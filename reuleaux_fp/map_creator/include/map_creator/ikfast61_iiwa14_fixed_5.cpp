/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x1000004a generated on 2021-07-14 01:53:20.512969
/// Generated using solver transform6d
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x1000004a);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61,x62,x63,x64;
x0=IKcos(j[0]);
x1=IKcos(j[1]);
x2=IKcos(j[2]);
x3=IKsin(j[0]);
x4=IKsin(j[2]);
x5=IKcos(j[3]);
x6=IKsin(j[1]);
x7=IKsin(j[3]);
x8=IKcos(j[4]);
x9=IKsin(j[4]);
x10=IKcos(j[6]);
x11=IKsin(j[6]);
x12=IKsin(j[5]);
x13=IKcos(j[5]);
x14=((0.4)*x3);
x15=((1.0)*x5);
x16=((0.126)*x7);
x17=((1.0)*x8);
x18=((1.0)*x7);
x19=((1.0)*x3);
x20=((1.0)*x13);
x21=((1.0)*x1);
x22=((1.0)*x9);
x23=((1.0)*x2);
x24=((0.4)*x0);
x25=((0.126)*x9);
x26=((0.126)*x8);
x27=(x5*x6);
x28=(x0*x6);
x29=(x0*x4);
x30=((-1.0)*x9);
x31=(x3*x6);
x32=(x1*x2);
x33=((-1.0)*x8);
x34=(x1*x5);
x35=(x2*x6);
x36=(x19*x4);
x37=(x4*x6*x9);
x38=(x15*x35);
x39=(x22*x4*x6);
x40=((((-1.0)*x36))+((x0*x32)));
x41=(((x3*x32))+x29);
x42=(((x35*x7))+x34);
x43=((((-1.0)*x0*x2*x21))+x36);
x44=((((-1.0)*x0*x23))+((x1*x36)));
x45=((((-1.0)*x1*x18))+x38);
x46=(((x21*x29))+((x19*x2)));
x47=((((-1.0)*x29))+(((-1.0)*x19*x32)));
x48=(x12*x42);
x49=(x40*x5);
x50=(x45*x8);
x51=(x44*x9);
x52=(x46*x9);
x53=(x49+((x28*x7)));
x54=(((x31*x7))+((x41*x5)));
x55=(((x0*x27))+((x43*x7)));
x56=((((-1.0)*x39))+x50);
x57=(((x17*x4*x6))+((x22*(((((-1.0)*x1*x7))+x38)))));
x58=((((-1.0)*x15*x40))+(((-1.0)*x18*x28)));
x59=(((x27*x3))+((x47*x7)));
x60=((((-1.0)*x15*x41))+(((-1.0)*x18*x31)));
x61=(x12*x55);
x62=(x58*x8);
x63=(x12*x59);
x64=(((x60*x8))+x51);
eerot[0]=(((x11*(((((-1.0)*x17*x46))+(((-1.0)*x22*x53))))))+(((-1.0)*x10*(((((1.0)*x13*((((x8*(((((-1.0)*x49))+(((-1.0)*x28*x7))))))+x52))))+(((1.0)*x61)))))));
eerot[1]=(((x10*((((x30*x53))+((x33*x46))))))+((x11*((((x13*((x52+x62))))+x61)))));
eerot[2]=(((x13*x55))+((x12*(((((-1.0)*x22*x46))+(((-1.0)*x17*x58)))))));
eetrans[0]=(((x7*((((x14*x4))+(((-1.0)*x24*x32))))))+((x13*(((((0.126)*x0*x27))+((x16*x43))))))+((x12*(((((-1.0)*x25*x46))+(((-1.0)*x26*x58))))))+((x24*x27))+(((0.42)*x28)));
eerot[3]=(((x10*(((((-1.0)*x20*x64))+(((-1.0)*x63))))))+((x11*((((x30*x54))+((x33*x44)))))));
eerot[4]=(((x11*((((x13*x64))+x63))))+((x10*(((((-1.0)*x17*x44))+(((-1.0)*x22*x54)))))));
eerot[5]=(((x13*x59))+((x12*(((((-1.0)*x22*x44))+(((-1.0)*x17*x60)))))));
eetrans[1]=(((x7*(((((-1.0)*x14*x32))+(((-1.0)*x24*x4))))))+((x12*(((((-1.0)*x25*x44))+(((-1.0)*x26*x60))))))+(((0.42)*x31))+((x14*x27))+((x13*(((((0.126)*x27*x3))+((x16*x47)))))));
eerot[6]=(((x11*x57))+((x10*(((((-1.0)*x48))+(((-1.0)*x20*x56)))))));
eerot[7]=(((x10*x57))+((x11*((((x13*x56))+x48)))));
eerot[8]=(((x13*x42))+((x12*(((((-1.0)*x17*x45))+x39)))));
eetrans[2]=((0.36)+((x13*((((x16*x35))+(((0.126)*x34))))))+((x12*((((x25*x4*x6))+(((-1.0)*x26*x45))))))+(((0.4)*x35*x7))+(((0.4)*x34))+(((0.42)*x1)));
}

IKFAST_API int GetNumFreeParameters() { return 1; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {5}; return freeparams; }
IKFAST_API int GetNumJoints() { return 7; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j6,cj6,sj6,htj6,j6mul,j5,cj5,sj5,htj5,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4,_ij6[2], _nj6,_ij5[2], _nj5;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j6=numeric_limits<IkReal>::quiet_NaN(); _ij6[0] = -1; _ij6[1] = -1; _nj6 = -1;  _ij5[0] = -1; _ij5[1] = -1; _nj5 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j5=pfree[0]; cj5=cos(pfree[0]); sj5=sin(pfree[0]), htj5=tan(pfree[0]*0.5);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=((-1.0)*r00);
new_r01=((-1.0)*r01);
new_r02=r02;
new_px=((((-0.126)*r02))+px);
new_r10=((-1.0)*r10);
new_r11=((-1.0)*r11);
new_r12=r12;
new_py=((((-0.126)*r12))+py);
new_r20=((-1.0)*r20);
new_r21=((-1.0)*r21);
new_r22=r22;
new_pz=((-0.36)+(((-0.126)*r22))+pz);
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x65=((1.0)*px);
IkReal x66=((1.0)*pz);
IkReal x67=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x67))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x66)));
rxp0_2=((((-1.0)*r10*x65))+((py*r00)));
rxp1_0=((((-1.0)*r21*x67))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x66)));
rxp1_2=((((-1.0)*r11*x65))+((py*r01)));
rxp2_0=(((pz*r12))+(((-1.0)*r22*x67)));
rxp2_1=(((px*r22))+(((-1.0)*r02*x66)));
rxp2_2=((((-1.0)*r12*x65))+((py*r02)));
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
cj3array[0]=((-1.00119047619048)+(((2.97619047619048)*pp)));
if( cj3array[0] >= -1-IKFAST_SINCOS_THRESH && cj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKacos(cj3array[0]);
    sj3array[0] = IKsin(j3array[0]);
    cj3array[1] = cj3array[0];
    j3array[1] = -j3array[0];
    sj3array[1] = -sj3array[0];
}
else if( isnan(cj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
IkReal j6eval[2];
IkReal x68=sj5*sj5;
j6eval[0]=((IKabs((npx*sj5)))+(IKabs((npy*sj5))));
j6eval[1]=(((x68*(npx*npx)))+((x68*(npy*npy))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
j4eval[0]=sj3;
j4eval[1]=sj5;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[4];
sj3=0;
cj3=1.0;
j3=0;
IkReal x69=npy*npy;
IkReal x70=npx*npx;
j6eval[0]=((((-1.0)*x70))+(((-1.0)*x69)));
j6eval[1]=1681.0;
j6eval[2]=sj5;
j6eval[3]=IKsign(((((-50.0)*x69))+(((-50.0)*x70))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  || IKabs(j6eval[3]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
sj3=0;
cj3=1.0;
j3=0;
IkReal x71=npz*npz;
IkReal x72=((2500.0)*x71);
IkReal x73=(((sj5*(npy*npy)))+((sj5*(npx*npx))));
j6eval[0]=x73;
j6eval[1]=((IKabs(((((-1.0)*npx*x72))+(((1681.0)*npx)))))+(IKabs((((npy*x72))+(((-1681.0)*npy))))));
j6eval[2]=IKsign(x73);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj3=0;
cj3=1.0;
j3=0;
sj5=0;
cj5=1.0;
j5=0;
j6eval[0]=((IKabs(npy))+(IKabs(npx)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j4, j6]

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
CheckValue<IkReal> x75 = IKatan2WithCheck(IkReal(((-1.0)*npx)),IkReal(npy),IKFAST_ATAN2_MAGTHRESH);
if(!x75.valid){
continue;
}
IkReal x74=x75.value;
j6array[0]=((-1.0)*x74);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x74)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*npy*(IKcos(j6))))+(((-1.0)*npx*(IKsin(j6)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[1];
sj3=0;
cj3=1.0;
j3=0;
sj5=0;
cj5=1.0;
j5=0;
j4eval[0]=((IKabs((((cj6*npy))+((npx*sj6)))))+(IKabs((((cj6*npx))+(((-1.0)*npy*sj6))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj3=0;
cj3=1.0;
j3=0;
sj5=0;
cj5=1.0;
j5=0;
IkReal x76=((1.0)*npy);
j4eval[0]=((IKabs((((cj6*npx))+(((-1.0)*sj6*x76)))))+(IKabs(((((-1.0)*npx*sj6))+(((-1.0)*cj6*x76))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
IkReal x77=((1.0)*npy);
CheckValue<IkReal> x79 = IKatan2WithCheck(IkReal((((cj6*npx))+(((-1.0)*sj6*x77)))),IkReal(((((-1.0)*npx*sj6))+(((-1.0)*cj6*x77)))),IKFAST_ATAN2_MAGTHRESH);
if(!x79.valid){
continue;
}
IkReal x78=x79.value;
j4array[0]=((-1.0)*x78);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x78)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
IkReal x80=IKcos(j4);
IkReal x81=IKsin(j4);
evalcond[0]=(((cj6*npx*x81))+(((-1.0)*npy*sj6*x81))+((cj6*npy*x80))+((npx*sj6*x80)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x1014 = IKatan2WithCheck(IkReal((((cj6*npy))+((npx*sj6)))),IkReal((((cj6*npx))+(((-1.0)*npy*sj6)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1014.valid){
continue;
}
IkReal x1013=x1014.value;
j4array[0]=((-1.0)*x1013);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x1013)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
IkReal x1015=IKcos(j4);
IkReal x1016=IKsin(j4);
IkReal x1017=((1.0)*sj6);
evalcond[0]=(((cj6*npx*x1015))+(((-1.0)*npx*x1016*x1017))+(((-1.0)*npy*x1015*x1017))+(((-1.0)*cj6*npy*x1016)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj3=0;
cj3=1.0;
j3=0;
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
j6eval[0]=((IKabs(npy))+(IKabs(npx)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j4, j6]

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
CheckValue<IkReal> x1019 = IKatan2WithCheck(IkReal(((-1.0)*npx)),IkReal(npy),IKFAST_ATAN2_MAGTHRESH);
if(!x1019.valid){
continue;
}
IkReal x1018=x1019.value;
j6array[0]=((-1.0)*x1018);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1018)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*npy*(IKcos(j6))))+(((-1.0)*npx*(IKsin(j6)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[1];
sj3=0;
cj3=1.0;
j3=0;
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
j4eval[0]=((IKabs((((cj6*npy))+((npx*sj6)))))+(IKabs(((((-1.0)*cj6*npx))+((npy*sj6))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj3=0;
cj3=1.0;
j3=0;
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x1020=((1.0)*npx);
j4eval[0]=((IKabs(((((-1.0)*cj6*npy))+(((-1.0)*sj6*x1020)))))+(IKabs(((((-1.0)*cj6*x1020))+((npy*sj6))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
IkReal x1021=((1.0)*cj6);
CheckValue<IkReal> x1023 = IKatan2WithCheck(IkReal(((((-1.0)*npx*x1021))+((npy*sj6)))),IkReal(((((-1.0)*npx*sj6))+(((-1.0)*npy*x1021)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1023.valid){
continue;
}
IkReal x1022=x1023.value;
j4array[0]=((-1.0)*x1022);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x1022)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
IkReal x1024=IKcos(j4);
IkReal x1025=IKsin(j4);
evalcond[0]=(((npy*sj6*x1025))+((cj6*npy*x1024))+((npx*sj6*x1024))+(((-1.0)*cj6*npx*x1025)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x1027 = IKatan2WithCheck(IkReal((((cj6*npy))+((npx*sj6)))),IkReal(((((-1.0)*cj6*npx))+((npy*sj6)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1027.valid){
continue;
}
IkReal x1026=x1027.value;
j4array[0]=((-1.0)*x1026);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x1026)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
IkReal x1028=IKcos(j4);
IkReal x1029=IKsin(j4);
IkReal x1030=((1.0)*npx);
evalcond[0]=(((npy*sj6*x1028))+(((-1.0)*sj6*x1029*x1030))+(((-1.0)*cj6*npy*x1029))+(((-1.0)*cj6*x1028*x1030)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4, j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1031=npz*npz;
IkReal x1032=((1.21951219512195)*x1031);
CheckValue<IkReal> x1033 = IKatan2WithCheck(IkReal(((((-0.82)*npy))+((npy*x1032)))),IkReal(((((0.82)*npx))+(((-1.0)*npx*x1032)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1033.valid){
continue;
}
CheckValue<IkReal> x1034=IKPowWithIntegerCheck(IKsign((((sj5*(npy*npy)))+((sj5*(npx*npx))))),-1);
if(!x1034.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1033.value)+(((1.5707963267949)*(x1034.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x1035=IKsin(j6);
IkReal x1036=IKcos(j6);
IkReal x1037=((1.0)*npx);
IkReal x1038=(npy*x1035);
evalcond[0]=((((-1.0)*x1035*x1037))+(((-1.0)*npy*x1036)));
evalcond[1]=(x1038+(((-1.0)*x1036*x1037))+(((0.82)*sj5)));
evalcond[2]=((0.82)+((sj5*x1038))+(((-1.0)*sj5*x1036*x1037))+(((-1.21951219512195)*(npz*npz))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[1];
sj3=0;
cj3=1.0;
j3=0;
IkReal x1039=((50.0)*npz);
j4eval[0]=((IKabs((((cj6*npy))+((npx*sj6)))))+(((0.024390243902439)*(IKabs((((cj6*npx*x1039))+(((-41.0)*npz*sj5))+(((-1.0)*npy*sj6*x1039))))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj3=0;
cj3=1.0;
j3=0;
IkReal x1040=((50.0)*npz);
j4eval[0]=((((0.024390243902439)*(IKabs((((cj6*npx*x1040))+(((-41.0)*npz*sj5))+(((-1.0)*npy*sj6*x1040)))))))+(IKabs(((((-1.0)*cj6*npy))+(((-1.0)*npx*sj6))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
IkReal x1041=((1.21951219512195)*npz);
CheckValue<IkReal> x1043 = IKatan2WithCheck(IkReal((((cj6*npx*x1041))+(((-1.0)*npz*sj5))+(((-1.0)*npy*sj6*x1041)))),IkReal(((((-1.0)*cj6*npy))+(((-1.0)*npx*sj6)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1043.valid){
continue;
}
IkReal x1042=x1043.value;
j4array[0]=((-1.0)*x1042);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x1042)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
IkReal x1044=IKcos(j4);
IkReal x1045=IKsin(j4);
IkReal x1046=(npz*x1045);
evalcond[0]=(((npx*sj6*x1044))+(((1.21951219512195)*cj6*npx*x1046))+(((-1.0)*sj5*x1046))+((cj6*npy*x1044))+(((-1.21951219512195)*npy*sj6*x1046)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
IkReal x1047=((1.21951219512195)*npz);
CheckValue<IkReal> x1049 = IKatan2WithCheck(IkReal((((cj6*npy))+((npx*sj6)))),IkReal((((cj6*npx*x1047))+(((-1.0)*npz*sj5))+(((-1.0)*npy*sj6*x1047)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1049.valid){
continue;
}
IkReal x1048=x1049.value;
j4array[0]=((-1.0)*x1048);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x1048)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
IkReal x1050=IKcos(j4);
IkReal x1051=IKsin(j4);
IkReal x1052=(npz*x1050);
IkReal x1053=((1.0)*x1051);
evalcond[0]=((((-1.0)*npx*sj6*x1053))+(((-1.0)*cj6*npy*x1053))+(((1.21951219512195)*cj6*npx*x1052))+(((-1.0)*sj5*x1052))+(((-1.21951219512195)*npy*sj6*x1052)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x1054 = IKatan2WithCheck(IkReal(((41.0)*npy*sj5)),IkReal(((-41.0)*npx*sj5)),IKFAST_ATAN2_MAGTHRESH);
if(!x1054.valid){
continue;
}
CheckValue<IkReal> x1055=IKPowWithIntegerCheck(IKsign(((((-50.0)*(npx*npx)))+(((-50.0)*(npy*npy))))),-1);
if(!x1055.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1054.value)+(((1.5707963267949)*(x1055.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x1056=IKsin(j6);
IkReal x1057=IKcos(j6);
IkReal x1058=((1.0)*npx);
IkReal x1059=(npy*x1056);
evalcond[0]=((((-1.0)*npy*x1057))+(((-1.0)*x1056*x1058)));
evalcond[1]=(x1059+(((0.82)*sj5))+(((-1.0)*x1057*x1058)));
evalcond[2]=((0.82)+((sj5*x1059))+(((-1.0)*sj5*x1057*x1058))+(((-1.21951219512195)*(npz*npz))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[1];
sj3=0;
cj3=1.0;
j3=0;
IkReal x1060=((50.0)*npz);
j4eval[0]=((IKabs((((cj6*npy))+((npx*sj6)))))+(((0.024390243902439)*(IKabs(((((-1.0)*npy*sj6*x1060))+((cj6*npx*x1060))+(((-41.0)*npz*sj5))))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj3=0;
cj3=1.0;
j3=0;
IkReal x1061=((50.0)*npz);
j4eval[0]=((IKabs(((((-1.0)*cj6*npy))+(((-1.0)*npx*sj6)))))+(((0.024390243902439)*(IKabs(((((-1.0)*npy*sj6*x1061))+((cj6*npx*x1061))+(((-41.0)*npz*sj5))))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
IkReal x1062=((1.21951219512195)*npz);
CheckValue<IkReal> x1064 = IKatan2WithCheck(IkReal(((((-1.0)*npy*sj6*x1062))+((cj6*npx*x1062))+(((-1.0)*npz*sj5)))),IkReal(((((-1.0)*cj6*npy))+(((-1.0)*npx*sj6)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1064.valid){
continue;
}
IkReal x1063=x1064.value;
j4array[0]=((-1.0)*x1063);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x1063)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
IkReal x1065=IKcos(j4);
IkReal x1066=IKsin(j4);
IkReal x1067=(npz*x1066);
evalcond[0]=(((npx*sj6*x1065))+(((-1.0)*sj5*x1067))+(((1.21951219512195)*cj6*npx*x1067))+((cj6*npy*x1065))+(((-1.21951219512195)*npy*sj6*x1067)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
IkReal x1068=((1.21951219512195)*npz);
CheckValue<IkReal> x1070 = IKatan2WithCheck(IkReal((((cj6*npy))+((npx*sj6)))),IkReal(((((-1.0)*npy*sj6*x1068))+((cj6*npx*x1068))+(((-1.0)*npz*sj5)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1070.valid){
continue;
}
IkReal x1069=x1070.value;
j4array[0]=((-1.0)*x1069);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x1069)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
IkReal x1071=IKcos(j4);
IkReal x1072=IKsin(j4);
IkReal x1073=(npz*x1071);
IkReal x1074=((1.0)*x1072);
evalcond[0]=((((-1.0)*npx*sj6*x1074))+(((-1.0)*cj6*npy*x1074))+(((1.21951219512195)*cj6*npx*x1073))+(((-1.0)*sj5*x1073))+(((-1.21951219512195)*npy*sj6*x1073)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x1075=npy*npy;
IkReal x1076=npx*npx;
j6eval[0]=(x1076+x1075);
j6eval[1]=IKsign(((((50.0)*x1076))+(((50.0)*x1075))));
j6eval[2]=((IKabs((npx*sj5)))+(IKabs((npy*sj5))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x1077=npz*npz;
IkReal x1078=((2500.0)*x1077);
IkReal x1079=(((sj5*(npy*npy)))+((sj5*(npx*npx))));
j6eval[0]=x1079;
j6eval[1]=((IKabs(((((-1.0)*npx))+((npx*x1078)))))+(IKabs(((((-1.0)*npy*x1078))+npy))));
j6eval[2]=IKsign(x1079);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj5=0;
cj5=1.0;
j5=0;
j6eval[0]=((IKabs(npy))+(IKabs(npx)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j4, j6]

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
CheckValue<IkReal> x1081 = IKatan2WithCheck(IkReal(((-1.0)*npx)),IkReal(npy),IKFAST_ATAN2_MAGTHRESH);
if(!x1081.valid){
continue;
}
IkReal x1080=x1081.value;
j6array[0]=((-1.0)*x1080);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1080)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*npy*(IKcos(j6))))+(((-1.0)*npx*(IKsin(j6)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj5=0;
cj5=1.0;
j5=0;
j4eval[0]=((IKabs((((cj6*npy))+((npx*sj6)))))+(IKabs((((cj6*npx))+(((-1.0)*npy*sj6))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj5=0;
cj5=1.0;
j5=0;
IkReal x1082=((1.0)*npy);
j4eval[0]=((IKabs((((cj6*npx))+(((-1.0)*sj6*x1082)))))+(IKabs(((((-1.0)*npx*sj6))+(((-1.0)*cj6*x1082))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
IkReal x1083=((1.0)*npy);
CheckValue<IkReal> x1085 = IKatan2WithCheck(IkReal((((cj6*npx))+(((-1.0)*sj6*x1083)))),IkReal(((((-1.0)*npx*sj6))+(((-1.0)*cj6*x1083)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1085.valid){
continue;
}
IkReal x1084=x1085.value;
j4array[0]=((-1.0)*x1084);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x1084)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
IkReal x1086=IKcos(j4);
IkReal x1087=IKsin(j4);
evalcond[0]=(((npx*sj6*x1086))+((cj6*npx*x1087))+(((-1.0)*npy*sj6*x1087))+((cj6*npy*x1086)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x1089 = IKatan2WithCheck(IkReal((((cj6*npy))+((npx*sj6)))),IkReal((((cj6*npx))+(((-1.0)*npy*sj6)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1089.valid){
continue;
}
IkReal x1088=x1089.value;
j4array[0]=((-1.0)*x1088);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x1088)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
IkReal x1090=IKcos(j4);
IkReal x1091=IKsin(j4);
IkReal x1092=((1.0)*sj6);
evalcond[0]=((((-1.0)*cj6*npy*x1091))+((cj6*npx*x1090))+(((-1.0)*npx*x1091*x1092))+(((-1.0)*npy*x1090*x1092)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
j6eval[0]=((IKabs(npy))+(IKabs(npx)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j4, j6]

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
CheckValue<IkReal> x1094 = IKatan2WithCheck(IkReal(((-1.0)*npx)),IkReal(npy),IKFAST_ATAN2_MAGTHRESH);
if(!x1094.valid){
continue;
}
IkReal x1093=x1094.value;
j6array[0]=((-1.0)*x1093);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1093)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*npy*(IKcos(j6))))+(((-1.0)*npx*(IKsin(j6)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
j4eval[0]=((IKabs((((cj6*npy))+((npx*sj6)))))+(IKabs(((((-1.0)*cj6*npx))+((npy*sj6))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x1095=((1.0)*npx);
j4eval[0]=((IKabs(((((-1.0)*sj6*x1095))+(((-1.0)*cj6*npy)))))+(IKabs(((((-1.0)*cj6*x1095))+((npy*sj6))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
IkReal x1096=((1.0)*cj6);
CheckValue<IkReal> x1098 = IKatan2WithCheck(IkReal((((npy*sj6))+(((-1.0)*npx*x1096)))),IkReal(((((-1.0)*npx*sj6))+(((-1.0)*npy*x1096)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1098.valid){
continue;
}
IkReal x1097=x1098.value;
j4array[0]=((-1.0)*x1097);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x1097)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
IkReal x1099=IKcos(j4);
IkReal x1100=IKsin(j4);
evalcond[0]=(((cj6*npy*x1099))+((npy*sj6*x1100))+(((-1.0)*cj6*npx*x1100))+((npx*sj6*x1099)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x1102 = IKatan2WithCheck(IkReal((((cj6*npy))+((npx*sj6)))),IkReal(((((-1.0)*cj6*npx))+((npy*sj6)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1102.valid){
continue;
}
IkReal x1101=x1102.value;
j4array[0]=((-1.0)*x1101);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x1101)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
IkReal x1103=IKcos(j4);
IkReal x1104=IKsin(j4);
IkReal x1105=((1.0)*npx);
evalcond[0]=((((-1.0)*cj6*x1103*x1105))+((npy*sj6*x1103))+(((-1.0)*sj6*x1104*x1105))+(((-1.0)*cj6*npy*x1104)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4, j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1106=npz*npz;
IkReal x1107=((50.0)*x1106);
CheckValue<IkReal> x1108 = IKatan2WithCheck(IkReal(((((-1.0)*npy*x1107))+(((0.02)*npy)))),IkReal((((npx*x1107))+(((-0.02)*npx)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1108.valid){
continue;
}
CheckValue<IkReal> x1109=IKPowWithIntegerCheck(IKsign((((sj5*(npy*npy)))+((sj5*(npx*npx))))),-1);
if(!x1109.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1108.value)+(((1.5707963267949)*(x1109.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x1110=IKsin(j6);
IkReal x1111=IKcos(j6);
IkReal x1112=((1.0)*npx);
IkReal x1113=(npy*x1110);
evalcond[0]=((((-1.0)*npy*x1111))+(((-1.0)*x1110*x1112)));
evalcond[1]=(x1113+(((-0.02)*sj5))+(((-1.0)*x1111*x1112)));
evalcond[2]=((-0.02)+(((-1.0)*sj5*x1111*x1112))+(((50.0)*(npz*npz)))+((sj5*x1113)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x1114=((50.0)*npz);
j4eval[0]=((IKabs((((cj6*npy))+((npx*sj6)))))+(IKabs((((npy*sj6*x1114))+(((-1.0)*npz*sj5))+(((-1.0)*cj6*npx*x1114))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x1115=((50.0)*npz);
j4eval[0]=((IKabs((((npy*sj6*x1115))+(((-1.0)*npz*sj5))+(((-1.0)*cj6*npx*x1115)))))+(IKabs(((((-1.0)*cj6*npy))+(((-1.0)*npx*sj6))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
IkReal x1116=((50.0)*npz);
CheckValue<IkReal> x1118 = IKatan2WithCheck(IkReal((((npy*sj6*x1116))+(((-1.0)*npz*sj5))+(((-1.0)*cj6*npx*x1116)))),IkReal(((((-1.0)*cj6*npy))+(((-1.0)*npx*sj6)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1118.valid){
continue;
}
IkReal x1117=x1118.value;
j4array[0]=((-1.0)*x1117);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x1117)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
IkReal x1119=IKcos(j4);
IkReal x1120=IKsin(j4);
IkReal x1121=(npz*x1120);
evalcond[0]=((((-50.0)*cj6*npx*x1121))+(((50.0)*npy*sj6*x1121))+(((-1.0)*sj5*x1121))+((cj6*npy*x1119))+((npx*sj6*x1119)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
IkReal x1122=((50.0)*npz);
CheckValue<IkReal> x1124 = IKatan2WithCheck(IkReal((((cj6*npy))+((npx*sj6)))),IkReal((((npy*sj6*x1122))+(((-1.0)*cj6*npx*x1122))+(((-1.0)*npz*sj5)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1124.valid){
continue;
}
IkReal x1123=x1124.value;
j4array[0]=((-1.0)*x1123);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x1123)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
IkReal x1125=IKcos(j4);
IkReal x1126=IKsin(j4);
IkReal x1127=(npz*x1125);
IkReal x1128=((1.0)*x1126);
evalcond[0]=((((-50.0)*cj6*npx*x1127))+(((50.0)*npy*sj6*x1127))+(((-1.0)*cj6*npy*x1128))+(((-1.0)*sj5*x1127))+(((-1.0)*npx*sj6*x1128)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x1129 = IKatan2WithCheck(IkReal((npy*sj5)),IkReal(((-1.0)*npx*sj5)),IKFAST_ATAN2_MAGTHRESH);
if(!x1129.valid){
continue;
}
CheckValue<IkReal> x1130=IKPowWithIntegerCheck(IKsign(((((50.0)*(npy*npy)))+(((50.0)*(npx*npx))))),-1);
if(!x1130.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1129.value)+(((1.5707963267949)*(x1130.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x1131=IKsin(j6);
IkReal x1132=IKcos(j6);
IkReal x1133=((1.0)*npx);
IkReal x1134=(npy*x1131);
evalcond[0]=((((-1.0)*npy*x1132))+(((-1.0)*x1131*x1133)));
evalcond[1]=(x1134+(((-0.02)*sj5))+(((-1.0)*x1132*x1133)));
evalcond[2]=((-0.02)+(((-1.0)*sj5*x1132*x1133))+(((50.0)*(npz*npz)))+((sj5*x1134)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x1135=((50.0)*npz);
j4eval[0]=((IKabs((((cj6*npy))+((npx*sj6)))))+(IKabs((((npy*sj6*x1135))+(((-1.0)*cj6*npx*x1135))+(((-1.0)*npz*sj5))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x1136=((50.0)*npz);
j4eval[0]=((IKabs(((((-1.0)*cj6*npy))+(((-1.0)*npx*sj6)))))+(IKabs((((npy*sj6*x1136))+(((-1.0)*cj6*npx*x1136))+(((-1.0)*npz*sj5))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
IkReal x1137=((50.0)*npz);
CheckValue<IkReal> x1139 = IKatan2WithCheck(IkReal((((npy*sj6*x1137))+(((-1.0)*cj6*npx*x1137))+(((-1.0)*npz*sj5)))),IkReal(((((-1.0)*cj6*npy))+(((-1.0)*npx*sj6)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1139.valid){
continue;
}
IkReal x1138=x1139.value;
j4array[0]=((-1.0)*x1138);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x1138)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
IkReal x1140=IKcos(j4);
IkReal x1141=IKsin(j4);
IkReal x1142=(npz*x1141);
evalcond[0]=((((-1.0)*sj5*x1142))+((cj6*npy*x1140))+(((50.0)*npy*sj6*x1142))+((npx*sj6*x1140))+(((-50.0)*cj6*npx*x1142)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
IkReal x1143=((50.0)*npz);
CheckValue<IkReal> x1145 = IKatan2WithCheck(IkReal((((cj6*npy))+((npx*sj6)))),IkReal(((((-1.0)*npz*sj5))+(((-1.0)*cj6*npx*x1143))+((npy*sj6*x1143)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1145.valid){
continue;
}
IkReal x1144=x1145.value;
j4array[0]=((-1.0)*x1144);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x1144)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
IkReal x1146=IKcos(j4);
IkReal x1147=IKsin(j4);
IkReal x1148=(npz*x1146);
IkReal x1149=((1.0)*x1147);
evalcond[0]=((((-1.0)*sj5*x1148))+(((-1.0)*npx*sj6*x1149))+(((50.0)*npy*sj6*x1148))+(((-50.0)*cj6*npx*x1148))+(((-1.0)*cj6*npy*x1149)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj5=0;
cj5=1.0;
j5=0;
IkReal x1150=npy*npy;
IkReal x1151=npx*npx*npx;
IkReal x1152=sj3*sj3;
IkReal x1153=(npx*x1150);
IkReal x1154=(npx*x1152);
IkReal x1155=((0.7056)*npy*x1152);
IkReal x1156=((((4.0)*npy*(npx*npx)))+(((4.0)*(npy*npy*npy))));
j6eval[0]=((IKabs((x1155+(((-1.0)*x1156)))))+(IKabs(((((8.0)*x1151))+(((8.0)*x1153))+(((-1.4112)*x1154)))))+(((0.5)*(IKabs(((((16.0)*x1153))+(((16.0)*x1151))+(((-2.8224)*x1154)))))))+(((0.5)*(IKabs((x1156+(((-1.0)*x1155))))))));
if( IKabs(j6eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j4, j6]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal x1157=sj3*sj3;
IkReal x1158=npy*npy;
IkReal x1159=npx*npx*npx;
IkReal x1160=(npx*x1158);
IkReal x1161=(npx*x1157);
IkReal x1162=((0.7056)*npy*x1157);
IkReal x1163=((((4.0)*npy*(npx*npx)))+(((4.0)*(npy*npy*npy))));
IkReal x1164=(x1162+(((-1.0)*x1163)));
IkReal x1165=((((8.0)*x1160))+(((8.0)*x1159))+(((-1.4112)*x1161)));
IkReal x1166=(x1163+(((-1.0)*x1162)));
op[0]=x1164;
op[1]=x1165;
op[2]=x1164;
op[3]=((((16.0)*x1159))+(((-2.8224)*x1161))+(((16.0)*x1160)));
op[4]=x1166;
op[5]=x1165;
op[6]=x1166;
polyroots6(op,zeror,numroots);
IkReal j6array[6], cj6array[6], sj6array[6], tempj6array[1];
int numsolutions = 0;
for(int ij6 = 0; ij6 < numroots; ++ij6)
{
IkReal htj6 = zeror[ij6];
tempj6array[0]=((2.0)*(atan(htj6)));
for(int kj6 = 0; kj6 < 1; ++kj6)
{
j6array[numsolutions] = tempj6array[kj6];
if( j6array[numsolutions] > IKPI )
{
    j6array[numsolutions]-=IK2PI;
}
else if( j6array[numsolutions] < -IKPI )
{
    j6array[numsolutions]+=IK2PI;
}
sj6array[numsolutions] = IKsin(j6array[numsolutions]);
cj6array[numsolutions] = IKcos(j6array[numsolutions]);
numsolutions++;
}
}
bool j6valid[6]={true,true,true,true,true,true};
_nj6 = 6;
for(int ij6 = 0; ij6 < numsolutions; ++ij6)
    {
if( !j6valid[ij6] )
{
    continue;
}
    j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
htj6 = IKtan(j6/2);

_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < numsolutions; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
{
IkReal j4eval[3];
sj5=0;
cj5=1.0;
j5=0;
IkReal x1167=((50.0)*npx);
IkReal x1168=((50.0)*npy);
j4eval[0]=sj3;
j4eval[1]=((IKabs(((((-1.0)*cj6*x1167))+((sj6*x1168)))))+(IKabs((((sj6*x1167))+((cj6*x1168))))));
j4eval[2]=IKsign(sj3);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
sj5=0;
cj5=1.0;
j5=0;
j4eval[0]=((((-1.0)*npy*sj3*sj6))+((cj6*npx*sj3)));
j4eval[1]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
sj5=0;
cj5=1.0;
j5=0;
j4eval[0]=sj3;
j4eval[1]=(((cj6*npy*sj3))+((npx*sj3*sj6)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1169=((50.0)*sj6);
IkReal x1170=(cj6*npy);
IkReal x1171=((21.0)*sj3);
IkReal x1172=(npx*npy);
CheckValue<IkReal> x1173=IKPowWithIntegerCheck(sj3,-1);
if(!x1173.valid){
continue;
}
CheckValue<IkReal> x1174=IKPowWithIntegerCheck((((npx*sj6*x1171))+((x1170*x1171))),-1);
if(!x1174.valid){
continue;
}
if( IKabs(((0.0476190476190476)*(x1173.value)*((((npx*x1169))+(((50.0)*x1170)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1174.value)*(((((-100.0)*cj6*npx*x1170))+(((50.0)*x1172))+(((-1.0)*cj6*x1169*(npx*npx)))+((npy*x1169*x1170)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.0476190476190476)*(x1173.value)*((((npx*x1169))+(((50.0)*x1170))))))+IKsqr(((x1174.value)*(((((-100.0)*cj6*npx*x1170))+(((50.0)*x1172))+(((-1.0)*cj6*x1169*(npx*npx)))+((npy*x1169*x1170))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((0.0476190476190476)*(x1173.value)*((((npx*x1169))+(((50.0)*x1170))))), ((x1174.value)*(((((-100.0)*cj6*npx*x1170))+(((50.0)*x1172))+(((-1.0)*cj6*x1169*(npx*npx)))+((npy*x1169*x1170))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x1175=IKcos(j4);
IkReal x1176=IKsin(j4);
IkReal x1177=((1.0)*cj6);
IkReal x1178=((1.0)*npy);
IkReal x1179=((0.42)*sj3);
IkReal x1180=(sj6*x1175);
IkReal x1181=(cj6*x1175);
IkReal x1182=((1.0)*npx*sj6);
evalcond[0]=(((npy*sj6))+(((-1.0)*x1175*x1179))+(((-1.0)*npx*x1177)));
evalcond[1]=(((x1176*x1179))+(((-1.0)*x1182))+(((-1.0)*npy*x1177)));
evalcond[2]=((((-1.0)*sj6*x1176*x1178))+((npy*x1181))+((cj6*npx*x1176))+((npx*x1180)));
evalcond[3]=((((-1.0)*x1176*x1182))+x1179+(((-1.0)*npy*x1176*x1177))+(((-1.0)*x1178*x1180))+((npx*x1181)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1183=((50.0)*npx);
IkReal x1184=((21.0)*sj3);
IkReal x1185=(npy*sj6);
IkReal x1186=((50.0)*cj6*sj6);
CheckValue<IkReal> x1187=IKPowWithIntegerCheck(((((-1.0)*x1184*x1185))+((cj6*npx*x1184))),-1);
if(!x1187.valid){
continue;
}
CheckValue<IkReal> x1188=IKPowWithIntegerCheck(sj3,-1);
if(!x1188.valid){
continue;
}
if( IKabs(((x1187.value)*(((((-1.0)*npy*x1183))+((cj6*npx*sj6*x1183))+(((100.0)*npx*npy*(cj6*cj6)))+(((-50.0)*cj6*npy*x1185)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.0476190476190476)*(x1188.value)*(((((-1.0)*cj6*x1183))+(((50.0)*x1185)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1187.value)*(((((-1.0)*npy*x1183))+((cj6*npx*sj6*x1183))+(((100.0)*npx*npy*(cj6*cj6)))+(((-50.0)*cj6*npy*x1185))))))+IKsqr(((0.0476190476190476)*(x1188.value)*(((((-1.0)*cj6*x1183))+(((50.0)*x1185))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1187.value)*(((((-1.0)*npy*x1183))+((cj6*npx*sj6*x1183))+(((100.0)*npx*npy*(cj6*cj6)))+(((-50.0)*cj6*npy*x1185))))), ((0.0476190476190476)*(x1188.value)*(((((-1.0)*cj6*x1183))+(((50.0)*x1185))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x1189=IKcos(j4);
IkReal x1190=IKsin(j4);
IkReal x1191=((1.0)*cj6);
IkReal x1192=((1.0)*npy);
IkReal x1193=((0.42)*sj3);
IkReal x1194=(sj6*x1189);
IkReal x1195=(cj6*x1189);
IkReal x1196=((1.0)*npx*sj6);
evalcond[0]=((((-1.0)*x1189*x1193))+(((-1.0)*npx*x1191))+((npy*sj6)));
evalcond[1]=((((-1.0)*npy*x1191))+(((-1.0)*x1196))+((x1190*x1193)));
evalcond[2]=((((-1.0)*sj6*x1190*x1192))+((npy*x1195))+((cj6*npx*x1190))+((npx*x1194)));
evalcond[3]=(x1193+(((-1.0)*x1190*x1196))+(((-1.0)*x1192*x1194))+(((-1.0)*npy*x1190*x1191))+((npx*x1195)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1197=((50.0)*npx);
IkReal x1198=((50.0)*npy);
CheckValue<IkReal> x1199=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x1199.valid){
continue;
}
CheckValue<IkReal> x1200 = IKatan2WithCheck(IkReal((((cj6*x1198))+((sj6*x1197)))),IkReal((((sj6*x1198))+(((-1.0)*cj6*x1197)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1200.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1199.value)))+(x1200.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x1201=IKcos(j4);
IkReal x1202=IKsin(j4);
IkReal x1203=((1.0)*cj6);
IkReal x1204=((1.0)*npy);
IkReal x1205=((0.42)*sj3);
IkReal x1206=(sj6*x1201);
IkReal x1207=(cj6*x1201);
IkReal x1208=((1.0)*npx*sj6);
evalcond[0]=(((npy*sj6))+(((-1.0)*npx*x1203))+(((-1.0)*x1201*x1205)));
evalcond[1]=(((x1202*x1205))+(((-1.0)*npy*x1203))+(((-1.0)*x1208)));
evalcond[2]=(((cj6*npx*x1202))+((npy*x1207))+((npx*x1206))+(((-1.0)*sj6*x1202*x1204)));
evalcond[3]=((((-1.0)*x1204*x1206))+x1205+(((-1.0)*x1202*x1208))+(((-1.0)*npy*x1202*x1203))+((npx*x1207)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x1209=npy*npy;
IkReal x1210=npx*npx*npx;
IkReal x1211=sj3*sj3;
IkReal x1212=(npx*x1209);
IkReal x1213=(npx*x1211);
IkReal x1214=((0.7056)*npy*x1211);
IkReal x1215=((((4.0)*npy*(npx*npx)))+(((4.0)*(npy*npy*npy))));
j6eval[0]=((((0.5)*(IKabs((x1215+(((-1.0)*x1214)))))))+(IKabs(((((8.0)*x1212))+(((8.0)*x1210))+(((-1.4112)*x1213)))))+(((0.5)*(IKabs(((((16.0)*x1210))+(((16.0)*x1212))+(((-2.8224)*x1213)))))))+(IKabs((x1214+(((-1.0)*x1215))))));
if( IKabs(j6eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j4, j6]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal x1216=sj3*sj3;
IkReal x1217=npy*npy;
IkReal x1218=npx*npx*npx;
IkReal x1219=(npx*x1217);
IkReal x1220=(npx*x1216);
IkReal x1221=((0.7056)*npy*x1216);
IkReal x1222=((((4.0)*npy*(npx*npx)))+(((4.0)*(npy*npy*npy))));
IkReal x1223=(x1221+(((-1.0)*x1222)));
IkReal x1224=((((8.0)*x1218))+(((8.0)*x1219))+(((-1.4112)*x1220)));
IkReal x1225=(x1222+(((-1.0)*x1221)));
op[0]=x1223;
op[1]=x1224;
op[2]=x1223;
op[3]=((((16.0)*x1218))+(((16.0)*x1219))+(((-2.8224)*x1220)));
op[4]=x1225;
op[5]=x1224;
op[6]=x1225;
polyroots6(op,zeror,numroots);
IkReal j6array[6], cj6array[6], sj6array[6], tempj6array[1];
int numsolutions = 0;
for(int ij6 = 0; ij6 < numroots; ++ij6)
{
IkReal htj6 = zeror[ij6];
tempj6array[0]=((2.0)*(atan(htj6)));
for(int kj6 = 0; kj6 < 1; ++kj6)
{
j6array[numsolutions] = tempj6array[kj6];
if( j6array[numsolutions] > IKPI )
{
    j6array[numsolutions]-=IK2PI;
}
else if( j6array[numsolutions] < -IKPI )
{
    j6array[numsolutions]+=IK2PI;
}
sj6array[numsolutions] = IKsin(j6array[numsolutions]);
cj6array[numsolutions] = IKcos(j6array[numsolutions]);
numsolutions++;
}
}
bool j6valid[6]={true,true,true,true,true,true};
_nj6 = 6;
for(int ij6 = 0; ij6 < numsolutions; ++ij6)
    {
if( !j6valid[ij6] )
{
    continue;
}
    j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
htj6 = IKtan(j6/2);

_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < numsolutions; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
{
IkReal j4eval[3];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x1226=((50.0)*npx);
IkReal x1227=((50.0)*npy);
j4eval[0]=sj3;
j4eval[1]=((IKabs(((((-1.0)*sj6*x1227))+((cj6*x1226)))))+(IKabs((((cj6*x1227))+((sj6*x1226))))));
j4eval[2]=IKsign(sj3);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
j4eval[0]=(((npy*sj3*sj6))+(((-1.0)*cj6*npx*sj3)));
j4eval[1]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
j4eval[0]=sj3;
j4eval[1]=(((cj6*npy*sj3))+((npx*sj3*sj6)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1228=((50.0)*sj6);
IkReal x1229=(cj6*npy);
IkReal x1230=((21.0)*sj3);
IkReal x1231=(npx*npy);
CheckValue<IkReal> x1232=IKPowWithIntegerCheck(sj3,-1);
if(!x1232.valid){
continue;
}
CheckValue<IkReal> x1233=IKPowWithIntegerCheck((((npx*sj6*x1230))+((x1229*x1230))),-1);
if(!x1233.valid){
continue;
}
if( IKabs(((0.0476190476190476)*(x1232.value)*((((npx*x1228))+(((50.0)*x1229)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1233.value)*(((((-1.0)*npy*x1228*x1229))+((cj6*x1228*(npx*npx)))+(((-50.0)*x1231))+(((100.0)*cj6*npx*x1229)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.0476190476190476)*(x1232.value)*((((npx*x1228))+(((50.0)*x1229))))))+IKsqr(((x1233.value)*(((((-1.0)*npy*x1228*x1229))+((cj6*x1228*(npx*npx)))+(((-50.0)*x1231))+(((100.0)*cj6*npx*x1229))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((0.0476190476190476)*(x1232.value)*((((npx*x1228))+(((50.0)*x1229))))), ((x1233.value)*(((((-1.0)*npy*x1228*x1229))+((cj6*x1228*(npx*npx)))+(((-50.0)*x1231))+(((100.0)*cj6*npx*x1229))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x1234=IKcos(j4);
IkReal x1235=IKsin(j4);
IkReal x1236=((1.0)*cj6);
IkReal x1237=(npx*sj6);
IkReal x1238=((0.42)*sj3);
IkReal x1239=(npy*sj6);
evalcond[0]=((((-1.0)*npx*x1236))+x1239+((x1234*x1238)));
evalcond[1]=((((-1.0)*x1237))+(((-1.0)*npy*x1236))+((x1235*x1238)));
evalcond[2]=(((x1234*x1237))+(((-1.0)*npx*x1235*x1236))+((x1235*x1239))+((cj6*npy*x1234)));
evalcond[3]=(x1238+((x1234*x1239))+(((-1.0)*npy*x1235*x1236))+(((-1.0)*npx*x1234*x1236))+(((-1.0)*x1235*x1237)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1240=((21.0)*sj3);
IkReal x1241=(cj6*npx);
IkReal x1242=(npy*sj6);
IkReal x1243=(npx*npy);
IkReal x1244=((50.0)*cj6*sj6);
CheckValue<IkReal> x1245=IKPowWithIntegerCheck((((x1240*x1242))+(((-1.0)*x1240*x1241))),-1);
if(!x1245.valid){
continue;
}
CheckValue<IkReal> x1246=IKPowWithIntegerCheck(sj3,-1);
if(!x1246.valid){
continue;
}
if( IKabs(((x1245.value)*(((((-50.0)*npx*sj6*x1241))+(((50.0)*x1243))+(((50.0)*cj6*npy*x1242))+(((-100.0)*cj6*npy*x1241)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.0476190476190476)*(x1246.value)*(((((-50.0)*x1242))+(((50.0)*x1241)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1245.value)*(((((-50.0)*npx*sj6*x1241))+(((50.0)*x1243))+(((50.0)*cj6*npy*x1242))+(((-100.0)*cj6*npy*x1241))))))+IKsqr(((0.0476190476190476)*(x1246.value)*(((((-50.0)*x1242))+(((50.0)*x1241))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1245.value)*(((((-50.0)*npx*sj6*x1241))+(((50.0)*x1243))+(((50.0)*cj6*npy*x1242))+(((-100.0)*cj6*npy*x1241))))), ((0.0476190476190476)*(x1246.value)*(((((-50.0)*x1242))+(((50.0)*x1241))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x1247=IKcos(j4);
IkReal x1248=IKsin(j4);
IkReal x1249=((1.0)*cj6);
IkReal x1250=(npx*sj6);
IkReal x1251=((0.42)*sj3);
IkReal x1252=(npy*sj6);
evalcond[0]=(((x1247*x1251))+x1252+(((-1.0)*npx*x1249)));
evalcond[1]=((((-1.0)*npy*x1249))+(((-1.0)*x1250))+((x1248*x1251)));
evalcond[2]=(((x1247*x1250))+((cj6*npy*x1247))+(((-1.0)*npx*x1248*x1249))+((x1248*x1252)));
evalcond[3]=(((x1247*x1252))+x1251+(((-1.0)*npy*x1248*x1249))+(((-1.0)*npx*x1247*x1249))+(((-1.0)*x1248*x1250)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1253=((50.0)*npx);
IkReal x1254=((50.0)*npy);
CheckValue<IkReal> x1255=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x1255.valid){
continue;
}
CheckValue<IkReal> x1256 = IKatan2WithCheck(IkReal((((sj6*x1253))+((cj6*x1254)))),IkReal(((((-1.0)*sj6*x1254))+((cj6*x1253)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1256.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1255.value)))+(x1256.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x1257=IKcos(j4);
IkReal x1258=IKsin(j4);
IkReal x1259=((1.0)*cj6);
IkReal x1260=(npx*sj6);
IkReal x1261=((0.42)*sj3);
IkReal x1262=(npy*sj6);
evalcond[0]=(x1262+(((-1.0)*npx*x1259))+((x1257*x1261)));
evalcond[1]=(((x1258*x1261))+(((-1.0)*npy*x1259))+(((-1.0)*x1260)));
evalcond[2]=(((cj6*npy*x1257))+((x1258*x1262))+(((-1.0)*npx*x1258*x1259))+((x1257*x1260)));
evalcond[3]=(x1261+(((-1.0)*npx*x1257*x1259))+(((-1.0)*npy*x1258*x1259))+((x1257*x1262))+(((-1.0)*x1258*x1260)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4, j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x1263=IKPowWithIntegerCheck(sj3,-1);
if(!x1263.valid){
continue;
}
CheckValue<IkReal> x1264=IKPowWithIntegerCheck(sj5,-1);
if(!x1264.valid){
continue;
}
cj4array[0]=((-2.38095238095238)*(x1263.value)*(x1264.value)*(((((0.42)*cj3*cj5))+(((0.4)*cj5))+(((-1.0)*npz)))));
if( cj4array[0] >= -1-IKFAST_SINCOS_THRESH && cj4array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKacos(cj4array[0]);
    sj4array[0] = IKsin(j4array[0]);
    cj4array[1] = cj4array[0];
    j4array[1] = -j4array[0];
    sj4array[1] = -sj4array[0];
}
else if( isnan(cj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

{
IkReal j6eval[3];
IkReal x1265=npy*npy;
IkReal x1266=npx*npx;
IkReal x1267=((21.0)*cj3);
IkReal x1268=((50.0)*cj5*npz);
IkReal x1269=(sj5*x1266);
IkReal x1270=(sj5*x1265);
IkReal x1271=((21.0)*sj3*sj4*sj5);
j6eval[0]=(x1270+x1269);
j6eval[1]=((IKabs((((npx*x1267))+((npy*x1271))+(((-1.0)*npx*x1268))+(((20.0)*npx)))))+(IKabs((((npx*x1271))+((npy*x1268))+(((-1.0)*npy*x1267))+(((-20.0)*npy))))));
j6eval[2]=IKsign(((((50.0)*x1269))+(((50.0)*x1270))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
IkReal x1272=npy*npy;
IkReal x1273=npx*npx;
IkReal x1274=((21.0)*npy);
IkReal x1275=(sj3*sj4);
IkReal x1276=(cj3*sj5);
IkReal x1277=((20.0)*sj5);
IkReal x1278=((21.0)*npx);
IkReal x1279=(cj4*cj5*sj3);
j6eval[0]=(x1272+x1273);
j6eval[1]=((IKabs((((x1275*x1278))+(((-1.0)*npy*x1277))+((x1274*x1279))+(((-1.0)*x1274*x1276)))))+(IKabs((((x1276*x1278))+((npx*x1277))+((x1274*x1275))+(((-1.0)*x1278*x1279))))));
j6eval[2]=IKsign(((((50.0)*x1273))+(((50.0)*x1272))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
IkReal x1280=npx*npx;
IkReal x1281=npy*npy;
IkReal x1282=cj4*cj4;
IkReal x1283=(cj4*cj5);
IkReal x1284=((21.0)*sj3*sj4);
IkReal x1285=((21.0)*sj3*x1282);
IkReal x1286=((50.0)*cj4*npz*sj5);
j6eval[0]=(((x1280*x1283))+((x1281*x1283)));
j6eval[1]=IKsign(((((50.0)*x1281*x1283))+(((50.0)*x1280*x1283))));
j6eval[2]=((IKabs((((npy*x1283*x1284))+(((-1.0)*npx*x1285))+((npx*x1286)))))+(IKabs((((npx*x1283*x1284))+(((-1.0)*npy*x1286))+((npy*x1285))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj5=1.0;
cj5=0;
j5=1.5707963267949;
IkReal x1287=npy*npy;
IkReal x1288=npx*npx;
IkReal x1289=((21.0)*npy);
IkReal x1290=(sj3*sj4);
IkReal x1291=((21.0)*npx);
j6eval[0]=(x1287+x1288);
j6eval[1]=IKsign(((((50.0)*x1287))+(((50.0)*x1288))));
j6eval[2]=((IKabs(((((-1.0)*cj3*x1289))+((x1290*x1291))+(((-20.0)*npy)))))+(IKabs((((cj3*x1291))+((x1289*x1290))+(((20.0)*npx))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
sj5=1.0;
cj5=0;
j5=1.5707963267949;
IkReal x1292=(npz*sj4);
IkReal x1293=((0.4)*cj4);
IkReal x1294=((0.42)*cj3*cj4);
IkReal x1295=(((cj4*(npx*npx)))+((cj4*(npy*npy))));
j6eval[0]=x1295;
j6eval[1]=((IKabs(((((-1.0)*npy*x1293))+(((-1.0)*npy*x1294))+((npx*x1292)))))+(IKabs((((npx*x1293))+((npx*x1294))+((npy*x1292))))));
j6eval[2]=IKsign(x1295);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
sj5=1.0;
cj5=0;
j5=1.5707963267949;
IkReal x1296=((0.42)*npy);
IkReal x1297=(npx*sj4);
IkReal x1298=((1.0)*cj4*npz);
IkReal x1299=(((sj4*(npy*npy)))+((npx*x1297)));
j6eval[0]=x1299;
j6eval[1]=IKsign(x1299);
j6eval[2]=((IKabs(((((-1.0)*npy*x1298))+((sj3*x1296))+(((0.4)*x1297))+(((0.42)*cj3*x1297)))))+(IKabs(((((-1.0)*npx*x1298))+(((-0.4)*npy*sj4))+(((-1.0)*cj3*sj4*x1296))+(((0.42)*npx*sj3))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj5=1.0;
cj5=0;
j5=1.5707963267949;
sj4=0;
cj4=1.0;
j4=0;
IkReal x1300=((21.0)*cj3);
IkReal x1301=((((-1.0)*(npy*npy)))+(((-1.0)*(npx*npx))));
j6eval[0]=x1301;
j6eval[1]=((IKabs(((((-1.0)*npx*x1300))+(((-20.0)*npx)))))+(IKabs((((npy*x1300))+(((20.0)*npy))))));
j6eval[2]=IKsign(x1301);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1302=((0.42)*cj3);
CheckValue<IkReal> x1303=IKPowWithIntegerCheck(IKsign(((((-1.0)*(npy*npy)))+(((-1.0)*(npx*npx))))),-1);
if(!x1303.valid){
continue;
}
CheckValue<IkReal> x1304 = IKatan2WithCheck(IkReal(((((0.4)*npy))+((npy*x1302)))),IkReal(((((-1.0)*npx*x1302))+(((-0.4)*npx)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1304.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1303.value)))+(x1304.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[2];
IkReal x1305=IKsin(j6);
IkReal x1306=IKcos(j6);
IkReal x1307=((1.0)*npx);
evalcond[0]=((((-1.0)*x1305*x1307))+(((-1.0)*npy*x1306)));
evalcond[1]=((0.4)+(((-1.0)*x1306*x1307))+((npy*x1305))+(((0.42)*cj3)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj5=1.0;
cj5=0;
j5=1.5707963267949;
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
IkReal x1308=((21.0)*cj3);
IkReal x1309=((((-1.0)*(npy*npy)))+(((-1.0)*(npx*npx))));
j6eval[0]=x1309;
j6eval[1]=((IKabs(((((-1.0)*npx*x1308))+(((-20.0)*npx)))))+(IKabs((((npy*x1308))+(((20.0)*npy))))));
j6eval[2]=IKsign(x1309);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1310=((0.42)*cj3);
CheckValue<IkReal> x1311=IKPowWithIntegerCheck(IKsign(((((-1.0)*(npy*npy)))+(((-1.0)*(npx*npx))))),-1);
if(!x1311.valid){
continue;
}
CheckValue<IkReal> x1312 = IKatan2WithCheck(IkReal(((((0.4)*npy))+((npy*x1310)))),IkReal(((((-1.0)*npx*x1310))+(((-0.4)*npx)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1312.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1311.value)))+(x1312.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[2];
IkReal x1313=IKsin(j6);
IkReal x1314=IKcos(j6);
IkReal x1315=((1.0)*npx);
evalcond[0]=((((-1.0)*x1313*x1315))+(((-1.0)*npy*x1314)));
evalcond[1]=((0.4)+(((-1.0)*x1314*x1315))+(((0.42)*cj3))+((npy*x1313)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj5=1.0;
cj5=0;
j5=1.5707963267949;
sj4=1.0;
cj4=0;
j4=1.5707963267949;
IkReal x1316=npy*npy;
IkReal x1317=npx*npx;
IkReal x1318=((21.0)*sj3);
IkReal x1319=((21.0)*cj3);
j6eval[0]=(x1317+x1316);
j6eval[1]=IKsign(((((50.0)*x1316))+(((50.0)*x1317))));
j6eval[2]=((IKabs((((npx*x1318))+(((-1.0)*npy*x1319))+(((-20.0)*npy)))))+(IKabs((((npx*x1319))+((npy*x1318))+(((20.0)*npx))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1320=((21.0)*sj3);
IkReal x1321=((21.0)*cj3);
CheckValue<IkReal> x1322 = IKatan2WithCheck(IkReal(((((-1.0)*npy*x1321))+(((-20.0)*npy))+((npx*x1320)))),IkReal((((npy*x1320))+((npx*x1321))+(((20.0)*npx)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1322.valid){
continue;
}
CheckValue<IkReal> x1323=IKPowWithIntegerCheck(IKsign(((((50.0)*(npy*npy)))+(((50.0)*(npx*npx))))),-1);
if(!x1323.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1322.value)+(((1.5707963267949)*(x1323.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[2];
IkReal x1324=IKsin(j6);
IkReal x1325=IKcos(j6);
IkReal x1326=((1.0)*npx);
evalcond[0]=((((-1.0)*x1324*x1326))+(((0.42)*sj3))+(((-1.0)*npy*x1325)));
evalcond[1]=((0.4)+(((-1.0)*x1325*x1326))+(((0.42)*cj3))+((npy*x1324)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=npz;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj5=1.0;
cj5=0;
j5=1.5707963267949;
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
IkReal x1327=npy*npy;
IkReal x1328=npx*npx;
IkReal x1329=((21.0)*sj3);
IkReal x1330=((21.0)*cj3);
j6eval[0]=((((-1.0)*x1328))+(((-1.0)*x1327)));
j6eval[1]=((IKabs(((((-20.0)*npx))+(((-1.0)*npx*x1330))+((npy*x1329)))))+(IKabs((((npy*x1330))+((npx*x1329))+(((20.0)*npy))))));
j6eval[2]=IKsign(((((-50.0)*x1328))+(((-50.0)*x1327))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1331=((21.0)*sj3);
IkReal x1332=((21.0)*cj3);
CheckValue<IkReal> x1333=IKPowWithIntegerCheck(IKsign(((((-50.0)*(npx*npx)))+(((-50.0)*(npy*npy))))),-1);
if(!x1333.valid){
continue;
}
CheckValue<IkReal> x1334 = IKatan2WithCheck(IkReal((((npx*x1331))+((npy*x1332))+(((20.0)*npy)))),IkReal((((npy*x1331))+(((-20.0)*npx))+(((-1.0)*npx*x1332)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1334.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1333.value)))+(x1334.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[2];
IkReal x1335=IKsin(j6);
IkReal x1336=IKcos(j6);
IkReal x1337=((1.0)*npx);
evalcond[0]=((((-1.0)*x1335*x1337))+(((-0.42)*sj3))+(((-1.0)*npy*x1336)));
evalcond[1]=((0.4)+((npy*x1335))+(((-1.0)*x1336*x1337))+(((0.42)*cj3)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1338=(npx*sj4);
IkReal x1339=((0.42)*cj3);
IkReal x1340=(npy*sj4);
IkReal x1341=((0.42)*sj3);
IkReal x1342=((1.0)*cj4*npz);
CheckValue<IkReal> x1343 = IKatan2WithCheck(IkReal(((((-1.0)*npx*x1342))+(((-1.0)*x1339*x1340))+(((-0.4)*x1340))+((npx*x1341)))),IkReal((((npy*x1341))+((x1338*x1339))+(((-1.0)*npy*x1342))+(((0.4)*x1338)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1343.valid){
continue;
}
CheckValue<IkReal> x1344=IKPowWithIntegerCheck(IKsign((((npy*x1340))+((npx*x1338)))),-1);
if(!x1344.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1343.value)+(((1.5707963267949)*(x1344.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x1345=IKsin(j6);
IkReal x1346=IKcos(j6);
IkReal x1347=((0.42)*sj3);
IkReal x1348=((1.0)*npx);
IkReal x1349=((1.0)*sj4);
IkReal x1350=(npy*x1346);
evalcond[0]=((0.4)+((npy*x1345))+(((-1.0)*x1346*x1348))+(((0.42)*cj3)));
evalcond[1]=((((-1.0)*x1350))+((sj4*x1347))+(((-1.0)*x1345*x1348)));
evalcond[2]=(((cj4*x1350))+(((-1.0)*npz*x1349))+((cj4*npx*x1345)));
evalcond[3]=(x1347+(((-1.0)*sj4*x1345*x1348))+(((-1.0)*cj4*npz))+(((-1.0)*x1349*x1350)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1351=(npz*sj4);
IkReal x1352=((0.4)*cj4);
IkReal x1353=((0.42)*cj3*cj4);
CheckValue<IkReal> x1354=IKPowWithIntegerCheck(IKsign((((cj4*(npx*npx)))+((cj4*(npy*npy))))),-1);
if(!x1354.valid){
continue;
}
CheckValue<IkReal> x1355 = IKatan2WithCheck(IkReal(((((-1.0)*npy*x1352))+(((-1.0)*npy*x1353))+((npx*x1351)))),IkReal((((npy*x1351))+((npx*x1352))+((npx*x1353)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1355.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1354.value)))+(x1355.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x1356=IKsin(j6);
IkReal x1357=IKcos(j6);
IkReal x1358=((0.42)*sj3);
IkReal x1359=((1.0)*npx);
IkReal x1360=((1.0)*sj4);
IkReal x1361=(npy*x1357);
evalcond[0]=((0.4)+((npy*x1356))+(((0.42)*cj3))+(((-1.0)*x1357*x1359)));
evalcond[1]=((((-1.0)*x1361))+((sj4*x1358))+(((-1.0)*x1356*x1359)));
evalcond[2]=(((cj4*npx*x1356))+((cj4*x1361))+(((-1.0)*npz*x1360)));
evalcond[3]=(x1358+(((-1.0)*cj4*npz))+(((-1.0)*sj4*x1356*x1359))+(((-1.0)*x1360*x1361)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1362=((21.0)*npy);
IkReal x1363=(sj3*sj4);
IkReal x1364=((21.0)*npx);
CheckValue<IkReal> x1365 = IKatan2WithCheck(IkReal((((x1363*x1364))+(((-1.0)*cj3*x1362))+(((-20.0)*npy)))),IkReal((((cj3*x1364))+((x1362*x1363))+(((20.0)*npx)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1365.valid){
continue;
}
CheckValue<IkReal> x1366=IKPowWithIntegerCheck(IKsign(((((50.0)*(npy*npy)))+(((50.0)*(npx*npx))))),-1);
if(!x1366.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1365.value)+(((1.5707963267949)*(x1366.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x1367=IKsin(j6);
IkReal x1368=IKcos(j6);
IkReal x1369=((0.42)*sj3);
IkReal x1370=((1.0)*npx);
IkReal x1371=((1.0)*sj4);
IkReal x1372=(npy*x1368);
evalcond[0]=((0.4)+((npy*x1367))+(((0.42)*cj3))+(((-1.0)*x1368*x1370)));
evalcond[1]=((((-1.0)*x1372))+((sj4*x1369))+(((-1.0)*x1367*x1370)));
evalcond[2]=(((cj4*npx*x1367))+(((-1.0)*npz*x1371))+((cj4*x1372)));
evalcond[3]=(x1369+(((-1.0)*x1371*x1372))+(((-1.0)*cj4*npz))+(((-1.0)*sj4*x1367*x1370)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj5=-1.0;
cj5=0;
j5=-1.5707963267949;
IkReal x1373=npy*npy;
IkReal x1374=npx*npx;
IkReal x1375=((21.0)*npy);
IkReal x1376=(sj3*sj4);
IkReal x1377=((21.0)*npx);
j6eval[0]=(x1373+x1374);
j6eval[1]=IKsign(((((50.0)*x1374))+(((50.0)*x1373))));
j6eval[2]=((IKabs((((x1375*x1376))+(((-1.0)*cj3*x1377))+(((-20.0)*npx)))))+(IKabs((((x1376*x1377))+((cj3*x1375))+(((20.0)*npy))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
sj5=-1.0;
cj5=0;
j5=-1.5707963267949;
IkReal x1378=((0.4)*cj4);
IkReal x1379=((0.42)*cj3*cj4);
IkReal x1380=((1.0)*npz*sj4);
IkReal x1381=(((cj4*(npx*npx)))+((cj4*(npy*npy))));
j6eval[0]=x1381;
j6eval[1]=((IKabs(((((-1.0)*npx*x1380))+((npy*x1378))+((npy*x1379)))))+(IKabs(((((-1.0)*npx*x1379))+(((-1.0)*npx*x1378))+(((-1.0)*npy*x1380))))));
j6eval[2]=IKsign(x1381);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
sj5=-1.0;
cj5=0;
j5=-1.5707963267949;
IkReal x1382=(cj4*npz);
IkReal x1383=(npx*sj4);
IkReal x1384=((0.42)*cj3);
IkReal x1385=(npy*sj4);
IkReal x1386=((0.42)*sj3);
IkReal x1387=(((npy*x1385))+((npx*x1383)));
j6eval[0]=x1387;
j6eval[1]=IKsign(x1387);
j6eval[2]=((IKabs((((npx*x1386))+((npx*x1382))+(((0.4)*x1385))+((x1384*x1385)))))+(IKabs(((((-1.0)*x1383*x1384))+((npy*x1382))+((npy*x1386))+(((-0.4)*x1383))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj5=-1.0;
cj5=0;
j5=-1.5707963267949;
sj4=0;
cj4=1.0;
j4=0;
IkReal x1388=((21.0)*cj3);
IkReal x1389=((npx*npx)+(npy*npy));
j6eval[0]=x1389;
j6eval[1]=((IKabs(((((-1.0)*npx*x1388))+(((-20.0)*npx)))))+(IKabs((((npy*x1388))+(((20.0)*npy))))));
j6eval[2]=IKsign(x1389);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1390=((0.42)*cj3);
CheckValue<IkReal> x1391 = IKatan2WithCheck(IkReal((((npy*x1390))+(((0.4)*npy)))),IkReal(((((-1.0)*npx*x1390))+(((-0.4)*npx)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1391.valid){
continue;
}
CheckValue<IkReal> x1392=IKPowWithIntegerCheck(IKsign(((npx*npx)+(npy*npy))),-1);
if(!x1392.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1391.value)+(((1.5707963267949)*(x1392.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[2];
IkReal x1393=IKcos(j6);
IkReal x1394=IKsin(j6);
IkReal x1395=((1.0)*x1394);
evalcond[0]=((((-1.0)*npy*x1393))+(((-1.0)*npx*x1395)));
evalcond[1]=((0.4)+((npx*x1393))+(((-1.0)*npy*x1395))+(((0.42)*cj3)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj5=-1.0;
cj5=0;
j5=-1.5707963267949;
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
IkReal x1396=((21.0)*cj3);
IkReal x1397=((npx*npx)+(npy*npy));
j6eval[0]=x1397;
j6eval[1]=((IKabs(((((-20.0)*npx))+(((-1.0)*npx*x1396)))))+(IKabs((((npy*x1396))+(((20.0)*npy))))));
j6eval[2]=IKsign(x1397);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1398=((0.42)*cj3);
CheckValue<IkReal> x1399=IKPowWithIntegerCheck(IKsign(((npx*npx)+(npy*npy))),-1);
if(!x1399.valid){
continue;
}
CheckValue<IkReal> x1400 = IKatan2WithCheck(IkReal((((npy*x1398))+(((0.4)*npy)))),IkReal(((((-1.0)*npx*x1398))+(((-0.4)*npx)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1400.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1399.value)))+(x1400.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[2];
IkReal x1401=IKcos(j6);
IkReal x1402=IKsin(j6);
IkReal x1403=((1.0)*x1402);
evalcond[0]=((((-1.0)*npx*x1403))+(((-1.0)*npy*x1401)));
evalcond[1]=((0.4)+((npx*x1401))+(((-1.0)*npy*x1403))+(((0.42)*cj3)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=npz;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj5=-1.0;
cj5=0;
j5=-1.5707963267949;
sj4=1.0;
cj4=0;
j4=1.5707963267949;
IkReal x1404=npy*npy;
IkReal x1405=npx*npx;
IkReal x1406=((21.0)*sj3);
IkReal x1407=((21.0)*cj3);
j6eval[0]=(x1405+x1404);
j6eval[1]=((IKabs((((npx*x1406))+((npy*x1407))+(((20.0)*npy)))))+(IKabs(((((-1.0)*npx*x1407))+((npy*x1406))+(((-20.0)*npx))))));
j6eval[2]=IKsign(((((50.0)*x1404))+(((50.0)*x1405))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1408=((21.0)*sj3);
IkReal x1409=((21.0)*cj3);
CheckValue<IkReal> x1410=IKPowWithIntegerCheck(IKsign(((((50.0)*(npy*npy)))+(((50.0)*(npx*npx))))),-1);
if(!x1410.valid){
continue;
}
CheckValue<IkReal> x1411 = IKatan2WithCheck(IkReal((((npx*x1408))+((npy*x1409))+(((20.0)*npy)))),IkReal(((((-1.0)*npx*x1409))+((npy*x1408))+(((-20.0)*npx)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1411.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1410.value)))+(x1411.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[2];
IkReal x1412=IKcos(j6);
IkReal x1413=IKsin(j6);
IkReal x1414=((1.0)*x1413);
evalcond[0]=((((-1.0)*npy*x1412))+(((0.42)*sj3))+(((-1.0)*npx*x1414)));
evalcond[1]=((0.4)+(((0.42)*cj3))+(((-1.0)*npy*x1414))+((npx*x1412)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj5=-1.0;
cj5=0;
j5=-1.5707963267949;
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
IkReal x1415=npy*npy;
IkReal x1416=npx*npx;
IkReal x1417=((21.0)*sj3);
IkReal x1418=((21.0)*cj3);
j6eval[0]=(x1415+x1416);
j6eval[1]=IKsign(((((50.0)*x1415))+(((50.0)*x1416))));
j6eval[2]=((IKabs(((((-20.0)*npx))+(((-1.0)*npx*x1418))+(((-1.0)*npy*x1417)))))+(IKabs(((((-1.0)*npx*x1417))+((npy*x1418))+(((20.0)*npy))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1419=((21.0)*sj3);
IkReal x1420=((21.0)*cj3);
CheckValue<IkReal> x1421 = IKatan2WithCheck(IkReal(((((-1.0)*npx*x1419))+((npy*x1420))+(((20.0)*npy)))),IkReal(((((-20.0)*npx))+(((-1.0)*npy*x1419))+(((-1.0)*npx*x1420)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1421.valid){
continue;
}
CheckValue<IkReal> x1422=IKPowWithIntegerCheck(IKsign(((((50.0)*(npy*npy)))+(((50.0)*(npx*npx))))),-1);
if(!x1422.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1421.value)+(((1.5707963267949)*(x1422.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[2];
IkReal x1423=IKcos(j6);
IkReal x1424=IKsin(j6);
IkReal x1425=((1.0)*x1424);
evalcond[0]=((((-0.42)*sj3))+(((-1.0)*npy*x1423))+(((-1.0)*npx*x1425)));
evalcond[1]=((0.4)+(((0.42)*cj3))+((npx*x1423))+(((-1.0)*npy*x1425)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1426=(cj4*npz);
IkReal x1427=(npx*sj4);
IkReal x1428=((0.42)*cj3);
IkReal x1429=(npy*sj4);
IkReal x1430=((0.42)*sj3);
CheckValue<IkReal> x1431=IKPowWithIntegerCheck(IKsign((((npx*x1427))+((npy*x1429)))),-1);
if(!x1431.valid){
continue;
}
CheckValue<IkReal> x1432 = IKatan2WithCheck(IkReal((((npx*x1430))+(((0.4)*x1429))+((x1428*x1429))+((npx*x1426)))),IkReal(((((-1.0)*x1427*x1428))+((npy*x1430))+(((-0.4)*x1427))+((npy*x1426)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1432.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1431.value)))+(x1432.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x1433=IKsin(j6);
IkReal x1434=IKcos(j6);
IkReal x1435=((0.42)*sj3);
IkReal x1436=((1.0)*sj4);
IkReal x1437=(npy*x1434);
IkReal x1438=(npx*x1433);
evalcond[0]=((0.4)+((npx*x1434))+(((0.42)*cj3))+(((-1.0)*npy*x1433)));
evalcond[1]=(((cj4*x1438))+((cj4*x1437))+((npz*sj4)));
evalcond[2]=((((-1.0)*x1438))+(((-1.0)*x1437))+((sj4*x1435)));
evalcond[3]=((((-1.0)*x1436*x1437))+(((-1.0)*x1436*x1438))+((cj4*npz))+x1435);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1439=((0.4)*cj4);
IkReal x1440=((1.0)*npz*sj4);
IkReal x1441=((0.42)*cj3*cj4);
CheckValue<IkReal> x1442 = IKatan2WithCheck(IkReal(((((-1.0)*npx*x1440))+((npy*x1441))+((npy*x1439)))),IkReal(((((-1.0)*npx*x1441))+(((-1.0)*npy*x1440))+(((-1.0)*npx*x1439)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1442.valid){
continue;
}
CheckValue<IkReal> x1443=IKPowWithIntegerCheck(IKsign((((cj4*(npx*npx)))+((cj4*(npy*npy))))),-1);
if(!x1443.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1442.value)+(((1.5707963267949)*(x1443.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x1444=IKsin(j6);
IkReal x1445=IKcos(j6);
IkReal x1446=((0.42)*sj3);
IkReal x1447=((1.0)*sj4);
IkReal x1448=(npy*x1445);
IkReal x1449=(npx*x1444);
evalcond[0]=((0.4)+(((-1.0)*npy*x1444))+((npx*x1445))+(((0.42)*cj3)));
evalcond[1]=(((cj4*x1448))+((cj4*x1449))+((npz*sj4)));
evalcond[2]=(((sj4*x1446))+(((-1.0)*x1449))+(((-1.0)*x1448)));
evalcond[3]=((((-1.0)*x1447*x1448))+(((-1.0)*x1447*x1449))+((cj4*npz))+x1446);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1450=((21.0)*npy);
IkReal x1451=(sj3*sj4);
IkReal x1452=((21.0)*npx);
CheckValue<IkReal> x1453 = IKatan2WithCheck(IkReal((((cj3*x1450))+((x1451*x1452))+(((20.0)*npy)))),IkReal(((((-1.0)*cj3*x1452))+((x1450*x1451))+(((-20.0)*npx)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1453.valid){
continue;
}
CheckValue<IkReal> x1454=IKPowWithIntegerCheck(IKsign(((((50.0)*(npy*npy)))+(((50.0)*(npx*npx))))),-1);
if(!x1454.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1453.value)+(((1.5707963267949)*(x1454.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x1455=IKsin(j6);
IkReal x1456=IKcos(j6);
IkReal x1457=((0.42)*sj3);
IkReal x1458=((1.0)*sj4);
IkReal x1459=(npy*x1456);
IkReal x1460=(npx*x1455);
evalcond[0]=((0.4)+(((-1.0)*npy*x1455))+((npx*x1456))+(((0.42)*cj3)));
evalcond[1]=(((cj4*x1459))+((npz*sj4))+((cj4*x1460)));
evalcond[2]=((((-1.0)*x1459))+((sj4*x1457))+(((-1.0)*x1460)));
evalcond[3]=((((-1.0)*x1458*x1460))+(((-1.0)*x1458*x1459))+((cj4*npz))+x1457);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
IkReal x1461=npy*npy;
IkReal x1462=npx*npx;
IkReal x1463=(cj5*x1462);
IkReal x1464=((21.0)*cj5*sj3);
IkReal x1465=(cj5*x1461);
IkReal x1466=((50.0)*npz*sj5);
j6eval[0]=(x1465+x1463);
j6eval[1]=IKsign(((((50.0)*x1463))+(((50.0)*x1465))));
j6eval[2]=((IKabs((((npx*x1464))+(((-1.0)*npy*x1466)))))+(IKabs((((npx*x1466))+((npy*x1464))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
IkReal x1467=npy*npy;
IkReal x1468=npx*npx;
IkReal x1469=(npy*sj5);
IkReal x1470=((21.0)*cj3);
IkReal x1471=((21.0)*sj3);
IkReal x1472=(npx*sj5);
j6eval[0]=(x1468+x1467);
j6eval[1]=((IKabs((((npy*x1471))+(((20.0)*x1472))+((x1470*x1472)))))+(IKabs(((((-20.0)*x1469))+(((-1.0)*x1469*x1470))+((npx*x1471))))));
j6eval[2]=IKsign(((((50.0)*x1467))+(((50.0)*x1468))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
IkReal x1473=npy*npy;
IkReal x1474=npx*npx;
IkReal x1475=((21.0)*cj3);
IkReal x1476=((50.0)*cj5*npz);
IkReal x1477=((21.0)*sj3*sj5);
IkReal x1478=(sj5*x1474);
IkReal x1479=(sj5*x1473);
j6eval[0]=(x1478+x1479);
j6eval[1]=((IKabs(((((-1.0)*npy*x1475))+((npy*x1476))+((npx*x1477))+(((-20.0)*npy)))))+(IKabs((((npy*x1477))+(((-1.0)*npx*x1476))+((npx*x1475))+(((20.0)*npx))))));
j6eval[2]=IKsign(((((50.0)*x1479))+(((50.0)*x1478))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[4];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=0;
cj5=1.0;
j5=0;
IkReal x1480=npy*npy;
IkReal x1481=npx*npx;
j6eval[0]=(x1481+x1480);
j6eval[1]=IKsign(((((50.0)*x1480))+(((50.0)*x1481))));
j6eval[2]=441.0;
j6eval[3]=sj3;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  || IKabs(j6eval[3]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=0;
cj5=1.0;
j5=0;
sj3=0;
cj3=1.0;
j3=0;
j6eval[0]=((IKabs(npy))+(IKabs(npx)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
CheckValue<IkReal> x1483 = IKatan2WithCheck(IkReal(((-1.0)*npx)),IkReal(npy),IKFAST_ATAN2_MAGTHRESH);
if(!x1483.valid){
continue;
}
IkReal x1482=x1483.value;
j6array[0]=((-1.0)*x1482);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1482)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*npy*(IKcos(j6))))+(((-1.0)*npx*(IKsin(j6)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=0;
cj5=1.0;
j5=0;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j6eval[0]=((IKabs(npy))+(IKabs(npx)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
CheckValue<IkReal> x1485 = IKatan2WithCheck(IkReal(((-1.0)*npx)),IkReal(npy),IKFAST_ATAN2_MAGTHRESH);
if(!x1485.valid){
continue;
}
IkReal x1484=x1485.value;
j6array[0]=((-1.0)*x1484);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1484)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*npy*(IKcos(j6))))+(((-1.0)*npx*(IKsin(j6)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1486=((21.0)*sj3);
CheckValue<IkReal> x1487 = IKatan2WithCheck(IkReal((npx*x1486)),IkReal((npy*x1486)),IKFAST_ATAN2_MAGTHRESH);
if(!x1487.valid){
continue;
}
CheckValue<IkReal> x1488=IKPowWithIntegerCheck(IKsign(((((50.0)*(npy*npy)))+(((50.0)*(npx*npx))))),-1);
if(!x1488.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1487.value)+(((1.5707963267949)*(x1488.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[2];
IkReal x1489=IKsin(j6);
IkReal x1490=IKcos(j6);
IkReal x1491=((1.0)*npx);
evalcond[0]=(((npy*x1489))+(((-1.0)*x1490*x1491)));
evalcond[1]=((((0.42)*sj3))+(((-1.0)*npy*x1490))+(((-1.0)*x1489*x1491)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[4];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x1492=npy*npy;
IkReal x1493=npx*npx;
j6eval[0]=(x1492+x1493);
j6eval[1]=IKsign(((((50.0)*x1493))+(((50.0)*x1492))));
j6eval[2]=441.0;
j6eval[3]=sj3;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  || IKabs(j6eval[3]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj3=0;
cj3=1.0;
j3=0;
j6eval[0]=((IKabs(npy))+(IKabs(npx)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
CheckValue<IkReal> x1495 = IKatan2WithCheck(IkReal(((-1.0)*npx)),IkReal(npy),IKFAST_ATAN2_MAGTHRESH);
if(!x1495.valid){
continue;
}
IkReal x1494=x1495.value;
j6array[0]=((-1.0)*x1494);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1494)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*npy*(IKcos(j6))))+(((-1.0)*npx*(IKsin(j6)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j6eval[0]=((IKabs(npy))+(IKabs(npx)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
CheckValue<IkReal> x1497 = IKatan2WithCheck(IkReal(((-1.0)*npx)),IkReal(npy),IKFAST_ATAN2_MAGTHRESH);
if(!x1497.valid){
continue;
}
IkReal x1496=x1497.value;
j6array[0]=((-1.0)*x1496);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1496)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*npy*(IKcos(j6))))+(((-1.0)*npx*(IKsin(j6)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1498=((21.0)*sj3);
CheckValue<IkReal> x1499 = IKatan2WithCheck(IkReal((npx*x1498)),IkReal((npy*x1498)),IKFAST_ATAN2_MAGTHRESH);
if(!x1499.valid){
continue;
}
CheckValue<IkReal> x1500=IKPowWithIntegerCheck(IKsign(((((50.0)*(npy*npy)))+(((50.0)*(npx*npx))))),-1);
if(!x1500.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1499.value)+(((1.5707963267949)*(x1500.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[2];
IkReal x1501=IKsin(j6);
IkReal x1502=IKcos(j6);
IkReal x1503=((1.0)*npx);
evalcond[0]=(((npy*x1501))+(((-1.0)*x1502*x1503)));
evalcond[1]=((((-1.0)*npy*x1502))+(((0.42)*sj3))+(((-1.0)*x1501*x1503)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1504=((50.0)*sj5);
IkReal x1505=((21.0)*cj3);
IkReal x1506=((50.0)*cj5*npz);
IkReal x1507=((21.0)*sj3*sj5);
CheckValue<IkReal> x1508=IKPowWithIntegerCheck(IKsign((((x1504*(npx*npx)))+((x1504*(npy*npy))))),-1);
if(!x1508.valid){
continue;
}
CheckValue<IkReal> x1509 = IKatan2WithCheck(IkReal((((npy*x1506))+(((-1.0)*npy*x1505))+(((-20.0)*npy))+((npx*x1507)))),IkReal((((npy*x1507))+(((-1.0)*npx*x1506))+((npx*x1505))+(((20.0)*npx)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1509.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1508.value)))+(x1509.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x1510=IKcos(j6);
IkReal x1511=IKsin(j6);
IkReal x1512=((1.0)*sj5);
IkReal x1513=((1.0)*cj5);
IkReal x1514=((0.42)*cj3);
IkReal x1515=(npy*x1511);
IkReal x1516=(npx*x1510);
evalcond[0]=((((-1.0)*npy*x1510))+(((0.42)*sj3))+(((-1.0)*npx*x1511)));
evalcond[1]=((((-1.0)*x1513*x1515))+(((-1.0)*npz*x1512))+((cj5*x1516)));
evalcond[2]=(((sj5*x1514))+(((-1.0)*x1516))+x1515+(((0.4)*sj5)));
evalcond[3]=((0.4)+((sj5*x1515))+(((-1.0)*npz*x1513))+x1514+(((-1.0)*x1512*x1516)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1517=(npy*sj5);
IkReal x1518=((21.0)*cj3);
IkReal x1519=((21.0)*sj3);
IkReal x1520=(npx*sj5);
CheckValue<IkReal> x1521=IKPowWithIntegerCheck(IKsign(((((50.0)*(npy*npy)))+(((50.0)*(npx*npx))))),-1);
if(!x1521.valid){
continue;
}
CheckValue<IkReal> x1522 = IKatan2WithCheck(IkReal(((((-1.0)*x1517*x1518))+((npx*x1519))+(((-20.0)*x1517)))),IkReal(((((20.0)*x1520))+((npy*x1519))+((x1518*x1520)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1522.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1521.value)))+(x1522.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x1523=IKcos(j6);
IkReal x1524=IKsin(j6);
IkReal x1525=((1.0)*sj5);
IkReal x1526=((1.0)*cj5);
IkReal x1527=((0.42)*cj3);
IkReal x1528=(npy*x1524);
IkReal x1529=(npx*x1523);
evalcond[0]=((((0.42)*sj3))+(((-1.0)*npx*x1524))+(((-1.0)*npy*x1523)));
evalcond[1]=((((-1.0)*npz*x1525))+((cj5*x1529))+(((-1.0)*x1526*x1528)));
evalcond[2]=(((sj5*x1527))+x1528+(((0.4)*sj5))+(((-1.0)*x1529)));
evalcond[3]=((0.4)+((sj5*x1528))+(((-1.0)*x1525*x1529))+(((-1.0)*npz*x1526))+x1527);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1530=((50.0)*cj5);
IkReal x1531=((21.0)*cj5*sj3);
IkReal x1532=((50.0)*npz*sj5);
CheckValue<IkReal> x1533=IKPowWithIntegerCheck(IKsign((((x1530*(npy*npy)))+((x1530*(npx*npx))))),-1);
if(!x1533.valid){
continue;
}
CheckValue<IkReal> x1534 = IKatan2WithCheck(IkReal(((((-1.0)*npy*x1532))+((npx*x1531)))),IkReal((((npy*x1531))+((npx*x1532)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1534.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1533.value)))+(x1534.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x1535=IKcos(j6);
IkReal x1536=IKsin(j6);
IkReal x1537=((1.0)*sj5);
IkReal x1538=((1.0)*cj5);
IkReal x1539=((0.42)*cj3);
IkReal x1540=(npy*x1536);
IkReal x1541=(npx*x1535);
evalcond[0]=((((0.42)*sj3))+(((-1.0)*npx*x1536))+(((-1.0)*npy*x1535)));
evalcond[1]=(((cj5*x1541))+(((-1.0)*npz*x1537))+(((-1.0)*x1538*x1540)));
evalcond[2]=((((-1.0)*x1541))+((sj5*x1539))+x1540+(((0.4)*sj5)));
evalcond[3]=((0.4)+(((-1.0)*npz*x1538))+x1539+(((-1.0)*x1537*x1541))+((sj5*x1540)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
IkReal x1542=npy*npy;
IkReal x1543=npx*npx;
IkReal x1544=(cj5*x1543);
IkReal x1545=((21.0)*cj5*sj3);
IkReal x1546=(cj5*x1542);
IkReal x1547=((50.0)*npz*sj5);
j6eval[0]=(x1546+x1544);
j6eval[1]=IKsign(((((50.0)*x1546))+(((50.0)*x1544))));
j6eval[2]=((IKabs(((((-1.0)*npy*x1547))+(((-1.0)*npx*x1545)))))+(IKabs(((((-1.0)*npy*x1545))+((npx*x1547))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
IkReal x1548=npy*npy;
IkReal x1549=npx*npx;
IkReal x1550=((21.0)*sj3);
IkReal x1551=((20.0)*sj5);
IkReal x1552=((21.0)*cj3*sj5);
j6eval[0]=((((-1.0)*x1548))+(((-1.0)*x1549)));
j6eval[1]=((IKabs((((npy*x1551))+((npy*x1552))+((npx*x1550)))))+(IKabs((((npy*x1550))+(((-1.0)*npx*x1552))+(((-1.0)*npx*x1551))))));
j6eval[2]=IKsign(((((-50.0)*x1548))+(((-50.0)*x1549))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
IkReal x1553=npy*npy;
IkReal x1554=npx*npx;
IkReal x1555=((21.0)*cj3);
IkReal x1556=((50.0)*cj5*npz);
IkReal x1557=((21.0)*sj3*sj5);
IkReal x1558=(sj5*x1554);
IkReal x1559=(sj5*x1553);
j6eval[0]=(x1559+x1558);
j6eval[1]=((IKabs(((((-20.0)*npy))+((npy*x1556))+(((-1.0)*npx*x1557))+(((-1.0)*npy*x1555)))))+(IKabs((((npx*x1555))+(((-1.0)*npx*x1556))+(((20.0)*npx))+(((-1.0)*npy*x1557))))));
j6eval[2]=IKsign(((((50.0)*x1558))+(((50.0)*x1559))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[4];
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
sj5=0;
cj5=1.0;
j5=0;
IkReal x1560=npy*npy;
IkReal x1561=npx*npx;
j6eval[0]=((((-1.0)*x1560))+(((-1.0)*x1561)));
j6eval[1]=441.0;
j6eval[2]=sj3;
j6eval[3]=IKsign(((((-50.0)*x1561))+(((-50.0)*x1560))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  || IKabs(j6eval[3]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
sj5=0;
cj5=1.0;
j5=0;
sj3=0;
cj3=1.0;
j3=0;
j6eval[0]=((IKabs(npy))+(IKabs(npx)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
CheckValue<IkReal> x1563 = IKatan2WithCheck(IkReal(((-1.0)*npx)),IkReal(npy),IKFAST_ATAN2_MAGTHRESH);
if(!x1563.valid){
continue;
}
IkReal x1562=x1563.value;
j6array[0]=((-1.0)*x1562);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1562)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*npy*(IKcos(j6))))+(((-1.0)*npx*(IKsin(j6)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
sj5=0;
cj5=1.0;
j5=0;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j6eval[0]=((IKabs(npy))+(IKabs(npx)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
CheckValue<IkReal> x1565 = IKatan2WithCheck(IkReal(((-1.0)*npx)),IkReal(npy),IKFAST_ATAN2_MAGTHRESH);
if(!x1565.valid){
continue;
}
IkReal x1564=x1565.value;
j6array[0]=((-1.0)*x1564);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1564)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*npy*(IKcos(j6))))+(((-1.0)*npx*(IKsin(j6)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1566=((21.0)*sj3);
CheckValue<IkReal> x1567 = IKatan2WithCheck(IkReal((npx*x1566)),IkReal((npy*x1566)),IKFAST_ATAN2_MAGTHRESH);
if(!x1567.valid){
continue;
}
CheckValue<IkReal> x1568=IKPowWithIntegerCheck(IKsign(((((-50.0)*(npx*npx)))+(((-50.0)*(npy*npy))))),-1);
if(!x1568.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1567.value)+(((1.5707963267949)*(x1568.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[2];
IkReal x1569=IKsin(j6);
IkReal x1570=IKcos(j6);
IkReal x1571=((1.0)*npx);
evalcond[0]=((((-1.0)*x1570*x1571))+((npy*x1569)));
evalcond[1]=((((-0.42)*sj3))+(((-1.0)*x1569*x1571))+(((-1.0)*npy*x1570)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[4];
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x1572=npy*npy;
IkReal x1573=npx*npx;
j6eval[0]=((((-1.0)*x1573))+(((-1.0)*x1572)));
j6eval[1]=441.0;
j6eval[2]=sj3;
j6eval[3]=IKsign(((((-50.0)*x1573))+(((-50.0)*x1572))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  || IKabs(j6eval[3]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj3=0;
cj3=1.0;
j3=0;
j6eval[0]=((IKabs(npy))+(IKabs(npx)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
CheckValue<IkReal> x1575 = IKatan2WithCheck(IkReal(((-1.0)*npx)),IkReal(npy),IKFAST_ATAN2_MAGTHRESH);
if(!x1575.valid){
continue;
}
IkReal x1574=x1575.value;
j6array[0]=((-1.0)*x1574);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1574)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*npy*(IKcos(j6))))+(((-1.0)*npx*(IKsin(j6)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j6eval[0]=((IKabs(npy))+(IKabs(npx)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
CheckValue<IkReal> x1577 = IKatan2WithCheck(IkReal(((-1.0)*npx)),IkReal(npy),IKFAST_ATAN2_MAGTHRESH);
if(!x1577.valid){
continue;
}
IkReal x1576=x1577.value;
j6array[0]=((-1.0)*x1576);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1576)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*npy*(IKcos(j6))))+(((-1.0)*npx*(IKsin(j6)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1578=((21.0)*sj3);
CheckValue<IkReal> x1579 = IKatan2WithCheck(IkReal((npx*x1578)),IkReal((npy*x1578)),IKFAST_ATAN2_MAGTHRESH);
if(!x1579.valid){
continue;
}
CheckValue<IkReal> x1580=IKPowWithIntegerCheck(IKsign(((((-50.0)*(npx*npx)))+(((-50.0)*(npy*npy))))),-1);
if(!x1580.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1579.value)+(((1.5707963267949)*(x1580.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[2];
IkReal x1581=IKsin(j6);
IkReal x1582=IKcos(j6);
IkReal x1583=((1.0)*npx);
evalcond[0]=(((npy*x1581))+(((-1.0)*x1582*x1583)));
evalcond[1]=((((-1.0)*npy*x1582))+(((-0.42)*sj3))+(((-1.0)*x1581*x1583)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1584=((50.0)*sj5);
IkReal x1585=((21.0)*cj3);
IkReal x1586=((50.0)*cj5*npz);
IkReal x1587=((21.0)*sj3*sj5);
CheckValue<IkReal> x1588 = IKatan2WithCheck(IkReal((((npy*x1586))+(((-1.0)*npx*x1587))+(((-20.0)*npy))+(((-1.0)*npy*x1585)))),IkReal(((((-1.0)*npx*x1586))+(((-1.0)*npy*x1587))+((npx*x1585))+(((20.0)*npx)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1588.valid){
continue;
}
CheckValue<IkReal> x1589=IKPowWithIntegerCheck(IKsign((((x1584*(npy*npy)))+((x1584*(npx*npx))))),-1);
if(!x1589.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1588.value)+(((1.5707963267949)*(x1589.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x1590=IKsin(j6);
IkReal x1591=IKcos(j6);
IkReal x1592=((1.0)*npx);
IkReal x1593=((0.42)*cj3);
IkReal x1594=(npy*x1590);
evalcond[0]=((((-1.0)*npy*x1591))+(((-0.42)*sj3))+(((-1.0)*x1590*x1592)));
evalcond[1]=(((npz*sj5))+(((-1.0)*cj5*x1591*x1592))+((cj5*x1594)));
evalcond[2]=(x1594+(((-1.0)*x1591*x1592))+(((0.4)*sj5))+((sj5*x1593)));
evalcond[3]=((0.4)+(((-1.0)*cj5*npz))+x1593+(((-1.0)*sj5*x1591*x1592))+((sj5*x1594)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1595=(npy*sj5);
IkReal x1596=((21.0)*cj3);
IkReal x1597=((21.0)*sj3);
IkReal x1598=(npx*sj5);
CheckValue<IkReal> x1599=IKPowWithIntegerCheck(IKsign(((((-50.0)*(npx*npx)))+(((-50.0)*(npy*npy))))),-1);
if(!x1599.valid){
continue;
}
CheckValue<IkReal> x1600 = IKatan2WithCheck(IkReal(((((20.0)*x1595))+((x1595*x1596))+((npx*x1597)))),IkReal(((((-20.0)*x1598))+((npy*x1597))+(((-1.0)*x1596*x1598)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1600.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1599.value)))+(x1600.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x1601=IKsin(j6);
IkReal x1602=IKcos(j6);
IkReal x1603=((1.0)*npx);
IkReal x1604=((0.42)*cj3);
IkReal x1605=(npy*x1601);
evalcond[0]=((((-0.42)*sj3))+(((-1.0)*npy*x1602))+(((-1.0)*x1601*x1603)));
evalcond[1]=(((cj5*x1605))+((npz*sj5))+(((-1.0)*cj5*x1602*x1603)));
evalcond[2]=(x1605+((sj5*x1604))+(((0.4)*sj5))+(((-1.0)*x1602*x1603)));
evalcond[3]=((0.4)+x1604+((sj5*x1605))+(((-1.0)*sj5*x1602*x1603))+(((-1.0)*cj5*npz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1606=((50.0)*cj5);
IkReal x1607=((21.0)*cj5*sj3);
IkReal x1608=((50.0)*npz*sj5);
CheckValue<IkReal> x1609 = IKatan2WithCheck(IkReal(((((-1.0)*npy*x1608))+(((-1.0)*npx*x1607)))),IkReal(((((-1.0)*npy*x1607))+((npx*x1608)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1609.valid){
continue;
}
CheckValue<IkReal> x1610=IKPowWithIntegerCheck(IKsign((((x1606*(npx*npx)))+((x1606*(npy*npy))))),-1);
if(!x1610.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1609.value)+(((1.5707963267949)*(x1610.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x1611=IKsin(j6);
IkReal x1612=IKcos(j6);
IkReal x1613=((1.0)*npx);
IkReal x1614=((0.42)*cj3);
IkReal x1615=(npy*x1611);
evalcond[0]=((((-0.42)*sj3))+(((-1.0)*x1611*x1613))+(((-1.0)*npy*x1612)));
evalcond[1]=((((-1.0)*cj5*x1612*x1613))+((npz*sj5))+((cj5*x1615)));
evalcond[2]=(((sj5*x1614))+x1615+(((0.4)*sj5))+(((-1.0)*x1612*x1613)));
evalcond[3]=((0.4)+((sj5*x1615))+(((-1.0)*sj5*x1612*x1613))+x1614+(((-1.0)*cj5*npz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj5=0;
cj5=1.0;
j5=0;
IkReal x1616=npy*npy;
IkReal x1617=npx*npx;
IkReal x1618=(npy*sj3);
IkReal x1619=(npx*sj3);
j6eval[0]=(x1616+x1617);
j6eval[1]=IKsign(((((50.0)*x1616))+(((50.0)*x1617))));
j6eval[2]=((IKabs(((((-1.0)*cj4*x1619))+((sj4*x1618)))))+(IKabs((((cj4*x1618))+((sj4*x1619))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
sj5=0;
cj5=1.0;
j5=0;
IkReal x1620=npy*npy;
IkReal x1621=npx*npx;
IkReal x1622=cj4*cj4;
IkReal x1623=(cj4*sj3*sj4);
IkReal x1624=(cj4*x1620);
IkReal x1625=(sj3*x1622);
IkReal x1626=(cj4*x1621);
j6eval[0]=(x1626+x1624);
j6eval[1]=IKsign(((((50.0)*x1626))+(((50.0)*x1624))));
j6eval[2]=((IKabs((((npy*x1623))+(((-1.0)*npx*x1625)))))+(IKabs((((npy*x1625))+((npx*x1623))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
sj5=0;
cj5=1.0;
j5=0;
IkReal x1627=cj4*cj4;
IkReal x1628=npx*npx;
IkReal x1629=npy*npy;
IkReal x1630=((1.0)*npx);
IkReal x1631=(npy*sj3);
IkReal x1632=(cj4*sj3*sj4);
IkReal x1633=(sj4*x1628);
IkReal x1634=(sj4*x1629);
j6eval[0]=(x1633+x1634);
j6eval[1]=((IKabs((x1631+(((-1.0)*x1627*x1631))+(((-1.0)*x1630*x1632)))))+(IKabs((((npx*sj3))+((cj4*sj4*x1631))+(((-1.0)*sj3*x1627*x1630))))));
j6eval[2]=IKsign(((((50.0)*x1634))+(((50.0)*x1633))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[4];
sj5=0;
cj5=1.0;
j5=0;
sj4=0;
cj4=1.0;
j4=0;
IkReal x1635=npy*npy;
IkReal x1636=npx*npx;
j6eval[0]=(x1635+x1636);
j6eval[1]=441.0;
j6eval[2]=sj3;
j6eval[3]=IKsign(((((50.0)*x1635))+(((50.0)*x1636))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  || IKabs(j6eval[3]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj5=0;
cj5=1.0;
j5=0;
sj4=0;
cj4=1.0;
j4=0;
sj3=0;
cj3=1.0;
j3=0;
j6eval[0]=((IKabs(npy))+(IKabs(npx)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
CheckValue<IkReal> x1638 = IKatan2WithCheck(IkReal(((-1.0)*npx)),IkReal(npy),IKFAST_ATAN2_MAGTHRESH);
if(!x1638.valid){
continue;
}
IkReal x1637=x1638.value;
j6array[0]=((-1.0)*x1637);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1637)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*npy*(IKcos(j6))))+(((-1.0)*npx*(IKsin(j6)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj5=0;
cj5=1.0;
j5=0;
sj4=0;
cj4=1.0;
j4=0;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j6eval[0]=((IKabs(npy))+(IKabs(npx)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
CheckValue<IkReal> x1640 = IKatan2WithCheck(IkReal(((-1.0)*npx)),IkReal(npy),IKFAST_ATAN2_MAGTHRESH);
if(!x1640.valid){
continue;
}
IkReal x1639=x1640.value;
j6array[0]=((-1.0)*x1639);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1639)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*npy*(IKcos(j6))))+(((-1.0)*npx*(IKsin(j6)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x1641=IKPowWithIntegerCheck(IKsign(((((50.0)*(npy*npy)))+(((50.0)*(npx*npx))))),-1);
if(!x1641.valid){
continue;
}
CheckValue<IkReal> x1642 = IKatan2WithCheck(IkReal(((21.0)*npy*sj3)),IkReal(((-21.0)*npx*sj3)),IKFAST_ATAN2_MAGTHRESH);
if(!x1642.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1641.value)))+(x1642.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[2];
IkReal x1643=IKsin(j6);
IkReal x1644=IKcos(j6);
IkReal x1645=((1.0)*npx);
evalcond[0]=((((-1.0)*npy*x1644))+(((-1.0)*x1643*x1645)));
evalcond[1]=((((-0.42)*sj3))+(((-1.0)*x1644*x1645))+((npy*x1643)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[4];
sj5=0;
cj5=1.0;
j5=0;
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
IkReal x1646=npy*npy;
IkReal x1647=npx*npx;
j6eval[0]=((((-1.0)*x1647))+(((-1.0)*x1646)));
j6eval[1]=441.0;
j6eval[2]=sj3;
j6eval[3]=IKsign(((((-50.0)*x1646))+(((-50.0)*x1647))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  || IKabs(j6eval[3]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj5=0;
cj5=1.0;
j5=0;
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
sj3=0;
cj3=1.0;
j3=0;
j6eval[0]=((IKabs(npy))+(IKabs(npx)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
CheckValue<IkReal> x1649 = IKatan2WithCheck(IkReal(((-1.0)*npx)),IkReal(npy),IKFAST_ATAN2_MAGTHRESH);
if(!x1649.valid){
continue;
}
IkReal x1648=x1649.value;
j6array[0]=((-1.0)*x1648);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1648)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*npy*(IKcos(j6))))+(((-1.0)*npx*(IKsin(j6)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj5=0;
cj5=1.0;
j5=0;
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j6eval[0]=((IKabs(npy))+(IKabs(npx)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
CheckValue<IkReal> x1651 = IKatan2WithCheck(IkReal(((-1.0)*npx)),IkReal(npy),IKFAST_ATAN2_MAGTHRESH);
if(!x1651.valid){
continue;
}
IkReal x1650=x1651.value;
j6array[0]=((-1.0)*x1650);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1650)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*npy*(IKcos(j6))))+(((-1.0)*npx*(IKsin(j6)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x1652=IKPowWithIntegerCheck(IKsign(((((-50.0)*(npx*npx)))+(((-50.0)*(npy*npy))))),-1);
if(!x1652.valid){
continue;
}
CheckValue<IkReal> x1653 = IKatan2WithCheck(IkReal(((21.0)*npy*sj3)),IkReal(((-21.0)*npx*sj3)),IKFAST_ATAN2_MAGTHRESH);
if(!x1653.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1652.value)))+(x1653.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[2];
IkReal x1654=IKsin(j6);
IkReal x1655=IKcos(j6);
IkReal x1656=((1.0)*npx);
evalcond[0]=((((-1.0)*x1654*x1656))+(((-1.0)*npy*x1655)));
evalcond[1]=((((0.42)*sj3))+(((-1.0)*x1655*x1656))+((npy*x1654)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj5=0;
cj5=1.0;
j5=0;
sj3=0;
cj3=1.0;
j3=0;
j6eval[0]=((IKabs(npy))+(IKabs(npx)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj5=0;
cj5=1.0;
j5=0;
sj3=0;
cj3=1.0;
j3=0;
j6eval[0]=((IKabs((((cj4*npx))+(((-1.0)*npy*sj4)))))+(IKabs((((npx*sj4))+((cj4*npy))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj5=0;
cj5=1.0;
j5=0;
sj3=0;
cj3=1.0;
j3=0;
IkReal x1657=((1.0)*npy);
j6eval[0]=((IKabs(((((-1.0)*cj4*x1657))+(((-1.0)*npx*sj4)))))+(IKabs(((((-1.0)*sj4*x1657))+((cj4*npx))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1658=((1.0)*npy);
CheckValue<IkReal> x1660 = IKatan2WithCheck(IkReal(((((-1.0)*sj4*x1658))+((cj4*npx)))),IkReal(((((-1.0)*cj4*x1658))+(((-1.0)*npx*sj4)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1660.valid){
continue;
}
IkReal x1659=x1660.value;
j6array[0]=((-1.0)*x1659);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1659)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x1661=IKsin(j6);
IkReal x1662=IKcos(j6);
IkReal x1663=(npy*x1661);
IkReal x1664=(npy*x1662);
IkReal x1665=(npx*x1662);
IkReal x1666=(npx*x1661);
evalcond[0]=(x1663+(((-1.0)*x1665)));
evalcond[1]=((((-1.0)*x1666))+(((-1.0)*x1664)));
evalcond[2]=(((cj4*x1664))+((cj4*x1666))+((sj4*x1665))+(((-1.0)*sj4*x1663)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
CheckValue<IkReal> x1668 = IKatan2WithCheck(IkReal((((npx*sj4))+((cj4*npy)))),IkReal((((cj4*npx))+(((-1.0)*npy*sj4)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1668.valid){
continue;
}
IkReal x1667=x1668.value;
j6array[0]=((-1.0)*x1667);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1667)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x1669=IKsin(j6);
IkReal x1670=IKcos(j6);
IkReal x1671=((1.0)*npx);
IkReal x1672=(npy*x1669);
IkReal x1673=((1.0)*npy*x1670);
evalcond[0]=(x1672+(((-1.0)*x1670*x1671)));
evalcond[1]=((((-1.0)*x1669*x1671))+(((-1.0)*x1673)));
evalcond[2]=(((cj4*npx*x1670))+(((-1.0)*sj4*x1673))+(((-1.0)*sj4*x1669*x1671))+(((-1.0)*cj4*x1672)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
CheckValue<IkReal> x1675 = IKatan2WithCheck(IkReal(((-1.0)*npx)),IkReal(npy),IKFAST_ATAN2_MAGTHRESH);
if(!x1675.valid){
continue;
}
IkReal x1674=x1675.value;
j6array[0]=((-1.0)*x1674);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1674)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x1676=IKsin(j6);
IkReal x1677=IKcos(j6);
IkReal x1678=(cj4*npy);
IkReal x1679=((1.0)*npy);
IkReal x1680=(cj4*npx);
IkReal x1681=((1.0)*x1676);
IkReal x1682=(sj4*x1677);
evalcond[0]=((((-1.0)*npx*x1681))+(((-1.0)*x1677*x1679)));
evalcond[1]=(((x1676*x1680))+((npx*x1682))+(((-1.0)*sj4*x1676*x1679))+((x1677*x1678)));
evalcond[2]=(((x1677*x1680))+(((-1.0)*x1678*x1681))+(((-1.0)*x1679*x1682))+(((-1.0)*npx*sj4*x1681)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj5=0;
cj5=1.0;
j5=0;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j6eval[0]=((IKabs(npy))+(IKabs(npx)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj5=0;
cj5=1.0;
j5=0;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j6eval[0]=((IKabs((((cj4*npx))+(((-1.0)*npy*sj4)))))+(IKabs((((npx*sj4))+((cj4*npy))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj5=0;
cj5=1.0;
j5=0;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x1683=((1.0)*npy);
j6eval[0]=((IKabs((((cj4*npx))+(((-1.0)*sj4*x1683)))))+(IKabs(((((-1.0)*cj4*x1683))+(((-1.0)*npx*sj4))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1684=((1.0)*npy);
CheckValue<IkReal> x1686 = IKatan2WithCheck(IkReal((((cj4*npx))+(((-1.0)*sj4*x1684)))),IkReal(((((-1.0)*cj4*x1684))+(((-1.0)*npx*sj4)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1686.valid){
continue;
}
IkReal x1685=x1686.value;
j6array[0]=((-1.0)*x1685);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1685)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x1687=IKsin(j6);
IkReal x1688=IKcos(j6);
IkReal x1689=(npy*x1687);
IkReal x1690=(npy*x1688);
IkReal x1691=(npx*x1688);
IkReal x1692=(npx*x1687);
evalcond[0]=(x1689+(((-1.0)*x1691)));
evalcond[1]=((((-1.0)*x1690))+(((-1.0)*x1692)));
evalcond[2]=((((-1.0)*sj4*x1689))+((cj4*x1690))+((cj4*x1692))+((sj4*x1691)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
CheckValue<IkReal> x1694 = IKatan2WithCheck(IkReal((((npx*sj4))+((cj4*npy)))),IkReal((((cj4*npx))+(((-1.0)*npy*sj4)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1694.valid){
continue;
}
IkReal x1693=x1694.value;
j6array[0]=((-1.0)*x1693);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1693)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x1695=IKsin(j6);
IkReal x1696=IKcos(j6);
IkReal x1697=((1.0)*npx);
IkReal x1698=(npy*x1695);
IkReal x1699=((1.0)*npy*x1696);
evalcond[0]=((((-1.0)*x1696*x1697))+x1698);
evalcond[1]=((((-1.0)*x1699))+(((-1.0)*x1695*x1697)));
evalcond[2]=(((cj4*npx*x1696))+(((-1.0)*cj4*x1698))+(((-1.0)*sj4*x1695*x1697))+(((-1.0)*sj4*x1699)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
CheckValue<IkReal> x1701 = IKatan2WithCheck(IkReal(((-1.0)*npx)),IkReal(npy),IKFAST_ATAN2_MAGTHRESH);
if(!x1701.valid){
continue;
}
IkReal x1700=x1701.value;
j6array[0]=((-1.0)*x1700);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1700)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x1702=IKsin(j6);
IkReal x1703=IKcos(j6);
IkReal x1704=(cj4*npy);
IkReal x1705=((1.0)*npy);
IkReal x1706=(cj4*npx);
IkReal x1707=((1.0)*x1702);
IkReal x1708=(sj4*x1703);
evalcond[0]=((((-1.0)*npx*x1707))+(((-1.0)*x1703*x1705)));
evalcond[1]=(((npx*x1708))+(((-1.0)*sj4*x1702*x1705))+((x1703*x1704))+((x1702*x1706)));
evalcond[2]=((((-1.0)*npx*sj4*x1707))+((x1703*x1706))+(((-1.0)*x1704*x1707))+(((-1.0)*x1705*x1708)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1709=cj4*cj4;
IkReal x1710=((50.0)*sj4);
IkReal x1711=((21.0)*npx*sj3);
IkReal x1712=((21.0)*npy*sj3);
IkReal x1713=((21.0)*cj4*sj3*sj4);
CheckValue<IkReal> x1714=IKPowWithIntegerCheck(IKsign((((x1710*(npy*npy)))+((x1710*(npx*npx))))),-1);
if(!x1714.valid){
continue;
}
CheckValue<IkReal> x1715 = IKatan2WithCheck(IkReal((x1711+(((-1.0)*x1709*x1711))+((cj4*sj4*x1712)))),IkReal((x1712+(((-1.0)*cj4*sj4*x1711))+(((-1.0)*x1709*x1712)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1715.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1714.value)))+(x1715.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x1716=IKsin(j6);
IkReal x1717=IKcos(j6);
IkReal x1718=((0.42)*sj3);
IkReal x1719=((1.0)*sj4);
IkReal x1720=(npy*x1716);
IkReal x1721=(npx*x1716);
IkReal x1722=((1.0)*x1717);
IkReal x1723=(npx*x1717);
evalcond[0]=((((-1.0)*npx*x1722))+x1720+(((-1.0)*cj4*x1718)));
evalcond[1]=(((sj4*x1718))+(((-1.0)*x1721))+(((-1.0)*npy*x1722)));
evalcond[2]=(((sj4*x1723))+((cj4*x1721))+(((-1.0)*x1719*x1720))+((cj4*npy*x1717)));
evalcond[3]=((((-1.0)*cj4*x1720))+x1718+(((-1.0)*npy*x1717*x1719))+((cj4*x1723))+(((-1.0)*x1719*x1721)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1724=cj4*cj4;
IkReal x1725=((21.0)*sj3);
IkReal x1726=(cj4*sj4);
IkReal x1727=((50.0)*cj4);
CheckValue<IkReal> x1728=IKPowWithIntegerCheck(IKsign((((x1727*(npy*npy)))+((x1727*(npx*npx))))),-1);
if(!x1728.valid){
continue;
}
CheckValue<IkReal> x1729 = IKatan2WithCheck(IkReal((((npx*x1725*x1726))+((npy*x1724*x1725)))),IkReal(((((-1.0)*npx*x1724*x1725))+((npy*x1725*x1726)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1729.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1728.value)))+(x1729.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x1730=IKsin(j6);
IkReal x1731=IKcos(j6);
IkReal x1732=((0.42)*sj3);
IkReal x1733=((1.0)*sj4);
IkReal x1734=(npy*x1730);
IkReal x1735=(npx*x1730);
IkReal x1736=((1.0)*x1731);
IkReal x1737=(npx*x1731);
evalcond[0]=((((-1.0)*npx*x1736))+x1734+(((-1.0)*cj4*x1732)));
evalcond[1]=((((-1.0)*npy*x1736))+((sj4*x1732))+(((-1.0)*x1735)));
evalcond[2]=((((-1.0)*x1733*x1734))+((cj4*npy*x1731))+((sj4*x1737))+((cj4*x1735)));
evalcond[3]=((((-1.0)*x1733*x1735))+(((-1.0)*cj4*x1734))+x1732+(((-1.0)*npy*x1731*x1733))+((cj4*x1737)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1738=((21.0)*sj3);
CheckValue<IkReal> x1739=IKPowWithIntegerCheck(IKsign(((((50.0)*(npy*npy)))+(((50.0)*(npx*npx))))),-1);
if(!x1739.valid){
continue;
}
CheckValue<IkReal> x1740 = IKatan2WithCheck(IkReal((((npx*sj4*x1738))+((cj4*npy*x1738)))),IkReal(((((-1.0)*cj4*npx*x1738))+((npy*sj4*x1738)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1740.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1739.value)))+(x1740.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x1741=IKsin(j6);
IkReal x1742=IKcos(j6);
IkReal x1743=((0.42)*sj3);
IkReal x1744=((1.0)*sj4);
IkReal x1745=(npy*x1741);
IkReal x1746=(npx*x1741);
IkReal x1747=((1.0)*x1742);
IkReal x1748=(npx*x1742);
evalcond[0]=((((-1.0)*cj4*x1743))+x1745+(((-1.0)*npx*x1747)));
evalcond[1]=(((sj4*x1743))+(((-1.0)*npy*x1747))+(((-1.0)*x1746)));
evalcond[2]=(((cj4*x1746))+((sj4*x1748))+((cj4*npy*x1742))+(((-1.0)*x1744*x1745)));
evalcond[3]=(((cj4*x1748))+x1743+(((-1.0)*cj4*x1745))+(((-1.0)*x1744*x1746))+(((-1.0)*npy*x1742*x1744)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x1749=npy*npy;
IkReal x1750=npx*npx;
IkReal x1751=(cj4*sj3);
IkReal x1752=(sj3*sj4);
j6eval[0]=(x1749+x1750);
j6eval[1]=((IKabs((((npy*x1752))+((npx*x1751)))))+(IKabs((((npx*x1752))+(((-1.0)*npy*x1751))))));
j6eval[2]=IKsign(((((50.0)*x1750))+(((50.0)*x1749))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x1753=cj4*cj4;
IkReal x1754=npy*npy;
IkReal x1755=npx*npx;
IkReal x1756=((1.0)*cj4);
IkReal x1757=(npx*sj3);
IkReal x1758=((50.0)*cj4);
IkReal x1759=(npy*sj3);
j6eval[0]=((((-1.0)*x1754*x1756))+(((-1.0)*x1755*x1756)));
j6eval[1]=((IKabs((((x1753*x1759))+(((-1.0)*sj4*x1756*x1757)))))+(IKabs(((((-1.0)*sj4*x1756*x1759))+(((-1.0)*x1753*x1757))))));
j6eval[2]=IKsign(((((-1.0)*x1754*x1758))+(((-1.0)*x1755*x1758))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x1760=cj4*cj4;
IkReal x1761=npx*npx;
IkReal x1762=npy*npy;
IkReal x1763=((1.0)*sj4);
IkReal x1764=((1.0)*npx);
IkReal x1765=((50.0)*sj4);
IkReal x1766=(cj4*sj3*sj4);
IkReal x1767=(sj3*x1760);
j6eval[0]=((((-1.0)*x1762*x1763))+(((-1.0)*x1761*x1763)));
j6eval[1]=((IKabs((((npy*x1767))+(((-1.0)*cj4*npx*sj3*x1763))+(((-1.0)*npy*sj3)))))+(IKabs(((((-1.0)*sj3*x1764))+((npy*x1766))+((npx*x1767))))));
j6eval[2]=IKsign(((((-1.0)*x1762*x1765))+(((-1.0)*x1761*x1765))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[4];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj4=0;
cj4=1.0;
j4=0;
IkReal x1768=npy*npy;
IkReal x1769=npx*npx;
j6eval[0]=((((-1.0)*x1768))+(((-1.0)*x1769)));
j6eval[1]=441.0;
j6eval[2]=sj3;
j6eval[3]=IKsign(((((-50.0)*x1768))+(((-50.0)*x1769))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  || IKabs(j6eval[3]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj4=0;
cj4=1.0;
j4=0;
sj3=0;
cj3=1.0;
j3=0;
j6eval[0]=((IKabs(npy))+(IKabs(npx)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
CheckValue<IkReal> x1771 = IKatan2WithCheck(IkReal(((-1.0)*npx)),IkReal(npy),IKFAST_ATAN2_MAGTHRESH);
if(!x1771.valid){
continue;
}
IkReal x1770=x1771.value;
j6array[0]=((-1.0)*x1770);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1770)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*npy*(IKcos(j6))))+(((-1.0)*npx*(IKsin(j6)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj4=0;
cj4=1.0;
j4=0;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j6eval[0]=((IKabs(npy))+(IKabs(npx)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
CheckValue<IkReal> x1773 = IKatan2WithCheck(IkReal(((-1.0)*npx)),IkReal(npy),IKFAST_ATAN2_MAGTHRESH);
if(!x1773.valid){
continue;
}
IkReal x1772=x1773.value;
j6array[0]=((-1.0)*x1772);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1772)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*npy*(IKcos(j6))))+(((-1.0)*npx*(IKsin(j6)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x1774=IKPowWithIntegerCheck(IKsign(((((-50.0)*(npx*npx)))+(((-50.0)*(npy*npy))))),-1);
if(!x1774.valid){
continue;
}
CheckValue<IkReal> x1775 = IKatan2WithCheck(IkReal(((21.0)*npy*sj3)),IkReal(((-21.0)*npx*sj3)),IKFAST_ATAN2_MAGTHRESH);
if(!x1775.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1774.value)))+(x1775.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[2];
IkReal x1776=IKsin(j6);
IkReal x1777=IKcos(j6);
IkReal x1778=((1.0)*npx);
evalcond[0]=((((-1.0)*x1776*x1778))+(((-1.0)*npy*x1777)));
evalcond[1]=((((0.42)*sj3))+((npy*x1776))+(((-1.0)*x1777*x1778)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[4];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
IkReal x1779=npy*npy;
IkReal x1780=npx*npx;
j6eval[0]=(x1780+x1779);
j6eval[1]=441.0;
j6eval[2]=sj3;
j6eval[3]=IKsign(((((50.0)*x1780))+(((50.0)*x1779))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  || IKabs(j6eval[3]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
sj3=0;
cj3=1.0;
j3=0;
j6eval[0]=((IKabs(npy))+(IKabs(npx)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
CheckValue<IkReal> x1782 = IKatan2WithCheck(IkReal(((-1.0)*npx)),IkReal(npy),IKFAST_ATAN2_MAGTHRESH);
if(!x1782.valid){
continue;
}
IkReal x1781=x1782.value;
j6array[0]=((-1.0)*x1781);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1781)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*npy*(IKcos(j6))))+(((-1.0)*npx*(IKsin(j6)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j6eval[0]=((IKabs(npy))+(IKabs(npx)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
CheckValue<IkReal> x1784 = IKatan2WithCheck(IkReal(((-1.0)*npx)),IkReal(npy),IKFAST_ATAN2_MAGTHRESH);
if(!x1784.valid){
continue;
}
IkReal x1783=x1784.value;
j6array[0]=((-1.0)*x1783);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1783)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*npy*(IKcos(j6))))+(((-1.0)*npx*(IKsin(j6)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x1785=IKPowWithIntegerCheck(IKsign(((((50.0)*(npy*npy)))+(((50.0)*(npx*npx))))),-1);
if(!x1785.valid){
continue;
}
CheckValue<IkReal> x1786 = IKatan2WithCheck(IkReal(((21.0)*npy*sj3)),IkReal(((-21.0)*npx*sj3)),IKFAST_ATAN2_MAGTHRESH);
if(!x1786.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1785.value)))+(x1786.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[2];
IkReal x1787=IKsin(j6);
IkReal x1788=IKcos(j6);
IkReal x1789=((1.0)*npx);
evalcond[0]=((((-1.0)*npy*x1788))+(((-1.0)*x1787*x1789)));
evalcond[1]=((((-0.42)*sj3))+(((-1.0)*x1788*x1789))+((npy*x1787)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj3=0;
cj3=1.0;
j3=0;
j6eval[0]=((IKabs(npy))+(IKabs(npx)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj3=0;
cj3=1.0;
j3=0;
j6eval[0]=((IKabs(((((-1.0)*npx*sj4))+((cj4*npy)))))+(IKabs((((npy*sj4))+((cj4*npx))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj3=0;
cj3=1.0;
j3=0;
IkReal x1790=((1.0)*npx);
j6eval[0]=((IKabs(((((-1.0)*cj4*x1790))+(((-1.0)*npy*sj4)))))+(IKabs((((cj4*npy))+(((-1.0)*sj4*x1790))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1791=((1.0)*sj4);
CheckValue<IkReal> x1793 = IKatan2WithCheck(IkReal(((((-1.0)*cj4*npx))+(((-1.0)*npy*x1791)))),IkReal((((cj4*npy))+(((-1.0)*npx*x1791)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1793.valid){
continue;
}
IkReal x1792=x1793.value;
j6array[0]=((-1.0)*x1792);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1792)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x1794=IKsin(j6);
IkReal x1795=IKcos(j6);
IkReal x1796=((1.0)*npx);
IkReal x1797=(npy*x1794);
IkReal x1798=(npy*x1795);
evalcond[0]=((((-1.0)*x1795*x1796))+x1797);
evalcond[1]=((((-1.0)*x1798))+(((-1.0)*x1794*x1796)));
evalcond[2]=((((-1.0)*sj4*x1795*x1796))+((cj4*npx*x1794))+((sj4*x1797))+((cj4*x1798)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
CheckValue<IkReal> x1800 = IKatan2WithCheck(IkReal(((((-1.0)*npx*sj4))+((cj4*npy)))),IkReal((((npy*sj4))+((cj4*npx)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1800.valid){
continue;
}
IkReal x1799=x1800.value;
j6array[0]=((-1.0)*x1799);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1799)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x1801=IKsin(j6);
IkReal x1802=IKcos(j6);
IkReal x1803=((1.0)*npx);
IkReal x1804=(npy*x1801);
IkReal x1805=((1.0)*npy*x1802);
evalcond[0]=((((-1.0)*x1802*x1803))+x1804);
evalcond[1]=((((-1.0)*x1801*x1803))+(((-1.0)*x1805)));
evalcond[2]=((((-1.0)*sj4*x1805))+(((-1.0)*sj4*x1801*x1803))+((cj4*x1804))+(((-1.0)*cj4*x1802*x1803)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
CheckValue<IkReal> x1807 = IKatan2WithCheck(IkReal(((-1.0)*npx)),IkReal(npy),IKFAST_ATAN2_MAGTHRESH);
if(!x1807.valid){
continue;
}
IkReal x1806=x1807.value;
j6array[0]=((-1.0)*x1806);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1806)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x1808=IKsin(j6);
IkReal x1809=IKcos(j6);
IkReal x1810=((1.0)*sj4);
IkReal x1811=(npy*x1809);
IkReal x1812=(npx*x1809);
IkReal x1813=(cj4*x1808);
IkReal x1814=(npx*x1808);
evalcond[0]=((((-1.0)*x1811))+(((-1.0)*x1814)));
evalcond[1]=(((npx*x1813))+(((-1.0)*x1810*x1812))+((npy*sj4*x1808))+((cj4*x1811)));
evalcond[2]=((((-1.0)*x1810*x1811))+(((-1.0)*x1810*x1814))+((npy*x1813))+(((-1.0)*cj4*x1812)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j6eval[0]=((IKabs(npy))+(IKabs(npx)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j6eval[0]=((IKabs(((((-1.0)*npx*sj4))+((cj4*npy)))))+(IKabs((((npy*sj4))+((cj4*npx))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x1815=((1.0)*npx);
j6eval[0]=((IKabs((((cj4*npy))+(((-1.0)*sj4*x1815)))))+(IKabs(((((-1.0)*cj4*x1815))+(((-1.0)*npy*sj4))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1816=((1.0)*sj4);
CheckValue<IkReal> x1818 = IKatan2WithCheck(IkReal(((((-1.0)*npy*x1816))+(((-1.0)*cj4*npx)))),IkReal(((((-1.0)*npx*x1816))+((cj4*npy)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1818.valid){
continue;
}
IkReal x1817=x1818.value;
j6array[0]=((-1.0)*x1817);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1817)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x1819=IKsin(j6);
IkReal x1820=IKcos(j6);
IkReal x1821=((1.0)*npx);
IkReal x1822=(npy*x1819);
IkReal x1823=(npy*x1820);
evalcond[0]=(x1822+(((-1.0)*x1820*x1821)));
evalcond[1]=((((-1.0)*x1823))+(((-1.0)*x1819*x1821)));
evalcond[2]=(((cj4*x1823))+((cj4*npx*x1819))+((sj4*x1822))+(((-1.0)*sj4*x1820*x1821)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
CheckValue<IkReal> x1825 = IKatan2WithCheck(IkReal(((((-1.0)*npx*sj4))+((cj4*npy)))),IkReal((((npy*sj4))+((cj4*npx)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1825.valid){
continue;
}
IkReal x1824=x1825.value;
j6array[0]=((-1.0)*x1824);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1824)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x1826=IKsin(j6);
IkReal x1827=IKcos(j6);
IkReal x1828=((1.0)*npx);
IkReal x1829=(npy*x1826);
IkReal x1830=((1.0)*npy*x1827);
evalcond[0]=((((-1.0)*x1827*x1828))+x1829);
evalcond[1]=((((-1.0)*x1830))+(((-1.0)*x1826*x1828)));
evalcond[2]=(((cj4*x1829))+(((-1.0)*sj4*x1830))+(((-1.0)*cj4*x1827*x1828))+(((-1.0)*sj4*x1826*x1828)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
CheckValue<IkReal> x1832 = IKatan2WithCheck(IkReal(((-1.0)*npx)),IkReal(npy),IKFAST_ATAN2_MAGTHRESH);
if(!x1832.valid){
continue;
}
IkReal x1831=x1832.value;
j6array[0]=((-1.0)*x1831);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1831)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x1833=IKsin(j6);
IkReal x1834=IKcos(j6);
IkReal x1835=((1.0)*sj4);
IkReal x1836=(npy*x1834);
IkReal x1837=(npx*x1834);
IkReal x1838=(cj4*x1833);
IkReal x1839=(npx*x1833);
evalcond[0]=((((-1.0)*x1839))+(((-1.0)*x1836)));
evalcond[1]=(((npx*x1838))+((npy*sj4*x1833))+(((-1.0)*x1835*x1837))+((cj4*x1836)));
evalcond[2]=(((npy*x1838))+(((-1.0)*cj4*x1837))+(((-1.0)*x1835*x1836))+(((-1.0)*x1835*x1839)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1840=cj4*cj4;
IkReal x1841=((21.0)*sj3);
IkReal x1842=(cj4*sj4);
IkReal x1843=((50.0)*sj4);
CheckValue<IkReal> x1844=IKPowWithIntegerCheck(IKsign(((((-1.0)*x1843*(npx*npx)))+(((-1.0)*x1843*(npy*npy))))),-1);
if(!x1844.valid){
continue;
}
CheckValue<IkReal> x1845 = IKatan2WithCheck(IkReal(((((-1.0)*npx*x1841))+((npx*x1840*x1841))+((npy*x1841*x1842)))),IkReal(((((-1.0)*npy*x1841))+((npy*x1840*x1841))+(((-1.0)*npx*x1841*x1842)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1845.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1844.value)))+(x1845.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x1846=IKsin(j6);
IkReal x1847=IKcos(j6);
IkReal x1848=((0.42)*sj3);
IkReal x1849=(cj4*npx);
IkReal x1850=(npy*x1846);
IkReal x1851=((1.0)*x1847);
IkReal x1852=(sj4*x1851);
IkReal x1853=((1.0)*npx*x1846);
evalcond[0]=(((cj4*x1848))+(((-1.0)*npx*x1851))+x1850);
evalcond[1]=((((-1.0)*npy*x1851))+((sj4*x1848))+(((-1.0)*x1853)));
evalcond[2]=(((cj4*npy*x1847))+((sj4*x1850))+(((-1.0)*npx*x1852))+((x1846*x1849)));
evalcond[3]=((((-1.0)*x1849*x1851))+(((-1.0)*npy*x1852))+(((-1.0)*sj4*x1853))+x1848+((cj4*x1850)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1854=cj4*cj4;
IkReal x1855=((50.0)*cj4);
IkReal x1856=((21.0)*cj4*sj3*sj4);
IkReal x1857=((21.0)*sj3*x1854);
CheckValue<IkReal> x1858 = IKatan2WithCheck(IkReal(((((-1.0)*npx*x1856))+((npy*x1857)))),IkReal(((((-1.0)*npy*x1856))+(((-1.0)*npx*x1857)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1858.valid){
continue;
}
CheckValue<IkReal> x1859=IKPowWithIntegerCheck(IKsign(((((-1.0)*x1855*(npx*npx)))+(((-1.0)*x1855*(npy*npy))))),-1);
if(!x1859.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1858.value)+(((1.5707963267949)*(x1859.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x1860=IKsin(j6);
IkReal x1861=IKcos(j6);
IkReal x1862=((0.42)*sj3);
IkReal x1863=(cj4*npx);
IkReal x1864=(npy*x1860);
IkReal x1865=((1.0)*x1861);
IkReal x1866=(sj4*x1865);
IkReal x1867=((1.0)*npx*x1860);
evalcond[0]=(((cj4*x1862))+(((-1.0)*npx*x1865))+x1864);
evalcond[1]=(((sj4*x1862))+(((-1.0)*npy*x1865))+(((-1.0)*x1867)));
evalcond[2]=(((sj4*x1864))+((x1860*x1863))+(((-1.0)*npx*x1866))+((cj4*npy*x1861)));
evalcond[3]=((((-1.0)*sj4*x1867))+(((-1.0)*npy*x1866))+((cj4*x1864))+(((-1.0)*x1863*x1865))+x1862);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1868=((21.0)*sj3);
CheckValue<IkReal> x1869=IKPowWithIntegerCheck(IKsign(((((50.0)*(npy*npy)))+(((50.0)*(npx*npx))))),-1);
if(!x1869.valid){
continue;
}
CheckValue<IkReal> x1870 = IKatan2WithCheck(IkReal(((((-1.0)*cj4*npy*x1868))+((npx*sj4*x1868)))),IkReal((((npy*sj4*x1868))+((cj4*npx*x1868)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1870.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1869.value)))+(x1870.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x1871=IKsin(j6);
IkReal x1872=IKcos(j6);
IkReal x1873=((0.42)*sj3);
IkReal x1874=(cj4*npx);
IkReal x1875=(npy*x1871);
IkReal x1876=((1.0)*x1872);
IkReal x1877=(sj4*x1876);
IkReal x1878=((1.0)*npx*x1871);
evalcond[0]=((((-1.0)*npx*x1876))+x1875+((cj4*x1873)));
evalcond[1]=((((-1.0)*npy*x1876))+(((-1.0)*x1878))+((sj4*x1873)));
evalcond[2]=(((cj4*npy*x1872))+(((-1.0)*npx*x1877))+((x1871*x1874))+((sj4*x1875)));
evalcond[3]=((((-1.0)*npy*x1877))+(((-1.0)*x1874*x1876))+x1873+(((-1.0)*sj4*x1878))+((cj4*x1875)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1879=cj4*cj4;
IkReal x1880=(cj4*cj5);
IkReal x1881=((21.0)*sj3*sj4);
IkReal x1882=((21.0)*sj3*x1879);
IkReal x1883=((50.0)*cj4*npz*sj5);
CheckValue<IkReal> x1884 = IKatan2WithCheck(IkReal(((((-1.0)*npy*x1883))+((npy*x1882))+((npx*x1880*x1881)))),IkReal((((npy*x1880*x1881))+(((-1.0)*npx*x1882))+((npx*x1883)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1884.valid){
continue;
}
CheckValue<IkReal> x1885=IKPowWithIntegerCheck(IKsign(((((50.0)*x1880*(npy*npy)))+(((50.0)*x1880*(npx*npx))))),-1);
if(!x1885.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1884.value)+(((1.5707963267949)*(x1885.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[5];
IkReal x1886=IKsin(j6);
IkReal x1887=IKcos(j6);
IkReal x1888=((1.0)*sj5);
IkReal x1889=((1.0)*sj4);
IkReal x1890=((1.0)*cj5);
IkReal x1891=((0.42)*cj3);
IkReal x1892=(cj4*cj5);
IkReal x1893=((0.42)*sj3);
IkReal x1894=(npy*x1886);
IkReal x1895=(npx*x1887);
IkReal x1896=(npy*x1887);
IkReal x1897=(npx*x1886);
evalcond[0]=((((-1.0)*x1896))+(((-1.0)*x1897))+((sj4*x1893)));
evalcond[1]=((0.4)+((sj5*x1894))+(((-1.0)*x1888*x1895))+x1891+(((-1.0)*npz*x1890)));
evalcond[2]=(((sj5*x1891))+(((-1.0)*x1892*x1893))+(((0.4)*sj5))+(((-1.0)*x1895))+x1894);
evalcond[3]=((((-1.0)*npz*sj4*x1888))+((cj5*sj4*x1895))+((cj4*x1897))+((cj4*x1896))+(((-1.0)*cj5*x1889*x1894)));
evalcond[4]=(((x1892*x1895))+(((-1.0)*cj4*npz*x1888))+(((-1.0)*x1889*x1897))+(((-1.0)*x1889*x1896))+x1893+(((-1.0)*cj4*x1890*x1894)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1898=((21.0)*npy);
IkReal x1899=(sj3*sj4);
IkReal x1900=(cj3*sj5);
IkReal x1901=((20.0)*sj5);
IkReal x1902=((21.0)*npx);
IkReal x1903=(cj4*cj5*sj3);
CheckValue<IkReal> x1904=IKPowWithIntegerCheck(IKsign(((((50.0)*(npy*npy)))+(((50.0)*(npx*npx))))),-1);
if(!x1904.valid){
continue;
}
CheckValue<IkReal> x1905 = IKatan2WithCheck(IkReal((((x1898*x1903))+(((-1.0)*x1898*x1900))+((x1899*x1902))+(((-1.0)*npy*x1901)))),IkReal(((((-1.0)*x1902*x1903))+((npx*x1901))+((x1900*x1902))+((x1898*x1899)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1905.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1904.value)))+(x1905.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[5];
IkReal x1906=IKsin(j6);
IkReal x1907=IKcos(j6);
IkReal x1908=((1.0)*sj5);
IkReal x1909=((1.0)*sj4);
IkReal x1910=((1.0)*cj5);
IkReal x1911=((0.42)*cj3);
IkReal x1912=(cj4*cj5);
IkReal x1913=((0.42)*sj3);
IkReal x1914=(npy*x1906);
IkReal x1915=(npx*x1907);
IkReal x1916=(npy*x1907);
IkReal x1917=(npx*x1906);
evalcond[0]=(((sj4*x1913))+(((-1.0)*x1917))+(((-1.0)*x1916)));
evalcond[1]=((0.4)+((sj5*x1914))+x1911+(((-1.0)*npz*x1910))+(((-1.0)*x1908*x1915)));
evalcond[2]=(((sj5*x1911))+(((-1.0)*x1915))+x1914+(((0.4)*sj5))+(((-1.0)*x1912*x1913)));
evalcond[3]=(((cj5*sj4*x1915))+(((-1.0)*cj5*x1909*x1914))+(((-1.0)*npz*sj4*x1908))+((cj4*x1916))+((cj4*x1917)));
evalcond[4]=(((x1912*x1915))+(((-1.0)*cj4*npz*x1908))+x1913+(((-1.0)*x1909*x1917))+(((-1.0)*x1909*x1916))+(((-1.0)*cj4*x1910*x1914)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1918=((50.0)*sj5);
IkReal x1919=((21.0)*cj3);
IkReal x1920=((50.0)*cj5*npz);
IkReal x1921=((21.0)*sj3*sj4*sj5);
CheckValue<IkReal> x1922 = IKatan2WithCheck(IkReal((((npy*x1920))+(((-20.0)*npy))+((npx*x1921))+(((-1.0)*npy*x1919)))),IkReal(((((-1.0)*npx*x1920))+((npx*x1919))+((npy*x1921))+(((20.0)*npx)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1922.valid){
continue;
}
CheckValue<IkReal> x1923=IKPowWithIntegerCheck(IKsign((((x1918*(npx*npx)))+((x1918*(npy*npy))))),-1);
if(!x1923.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1922.value)+(((1.5707963267949)*(x1923.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[5];
IkReal x1924=IKsin(j6);
IkReal x1925=IKcos(j6);
IkReal x1926=((1.0)*sj5);
IkReal x1927=((1.0)*sj4);
IkReal x1928=((1.0)*cj5);
IkReal x1929=((0.42)*cj3);
IkReal x1930=(cj4*cj5);
IkReal x1931=((0.42)*sj3);
IkReal x1932=(npy*x1924);
IkReal x1933=(npx*x1925);
IkReal x1934=(npy*x1925);
IkReal x1935=(npx*x1924);
evalcond[0]=((((-1.0)*x1935))+(((-1.0)*x1934))+((sj4*x1931)));
evalcond[1]=((0.4)+(((-1.0)*npz*x1928))+(((-1.0)*x1926*x1933))+x1929+((sj5*x1932)));
evalcond[2]=((((-1.0)*x1930*x1931))+(((-1.0)*x1933))+x1932+(((0.4)*sj5))+((sj5*x1929)));
evalcond[3]=(((cj4*x1934))+((cj4*x1935))+((cj5*sj4*x1933))+(((-1.0)*cj5*x1927*x1932))+(((-1.0)*npz*sj4*x1926)));
evalcond[4]=((((-1.0)*cj4*x1928*x1932))+((x1930*x1933))+(((-1.0)*cj4*npz*x1926))+x1931+(((-1.0)*x1927*x1935))+(((-1.0)*x1927*x1934)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1936=sj5*sj5;
CheckValue<IkReal> x1939 = IKatan2WithCheck(IkReal(((-1.0)*npx*sj5)),IkReal((npy*sj5)),IKFAST_ATAN2_MAGTHRESH);
if(!x1939.valid){
continue;
}
IkReal x1937=((1.0)*(x1939.value));
if(((((x1936*(npx*npx)))+((x1936*(npy*npy))))) < -0.00001)
continue;
CheckValue<IkReal> x1940=IKPowWithIntegerCheck(IKabs(IKsqrt((((x1936*(npx*npx)))+((x1936*(npy*npy)))))),-1);
if(!x1940.valid){
continue;
}
if( (((x1940.value)*(((0.4)+(((-1.0)*cj5*npz))+(((0.42)*cj3)))))) < -1-IKFAST_SINCOS_THRESH || (((x1940.value)*(((0.4)+(((-1.0)*cj5*npz))+(((0.42)*cj3)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1938=IKasin(((x1940.value)*(((0.4)+(((-1.0)*cj5*npz))+(((0.42)*cj3))))));
j6array[0]=((((-1.0)*x1938))+(((-1.0)*x1937)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+x1938+(((-1.0)*x1937)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];

{
IkReal j4eval[2];
j4eval[0]=sj3;
j4eval[1]=(((cj6*npy*sj3))+((npx*sj3*sj6)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
j4eval[0]=sj3;
j4eval[1]=sj5;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
j4eval[0]=sj3;
j4eval[1]=cj5;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[3];
sj5=1.0;
cj5=0;
j5=1.5707963267949;
j4eval[0]=sj3;
j4eval[1]=((((0.02)*(IKabs(((((50.0)*cj6*npy))+(((50.0)*npx*sj6)))))))+(IKabs(npz)));
j4eval[2]=IKsign(sj3);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
sj5=1.0;
cj5=0;
j5=1.5707963267949;
IkReal x1941=((1.0)*sj3);
j4eval[0]=((((-1.0)*cj6*npy*x1941))+(((-1.0)*npx*sj6*x1941)));
j4eval[1]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1942=((1050.0)*sj3);
CheckValue<IkReal> x1943=IKPowWithIntegerCheck(((((-1.0)*cj6*npy*x1942))+(((-1.0)*npx*sj6*x1942))),-1);
if(!x1943.valid){
continue;
}
CheckValue<IkReal> x1944=IKPowWithIntegerCheck(sj3,-1);
if(!x1944.valid){
continue;
}
if( IKabs(((x1943.value)*(((-441.0)+(((2500.0)*(npz*npz)))+(((441.0)*(cj3*cj3))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((2.38095238095238)*npz*(x1944.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1943.value)*(((-441.0)+(((2500.0)*(npz*npz)))+(((441.0)*(cj3*cj3)))))))+IKsqr(((2.38095238095238)*npz*(x1944.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1943.value)*(((-441.0)+(((2500.0)*(npz*npz)))+(((441.0)*(cj3*cj3)))))), ((2.38095238095238)*npz*(x1944.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x1945=IKcos(j4);
IkReal x1946=IKsin(j4);
IkReal x1947=((0.42)*sj3);
IkReal x1948=(npx*sj6);
IkReal x1949=((1.0)*npz);
IkReal x1950=((1.0)*cj6*npy);
evalcond[0]=(((x1945*x1947))+(((-1.0)*x1949)));
evalcond[1]=((((-1.0)*x1950))+((x1946*x1947))+(((-1.0)*x1948)));
evalcond[2]=(((x1945*x1948))+(((-1.0)*x1946*x1949))+((cj6*npy*x1945)));
evalcond[3]=((((-1.0)*x1945*x1949))+x1947+(((-1.0)*x1946*x1950))+(((-1.0)*x1946*x1948)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x1951=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x1951.valid){
continue;
}
CheckValue<IkReal> x1952 = IKatan2WithCheck(IkReal(((((50.0)*cj6*npy))+(((50.0)*npx*sj6)))),IkReal(((50.0)*npz)),IKFAST_ATAN2_MAGTHRESH);
if(!x1952.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1951.value)))+(x1952.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x1953=IKcos(j4);
IkReal x1954=IKsin(j4);
IkReal x1955=((0.42)*sj3);
IkReal x1956=(npx*sj6);
IkReal x1957=((1.0)*npz);
IkReal x1958=((1.0)*cj6*npy);
evalcond[0]=((((-1.0)*x1957))+((x1953*x1955)));
evalcond[1]=((((-1.0)*x1958))+((x1954*x1955))+(((-1.0)*x1956)));
evalcond[2]=((((-1.0)*x1954*x1957))+((x1953*x1956))+((cj6*npy*x1953)));
evalcond[3]=((((-1.0)*x1954*x1958))+(((-1.0)*x1954*x1956))+x1955+(((-1.0)*x1953*x1957)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[3];
sj5=-1.0;
cj5=0;
j5=-1.5707963267949;
j4eval[0]=sj3;
j4eval[1]=((((0.02)*(IKabs(((((50.0)*cj6*npy))+(((50.0)*npx*sj6)))))))+(IKabs(npz)));
j4eval[2]=IKsign(sj3);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
sj5=-1.0;
cj5=0;
j5=-1.5707963267949;
IkReal x1959=((1.0)*sj3);
j4eval[0]=((((-1.0)*cj6*npy*x1959))+(((-1.0)*npx*sj6*x1959)));
j4eval[1]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1960=((1050.0)*sj3);
CheckValue<IkReal> x1961=IKPowWithIntegerCheck(((((-1.0)*cj6*npy*x1960))+(((-1.0)*npx*sj6*x1960))),-1);
if(!x1961.valid){
continue;
}
CheckValue<IkReal> x1962=IKPowWithIntegerCheck(sj3,-1);
if(!x1962.valid){
continue;
}
if( IKabs(((x1961.value)*(((-441.0)+(((2500.0)*(npz*npz)))+(((441.0)*(cj3*cj3))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-2.38095238095238)*npz*(x1962.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1961.value)*(((-441.0)+(((2500.0)*(npz*npz)))+(((441.0)*(cj3*cj3)))))))+IKsqr(((-2.38095238095238)*npz*(x1962.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1961.value)*(((-441.0)+(((2500.0)*(npz*npz)))+(((441.0)*(cj3*cj3)))))), ((-2.38095238095238)*npz*(x1962.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x1963=IKsin(j4);
IkReal x1964=IKcos(j4);
IkReal x1965=((0.42)*sj3);
IkReal x1966=(npx*sj6);
IkReal x1967=(cj6*npy);
IkReal x1968=((1.0)*x1963);
evalcond[0]=((((-1.0)*x1964*x1965))+(((-1.0)*npz)));
evalcond[1]=((((-1.0)*x1966))+(((-1.0)*x1967))+((x1963*x1965)));
evalcond[2]=(((x1964*x1967))+((x1964*x1966))+((npz*x1963)));
evalcond[3]=((((-1.0)*x1966*x1968))+((npz*x1964))+x1965+(((-1.0)*x1967*x1968)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x1969=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x1969.valid){
continue;
}
CheckValue<IkReal> x1970 = IKatan2WithCheck(IkReal(((((50.0)*cj6*npy))+(((50.0)*npx*sj6)))),IkReal(((-50.0)*npz)),IKFAST_ATAN2_MAGTHRESH);
if(!x1970.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1969.value)))+(x1970.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x1971=IKsin(j4);
IkReal x1972=IKcos(j4);
IkReal x1973=((0.42)*sj3);
IkReal x1974=(npx*sj6);
IkReal x1975=(cj6*npy);
IkReal x1976=((1.0)*x1971);
evalcond[0]=((((-1.0)*npz))+(((-1.0)*x1972*x1973)));
evalcond[1]=(((x1971*x1973))+(((-1.0)*x1975))+(((-1.0)*x1974)));
evalcond[2]=(((x1972*x1975))+((x1972*x1974))+((npz*x1971)));
evalcond[3]=((((-1.0)*x1975*x1976))+(((-1.0)*x1974*x1976))+x1973+((npz*x1972)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[3];
sj5=0;
cj5=1.0;
j5=0;
IkReal x1977=((50.0)*npx);
IkReal x1978=((50.0)*npy);
j4eval[0]=sj3;
j4eval[1]=((IKabs(((((-1.0)*cj6*x1977))+((sj6*x1978)))))+(IKabs((((cj6*x1978))+((sj6*x1977))))));
j4eval[2]=IKsign(sj3);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
sj5=0;
cj5=1.0;
j5=0;
j4eval[0]=((((-1.0)*npy*sj3*sj6))+((cj6*npx*sj3)));
j4eval[1]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
sj5=0;
cj5=1.0;
j5=0;
j4eval[0]=sj3;
j4eval[1]=(((cj6*npy*sj3))+((npx*sj3*sj6)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1979=((50.0)*sj6);
IkReal x1980=(cj6*npy);
IkReal x1981=((21.0)*sj3);
IkReal x1982=(npx*npy);
CheckValue<IkReal> x1983=IKPowWithIntegerCheck(sj3,-1);
if(!x1983.valid){
continue;
}
CheckValue<IkReal> x1984=IKPowWithIntegerCheck((((x1980*x1981))+((npx*sj6*x1981))),-1);
if(!x1984.valid){
continue;
}
if( IKabs(((0.0476190476190476)*(x1983.value)*(((((50.0)*x1980))+((npx*x1979)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1984.value)*(((((50.0)*x1982))+(((-100.0)*cj6*npx*x1980))+((npy*x1979*x1980))+(((-1.0)*cj6*x1979*(npx*npx))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.0476190476190476)*(x1983.value)*(((((50.0)*x1980))+((npx*x1979))))))+IKsqr(((x1984.value)*(((((50.0)*x1982))+(((-100.0)*cj6*npx*x1980))+((npy*x1979*x1980))+(((-1.0)*cj6*x1979*(npx*npx)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((0.0476190476190476)*(x1983.value)*(((((50.0)*x1980))+((npx*x1979))))), ((x1984.value)*(((((50.0)*x1982))+(((-100.0)*cj6*npx*x1980))+((npy*x1979*x1980))+(((-1.0)*cj6*x1979*(npx*npx)))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x1985=IKcos(j4);
IkReal x1986=IKsin(j4);
IkReal x1987=((1.0)*cj6);
IkReal x1988=((1.0)*npy);
IkReal x1989=((0.42)*sj3);
IkReal x1990=(sj6*x1985);
IkReal x1991=(cj6*x1985);
IkReal x1992=((1.0)*npx*sj6);
evalcond[0]=((((-1.0)*x1985*x1989))+((npy*sj6))+(((-1.0)*npx*x1987)));
evalcond[1]=((((-1.0)*npy*x1987))+(((-1.0)*x1992))+((x1986*x1989)));
evalcond[2]=((((-1.0)*sj6*x1986*x1988))+((npy*x1991))+((cj6*npx*x1986))+((npx*x1990)));
evalcond[3]=((((-1.0)*x1986*x1992))+(((-1.0)*npy*x1986*x1987))+x1989+((npx*x1991))+(((-1.0)*x1988*x1990)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1993=((50.0)*npx);
IkReal x1994=((21.0)*sj3);
IkReal x1995=(npy*sj6);
IkReal x1996=((50.0)*cj6*sj6);
CheckValue<IkReal> x1997=IKPowWithIntegerCheck((((cj6*npx*x1994))+(((-1.0)*x1994*x1995))),-1);
if(!x1997.valid){
continue;
}
CheckValue<IkReal> x1998=IKPowWithIntegerCheck(sj3,-1);
if(!x1998.valid){
continue;
}
if( IKabs(((x1997.value)*(((((-50.0)*cj6*npy*x1995))+(((-1.0)*npy*x1993))+((cj6*npx*sj6*x1993))+(((100.0)*npx*npy*(cj6*cj6))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.0476190476190476)*(x1998.value)*(((((50.0)*x1995))+(((-1.0)*cj6*x1993)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1997.value)*(((((-50.0)*cj6*npy*x1995))+(((-1.0)*npy*x1993))+((cj6*npx*sj6*x1993))+(((100.0)*npx*npy*(cj6*cj6)))))))+IKsqr(((0.0476190476190476)*(x1998.value)*(((((50.0)*x1995))+(((-1.0)*cj6*x1993))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1997.value)*(((((-50.0)*cj6*npy*x1995))+(((-1.0)*npy*x1993))+((cj6*npx*sj6*x1993))+(((100.0)*npx*npy*(cj6*cj6)))))), ((0.0476190476190476)*(x1998.value)*(((((50.0)*x1995))+(((-1.0)*cj6*x1993))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x1999=IKcos(j4);
IkReal x2000=IKsin(j4);
IkReal x2001=((1.0)*cj6);
IkReal x2002=((1.0)*npy);
IkReal x2003=((0.42)*sj3);
IkReal x2004=(sj6*x1999);
IkReal x2005=(cj6*x1999);
IkReal x2006=((1.0)*npx*sj6);
evalcond[0]=((((-1.0)*npx*x2001))+((npy*sj6))+(((-1.0)*x1999*x2003)));
evalcond[1]=(((x2000*x2003))+(((-1.0)*x2006))+(((-1.0)*npy*x2001)));
evalcond[2]=(((npy*x2005))+(((-1.0)*sj6*x2000*x2002))+((cj6*npx*x2000))+((npx*x2004)));
evalcond[3]=(x2003+(((-1.0)*x2002*x2004))+(((-1.0)*x2000*x2006))+(((-1.0)*npy*x2000*x2001))+((npx*x2005)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x2007=((50.0)*npx);
IkReal x2008=((50.0)*npy);
CheckValue<IkReal> x2009=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x2009.valid){
continue;
}
CheckValue<IkReal> x2010 = IKatan2WithCheck(IkReal((((sj6*x2007))+((cj6*x2008)))),IkReal(((((-1.0)*cj6*x2007))+((sj6*x2008)))),IKFAST_ATAN2_MAGTHRESH);
if(!x2010.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x2009.value)))+(x2010.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x2011=IKcos(j4);
IkReal x2012=IKsin(j4);
IkReal x2013=((1.0)*cj6);
IkReal x2014=((1.0)*npy);
IkReal x2015=((0.42)*sj3);
IkReal x2016=(sj6*x2011);
IkReal x2017=(cj6*x2011);
IkReal x2018=((1.0)*npx*sj6);
evalcond[0]=(((npy*sj6))+(((-1.0)*npx*x2013))+(((-1.0)*x2011*x2015)));
evalcond[1]=((((-1.0)*x2018))+(((-1.0)*npy*x2013))+((x2012*x2015)));
evalcond[2]=(((npx*x2016))+(((-1.0)*sj6*x2012*x2014))+((npy*x2017))+((cj6*npx*x2012)));
evalcond[3]=(x2015+((npx*x2017))+(((-1.0)*x2014*x2016))+(((-1.0)*x2012*x2018))+(((-1.0)*npy*x2012*x2013)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[3];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x2019=((50.0)*npx);
IkReal x2020=((50.0)*npy);
j4eval[0]=sj3;
j4eval[1]=((IKabs((((sj6*x2019))+((cj6*x2020)))))+(IKabs(((((-1.0)*sj6*x2020))+((cj6*x2019))))));
j4eval[2]=IKsign(sj3);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
j4eval[0]=(((npy*sj3*sj6))+(((-1.0)*cj6*npx*sj3)));
j4eval[1]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
j4eval[0]=sj3;
j4eval[1]=(((cj6*npy*sj3))+((npx*sj3*sj6)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x2021=((50.0)*sj6);
IkReal x2022=(cj6*npy);
IkReal x2023=((21.0)*sj3);
IkReal x2024=(npx*npy);
CheckValue<IkReal> x2025=IKPowWithIntegerCheck(sj3,-1);
if(!x2025.valid){
continue;
}
CheckValue<IkReal> x2026=IKPowWithIntegerCheck((((x2022*x2023))+((npx*sj6*x2023))),-1);
if(!x2026.valid){
continue;
}
if( IKabs(((0.0476190476190476)*(x2025.value)*((((npx*x2021))+(((50.0)*x2022)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x2026.value)*((((cj6*x2021*(npx*npx)))+(((-1.0)*npy*x2021*x2022))+(((100.0)*cj6*npx*x2022))+(((-50.0)*x2024)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.0476190476190476)*(x2025.value)*((((npx*x2021))+(((50.0)*x2022))))))+IKsqr(((x2026.value)*((((cj6*x2021*(npx*npx)))+(((-1.0)*npy*x2021*x2022))+(((100.0)*cj6*npx*x2022))+(((-50.0)*x2024))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((0.0476190476190476)*(x2025.value)*((((npx*x2021))+(((50.0)*x2022))))), ((x2026.value)*((((cj6*x2021*(npx*npx)))+(((-1.0)*npy*x2021*x2022))+(((100.0)*cj6*npx*x2022))+(((-50.0)*x2024))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x2027=IKcos(j4);
IkReal x2028=IKsin(j4);
IkReal x2029=((1.0)*cj6);
IkReal x2030=(npx*sj6);
IkReal x2031=((0.42)*sj3);
IkReal x2032=(npy*sj6);
evalcond[0]=(((x2027*x2031))+x2032+(((-1.0)*npx*x2029)));
evalcond[1]=(((x2028*x2031))+(((-1.0)*x2030))+(((-1.0)*npy*x2029)));
evalcond[2]=(((x2027*x2030))+((x2028*x2032))+((cj6*npy*x2027))+(((-1.0)*npx*x2028*x2029)));
evalcond[3]=(((x2027*x2032))+x2031+(((-1.0)*x2028*x2030))+(((-1.0)*npy*x2028*x2029))+(((-1.0)*npx*x2027*x2029)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x2033=((21.0)*sj3);
IkReal x2034=(cj6*npx);
IkReal x2035=(npy*sj6);
IkReal x2036=(npx*npy);
IkReal x2037=((50.0)*cj6*sj6);
CheckValue<IkReal> x2038=IKPowWithIntegerCheck((((x2033*x2035))+(((-1.0)*x2033*x2034))),-1);
if(!x2038.valid){
continue;
}
CheckValue<IkReal> x2039=IKPowWithIntegerCheck(sj3,-1);
if(!x2039.valid){
continue;
}
if( IKabs(((x2038.value)*(((((-50.0)*npx*sj6*x2034))+(((50.0)*cj6*npy*x2035))+(((-100.0)*cj6*npy*x2034))+(((50.0)*x2036)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.0476190476190476)*(x2039.value)*(((((50.0)*x2034))+(((-50.0)*x2035)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x2038.value)*(((((-50.0)*npx*sj6*x2034))+(((50.0)*cj6*npy*x2035))+(((-100.0)*cj6*npy*x2034))+(((50.0)*x2036))))))+IKsqr(((0.0476190476190476)*(x2039.value)*(((((50.0)*x2034))+(((-50.0)*x2035))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x2038.value)*(((((-50.0)*npx*sj6*x2034))+(((50.0)*cj6*npy*x2035))+(((-100.0)*cj6*npy*x2034))+(((50.0)*x2036))))), ((0.0476190476190476)*(x2039.value)*(((((50.0)*x2034))+(((-50.0)*x2035))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x2040=IKcos(j4);
IkReal x2041=IKsin(j4);
IkReal x2042=((1.0)*cj6);
IkReal x2043=(npx*sj6);
IkReal x2044=((0.42)*sj3);
IkReal x2045=(npy*sj6);
evalcond[0]=(((x2040*x2044))+x2045+(((-1.0)*npx*x2042)));
evalcond[1]=(((x2041*x2044))+(((-1.0)*npy*x2042))+(((-1.0)*x2043)));
evalcond[2]=(((x2041*x2045))+((x2040*x2043))+(((-1.0)*npx*x2041*x2042))+((cj6*npy*x2040)));
evalcond[3]=((((-1.0)*npy*x2041*x2042))+((x2040*x2045))+(((-1.0)*x2041*x2043))+x2044+(((-1.0)*npx*x2040*x2042)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x2046=((50.0)*npx);
IkReal x2047=((50.0)*npy);
CheckValue<IkReal> x2048=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x2048.valid){
continue;
}
CheckValue<IkReal> x2049 = IKatan2WithCheck(IkReal((((sj6*x2046))+((cj6*x2047)))),IkReal(((((-1.0)*sj6*x2047))+((cj6*x2046)))),IKFAST_ATAN2_MAGTHRESH);
if(!x2049.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x2048.value)))+(x2049.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x2050=IKcos(j4);
IkReal x2051=IKsin(j4);
IkReal x2052=((1.0)*cj6);
IkReal x2053=(npx*sj6);
IkReal x2054=((0.42)*sj3);
IkReal x2055=(npy*sj6);
evalcond[0]=(x2055+((x2050*x2054))+(((-1.0)*npx*x2052)));
evalcond[1]=((((-1.0)*x2053))+((x2051*x2054))+(((-1.0)*npy*x2052)));
evalcond[2]=((((-1.0)*npx*x2051*x2052))+((cj6*npy*x2050))+((x2050*x2053))+((x2051*x2055)));
evalcond[3]=((((-1.0)*npx*x2050*x2052))+(((-1.0)*npy*x2051*x2052))+x2054+(((-1.0)*x2051*x2053))+((x2050*x2055)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x2060=IKPowWithIntegerCheck(sj3,-1);
if(!x2060.valid){
continue;
}
IkReal x2056=x2060.value;
IkReal x2057=((50.0)*npx);
IkReal x2058=((0.0476190476190476)*x2056);
IkReal x2059=((50.0)*npy);
CheckValue<IkReal> x2061=IKPowWithIntegerCheck(cj5,-1);
if(!x2061.valid){
continue;
}
if( IKabs((x2058*((((cj6*x2059))+((sj6*x2057)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x2058*(x2061.value)*(((((21.0)*cj3*sj5))+(((20.0)*sj5))+((sj6*x2059))+(((-1.0)*cj6*x2057)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x2058*((((cj6*x2059))+((sj6*x2057))))))+IKsqr((x2058*(x2061.value)*(((((21.0)*cj3*sj5))+(((20.0)*sj5))+((sj6*x2059))+(((-1.0)*cj6*x2057))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((x2058*((((cj6*x2059))+((sj6*x2057))))), (x2058*(x2061.value)*(((((21.0)*cj3*sj5))+(((20.0)*sj5))+((sj6*x2059))+(((-1.0)*cj6*x2057))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x2062=IKcos(j4);
IkReal x2063=IKsin(j4);
IkReal x2064=(npy*sj6);
IkReal x2065=(cj6*npy);
IkReal x2066=(npx*sj6);
IkReal x2067=((1.0)*cj5);
IkReal x2068=((0.42)*sj3);
IkReal x2069=(npz*sj5);
IkReal x2070=((0.42)*cj3);
IkReal x2071=(cj5*cj6*npx);
IkReal x2072=((1.0)*x2063);
evalcond[0]=((((-1.0)*x2065))+(((-1.0)*x2066))+((x2063*x2068)));
evalcond[1]=(((sj5*x2062*x2068))+(((0.4)*cj5))+(((-1.0)*npz))+((cj5*x2070)));
evalcond[2]=((((-1.0)*cj5*x2062*x2068))+x2064+(((-1.0)*cj6*npx))+(((0.4)*sj5))+((sj5*x2070)));
evalcond[3]=((((-1.0)*x2063*x2064*x2067))+(((-1.0)*x2069*x2072))+((x2063*x2071))+((x2062*x2065))+((x2062*x2066)));
evalcond[4]=(x2068+(((-1.0)*x2062*x2064*x2067))+(((-1.0)*x2062*x2069))+(((-1.0)*x2065*x2072))+((x2062*x2071))+(((-1.0)*x2066*x2072)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x2075=IKPowWithIntegerCheck(sj3,-1);
if(!x2075.valid){
continue;
}
IkReal x2073=x2075.value;
IkReal x2074=((0.0476190476190476)*x2073);
CheckValue<IkReal> x2076=IKPowWithIntegerCheck(sj5,-1);
if(!x2076.valid){
continue;
}
if( IKabs((x2074*(((((50.0)*cj6*npy))+(((50.0)*npx*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x2074*(x2076.value)*(((((-21.0)*cj3*cj5))+(((50.0)*npz))+(((-20.0)*cj5)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x2074*(((((50.0)*cj6*npy))+(((50.0)*npx*sj6))))))+IKsqr((x2074*(x2076.value)*(((((-21.0)*cj3*cj5))+(((50.0)*npz))+(((-20.0)*cj5))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((x2074*(((((50.0)*cj6*npy))+(((50.0)*npx*sj6))))), (x2074*(x2076.value)*(((((-21.0)*cj3*cj5))+(((50.0)*npz))+(((-20.0)*cj5))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x2077=IKcos(j4);
IkReal x2078=IKsin(j4);
IkReal x2079=(npy*sj6);
IkReal x2080=(cj6*npy);
IkReal x2081=(npx*sj6);
IkReal x2082=((1.0)*cj5);
IkReal x2083=((0.42)*sj3);
IkReal x2084=(npz*sj5);
IkReal x2085=((0.42)*cj3);
IkReal x2086=(cj5*cj6*npx);
IkReal x2087=((1.0)*x2078);
evalcond[0]=((((-1.0)*x2080))+(((-1.0)*x2081))+((x2078*x2083)));
evalcond[1]=((((0.4)*cj5))+(((-1.0)*npz))+((cj5*x2085))+((sj5*x2077*x2083)));
evalcond[2]=(x2079+(((-1.0)*cj5*x2077*x2083))+(((-1.0)*cj6*npx))+(((0.4)*sj5))+((sj5*x2085)));
evalcond[3]=(((x2078*x2086))+(((-1.0)*x2084*x2087))+((x2077*x2080))+((x2077*x2081))+(((-1.0)*x2078*x2079*x2082)));
evalcond[4]=((((-1.0)*x2077*x2084))+x2083+(((-1.0)*x2081*x2087))+((x2077*x2086))+(((-1.0)*x2080*x2087))+(((-1.0)*x2077*x2079*x2082)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x2088=((50.0)*sj6);
IkReal x2089=(cj5*cj6);
IkReal x2090=(cj6*npy);
IkReal x2091=((21.0)*sj3);
IkReal x2092=(npz*sj5);
IkReal x2093=(cj5*npx*npy);
CheckValue<IkReal> x2094=IKPowWithIntegerCheck(sj3,-1);
if(!x2094.valid){
continue;
}
CheckValue<IkReal> x2095=IKPowWithIntegerCheck((((npx*sj6*x2091))+((x2090*x2091))),-1);
if(!x2095.valid){
continue;
}
if( IKabs(((0.0476190476190476)*(x2094.value)*(((((50.0)*x2090))+((npx*x2088)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x2095.value)*(((((50.0)*x2093))+(((50.0)*x2090*x2092))+((npx*x2088*x2092))+((x2088*x2089*(npy*npy)))+(((-100.0)*npx*x2089*x2090))+(((-1.0)*x2088*x2089*(npx*npx))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.0476190476190476)*(x2094.value)*(((((50.0)*x2090))+((npx*x2088))))))+IKsqr(((x2095.value)*(((((50.0)*x2093))+(((50.0)*x2090*x2092))+((npx*x2088*x2092))+((x2088*x2089*(npy*npy)))+(((-100.0)*npx*x2089*x2090))+(((-1.0)*x2088*x2089*(npx*npx)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((0.0476190476190476)*(x2094.value)*(((((50.0)*x2090))+((npx*x2088))))), ((x2095.value)*(((((50.0)*x2093))+(((50.0)*x2090*x2092))+((npx*x2088*x2092))+((x2088*x2089*(npy*npy)))+(((-100.0)*npx*x2089*x2090))+(((-1.0)*x2088*x2089*(npx*npx)))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x2096=IKcos(j4);
IkReal x2097=IKsin(j4);
IkReal x2098=(npy*sj6);
IkReal x2099=(cj6*npy);
IkReal x2100=(npx*sj6);
IkReal x2101=((1.0)*cj5);
IkReal x2102=((0.42)*sj3);
IkReal x2103=(npz*sj5);
IkReal x2104=((0.42)*cj3);
IkReal x2105=(cj5*cj6*npx);
IkReal x2106=((1.0)*x2097);
evalcond[0]=(((x2097*x2102))+(((-1.0)*x2100))+(((-1.0)*x2099)));
evalcond[1]=(((cj5*x2104))+((sj5*x2096*x2102))+(((0.4)*cj5))+(((-1.0)*npz)));
evalcond[2]=(x2098+(((-1.0)*cj6*npx))+(((0.4)*sj5))+((sj5*x2104))+(((-1.0)*cj5*x2096*x2102)));
evalcond[3]=((((-1.0)*x2103*x2106))+((x2096*x2099))+((x2097*x2105))+((x2096*x2100))+(((-1.0)*x2097*x2098*x2101)));
evalcond[4]=((((-1.0)*x2100*x2106))+(((-1.0)*x2096*x2098*x2101))+x2102+(((-1.0)*x2099*x2106))+(((-1.0)*x2096*x2103))+((x2096*x2105)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}
}
}
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x82=(r02*sj5);
IkReal x83=((1.0)*cj5);
IkReal x84=((1.0)*sj6);
IkReal x85=((1.0)*cj4);
IkReal x86=((1.0)*cj3);
IkReal x87=((1.0)*sj4);
IkReal x88=((1.0)*cj6);
IkReal x89=(((cj6*r00))+(((-1.0)*r01*x84)));
IkReal x90=((((-1.0)*r11*x84))+((cj6*r10)));
IkReal x91=(((cj6*r20))+(((-1.0)*r21*x84)));
IkReal x92=((((-1.0)*r00*x84))+(((-1.0)*r01*x88)));
IkReal x93=((((-1.0)*r11*x88))+(((-1.0)*r10*x84)));
IkReal x94=((((-1.0)*r20*x84))+(((-1.0)*r21*x88)));
IkReal x95=(((sj5*x89))+((cj5*r02)));
IkReal x96=((((-1.0)*x83*x89))+x82);
IkReal x97=((((-1.0)*x83*x90))+((r12*sj5)));
IkReal x98=(((cj5*r12))+((sj5*x90)));
IkReal x99=((((-1.0)*x83*x91))+((r22*sj5)));
IkReal x100=(((cj5*r22))+((sj5*x91)));
IkReal x101=(sj4*x92);
IkReal x102=((1.0)*x94);
IkReal x103=((((-1.0)*x87*x93))+((cj4*x97)));
IkReal x104=((((-1.0)*x87*x94))+((cj4*x99)));
new_r00=(((sj3*x95))+(((-1.0)*x86*((((cj4*(((((-1.0)*cj5*x89))+x82))))+(((-1.0)*x101)))))));
new_r01=((((-1.0)*x87*x96))+(((-1.0)*x85*x92)));
new_r02=(((cj3*x95))+((sj3*(((((-1.0)*x87*x92))+((cj4*x96)))))));
new_r10=(((sj3*x98))+(((-1.0)*x103*x86)));
new_r11=((((-1.0)*x87*x97))+(((-1.0)*x85*x93)));
new_r12=(((sj3*x103))+((cj3*x98)));
new_r20=(((sj3*x100))+(((-1.0)*x104*x86)));
new_r21=((((-1.0)*x87*x99))+(((-1.0)*x85*x94)));
new_r22=(((cj3*x100))+((sj3*x104)));
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
cj1array[0]=new_r22;
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j0eval[3];
j0eval[0]=sj1;
j0eval[1]=((IKabs(new_r12))+(IKabs(new_r02)));
j0eval[2]=IKsign(sj1);
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
j2eval[0]=sj1;
j2eval[1]=IKsign(sj1);
j2eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
j0eval[0]=new_r12;
j0eval[1]=sj1;
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r21;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j2mul = 1;
j2=0;
j0mul=-1.0;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r00));
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].fmul = j0mul;
vinfos[0].freeind = 0;
vinfos[0].maxsolutions = 0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].fmul = j2mul;
vinfos[2].freeind = 0;
vinfos[2].maxsolutions = 0;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(1);
vfree[0] = 2;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r21;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j2mul = 1;
j2=0;
j0mul=1.0;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0=IKatan2(new_r10, ((-1.0)*new_r11));
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].fmul = j0mul;
vinfos[0].freeind = 0;
vinfos[0].maxsolutions = 0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].fmul = j2mul;
vinfos[2].freeind = 0;
vinfos[2].maxsolutions = 0;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(1);
vfree[0] = 2;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x105=new_r22*new_r22;
IkReal x106=((16.0)*new_r10);
IkReal x107=((16.0)*new_r01);
IkReal x108=((16.0)*new_r22);
IkReal x109=((8.0)*new_r11);
IkReal x110=((8.0)*new_r00);
IkReal x111=(x105*x106);
IkReal x112=(x105*x107);
j0eval[0]=((IKabs(((((-1.0)*x111))+x106)))+(IKabs((((new_r22*x109))+(((-1.0)*x110)))))+(IKabs(((((-1.0)*x112))+x107)))+(IKabs(((((32.0)*new_r11))+(((-1.0)*new_r00*x108))+(((-16.0)*new_r11*x105)))))+(IKabs(((((-32.0)*new_r00*x105))+(((16.0)*new_r00))+((new_r11*x108)))))+(IKabs(((((-1.0)*x107))+x112)))+(IKabs(((((-1.0)*x106))+x111)))+(IKabs(((((-1.0)*new_r22*x110))+((x105*x109))))));
if( IKabs(j0eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j0, j2]

} else
{
IkReal op[4+1], zeror[4];
int numroots;
IkReal j0evalpoly[1];
IkReal x113=new_r22*new_r22;
IkReal x114=((16.0)*new_r10);
IkReal x115=(new_r11*new_r22);
IkReal x116=(x113*x114);
IkReal x117=((((8.0)*x115))+(((-8.0)*new_r00)));
op[0]=x117;
op[1]=((((-1.0)*x116))+x114);
op[2]=((((16.0)*x115))+(((16.0)*new_r00))+(((-32.0)*new_r00*x113)));
op[3]=((((-1.0)*x114))+x116);
op[4]=x117;
polyroots4(op,zeror,numroots);
IkReal j0array[4], cj0array[4], sj0array[4], tempj0array[1];
int numsolutions = 0;
for(int ij0 = 0; ij0 < numroots; ++ij0)
{
IkReal htj0 = zeror[ij0];
tempj0array[0]=((2.0)*(atan(htj0)));
for(int kj0 = 0; kj0 < 1; ++kj0)
{
j0array[numsolutions] = tempj0array[kj0];
if( j0array[numsolutions] > IKPI )
{
    j0array[numsolutions]-=IK2PI;
}
else if( j0array[numsolutions] < -IKPI )
{
    j0array[numsolutions]+=IK2PI;
}
sj0array[numsolutions] = IKsin(j0array[numsolutions]);
cj0array[numsolutions] = IKcos(j0array[numsolutions]);
numsolutions++;
}
}
bool j0valid[4]={true,true,true,true};
_nj0 = 4;
for(int ij0 = 0; ij0 < numsolutions; ++ij0)
    {
if( !j0valid[ij0] )
{
    continue;
}
    j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
htj0 = IKtan(j0/2);

IkReal x118=((16.0)*new_r01);
IkReal x119=new_r22*new_r22;
IkReal x120=(new_r00*new_r22);
IkReal x121=((8.0)*x120);
IkReal x122=(new_r11*x119);
IkReal x123=(x118*x119);
IkReal x124=((8.0)*x122);
j0evalpoly[0]=(((htj0*(((((-1.0)*x123))+x118))))+(((htj0*htj0)*(((((-16.0)*x122))+(((-16.0)*x120))+(((32.0)*new_r11))))))+(((-1.0)*x121))+x124+(((htj0*htj0*htj0*htj0)*(((((-1.0)*x121))+x124))))+(((htj0*htj0*htj0)*(((((-1.0)*x118))+x123)))));
if( IKabs(j0evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < numsolutions; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
{
IkReal j2eval[3];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x125=cj0*cj0;
IkReal x126=new_r22*new_r22;
IkReal x127=((1.0)*cj0);
IkReal x128=(new_r22*sj0);
IkReal x129=((((-1.0)*x125*x126))+x126+x125);
j2eval[0]=x129;
j2eval[1]=((IKabs(((((-1.0)*new_r10*x127))+((new_r11*x128)))))+(IKabs(((((-1.0)*new_r10*x128))+(((-1.0)*new_r11*x127))))));
j2eval[2]=IKsign(x129);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j2eval[0]=new_r22;
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j2eval[0]=cj0;
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r00, new_r01);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x130=IKsin(j2);
IkReal x131=IKcos(j2);
evalcond[0]=x131;
evalcond[1]=((-1.0)*x130);
evalcond[2]=(x130+(((-1.0)*new_r00)));
evalcond[3]=(x131+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x132=IKcos(j2);
IkReal x133=IKsin(j2);
evalcond[0]=x132;
evalcond[1]=(x133+new_r00);
evalcond[2]=(x132+new_r01);
evalcond[3]=((-1.0)*x133);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x134=new_r22*new_r22;
CheckValue<IkReal> x135=IKPowWithIntegerCheck(((1.0)+(((-1.0)*x134))),-1);
if(!x135.valid){
continue;
}
if((((-1.0)*x134*(x135.value))) < -0.00001)
continue;
IkReal gconst12=IKsqrt(((-1.0)*x134*(x135.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj0+(((-1.0)*gconst12)))))+(IKabs(((-1.0)+(IKsign(sj0)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
IkReal x136=new_r22*new_r22;
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst12*gconst12))))) < -0.00001)
continue;
sj0=IKsqrt(((1.0)+(((-1.0)*(gconst12*gconst12)))));
cj0=gconst12;
if( (gconst12) < -1-IKFAST_SINCOS_THRESH || (gconst12) > 1+IKFAST_SINCOS_THRESH )
    continue;
j0=IKacos(gconst12);
CheckValue<IkReal> x137=IKPowWithIntegerCheck(((1.0)+(((-1.0)*x136))),-1);
if(!x137.valid){
continue;
}
if((((-1.0)*x136*(x137.value))) < -0.00001)
continue;
IkReal gconst12=IKsqrt(((-1.0)*x136*(x137.value)));
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x138=IKPowWithIntegerCheck(gconst12,-1);
if(!x138.valid){
continue;
}
if((((1.0)+(((-1.0)*(gconst12*gconst12))))) < -0.00001)
continue;
if( IKabs(((-1.0)*new_r10*(x138.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst12*gconst12))))))))+(((-1.0)*gconst12*new_r11)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10*(x138.value)))+IKsqr((((new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst12*gconst12))))))))+(((-1.0)*gconst12*new_r11))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r10*(x138.value)), (((new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst12*gconst12))))))))+(((-1.0)*gconst12*new_r11))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x139=IKsin(j2);
IkReal x140=IKcos(j2);
if((((1.0)+(((-1.0)*(gconst12*gconst12))))) < -0.00001)
continue;
IkReal x141=IKsqrt(((1.0)+(((-1.0)*(gconst12*gconst12)))));
IkReal x142=((1.0)*x141);
evalcond[0]=x140;
evalcond[1]=((-1.0)*x139);
evalcond[2]=(((gconst12*x139))+new_r10);
evalcond[3]=(((gconst12*x140))+new_r11);
evalcond[4]=((((-1.0)*x139*x142))+new_r00);
evalcond[5]=((((-1.0)*x140*x142))+new_r01);
evalcond[6]=(x139+(((-1.0)*new_r00*x142))+((gconst12*new_r10)));
evalcond[7]=((((-1.0)*new_r01*x142))+x140+((gconst12*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x143 = IKatan2WithCheck(IkReal(((-1.0)*new_r10)),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x143.valid){
continue;
}
CheckValue<IkReal> x144=IKPowWithIntegerCheck(IKsign(gconst12),-1);
if(!x144.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x143.value)+(((1.5707963267949)*(x144.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x145=IKsin(j2);
IkReal x146=IKcos(j2);
if((((1.0)+(((-1.0)*(gconst12*gconst12))))) < -0.00001)
continue;
IkReal x147=IKsqrt(((1.0)+(((-1.0)*(gconst12*gconst12)))));
IkReal x148=((1.0)*x147);
evalcond[0]=x146;
evalcond[1]=((-1.0)*x145);
evalcond[2]=(((gconst12*x145))+new_r10);
evalcond[3]=(((gconst12*x146))+new_r11);
evalcond[4]=((((-1.0)*x145*x148))+new_r00);
evalcond[5]=((((-1.0)*x146*x148))+new_r01);
evalcond[6]=(x145+(((-1.0)*new_r00*x148))+((gconst12*new_r10)));
evalcond[7]=((((-1.0)*new_r01*x148))+x146+((gconst12*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x149=new_r22*new_r22;
CheckValue<IkReal> x150=IKPowWithIntegerCheck(((1.0)+(((-1.0)*x149))),-1);
if(!x150.valid){
continue;
}
if((((-1.0)*x149*(x150.value))) < -0.00001)
continue;
IkReal gconst12=IKsqrt(((-1.0)*x149*(x150.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj0+(((-1.0)*gconst12)))))+(IKabs(((1.0)+(IKsign(sj0)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
IkReal x151=new_r22*new_r22;
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst12*gconst12))))) < -0.00001)
continue;
sj0=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst12*gconst12)))))));
cj0=gconst12;
if( (gconst12) < -1-IKFAST_SINCOS_THRESH || (gconst12) > 1+IKFAST_SINCOS_THRESH )
    continue;
j0=((-1.0)*(IKacos(gconst12)));
CheckValue<IkReal> x152=IKPowWithIntegerCheck(((1.0)+(((-1.0)*x151))),-1);
if(!x152.valid){
continue;
}
if((((-1.0)*x151*(x152.value))) < -0.00001)
continue;
IkReal gconst12=IKsqrt(((-1.0)*x151*(x152.value)));
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x153=IKPowWithIntegerCheck(gconst12,-1);
if(!x153.valid){
continue;
}
if((((1.0)+(((-1.0)*(gconst12*gconst12))))) < -0.00001)
continue;
if( IKabs(((-1.0)*new_r10*(x153.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst12*gconst12))))))))+(((-1.0)*gconst12*new_r11)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10*(x153.value)))+IKsqr(((((-1.0)*new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst12*gconst12))))))))+(((-1.0)*gconst12*new_r11))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r10*(x153.value)), ((((-1.0)*new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst12*gconst12))))))))+(((-1.0)*gconst12*new_r11))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x154=IKsin(j2);
IkReal x155=IKcos(j2);
if((((1.0)+(((-1.0)*(gconst12*gconst12))))) < -0.00001)
continue;
IkReal x156=IKsqrt(((1.0)+(((-1.0)*(gconst12*gconst12)))));
evalcond[0]=x155;
evalcond[1]=((-1.0)*x154);
evalcond[2]=(((gconst12*x154))+new_r10);
evalcond[3]=(((gconst12*x155))+new_r11);
evalcond[4]=(((x154*x156))+new_r00);
evalcond[5]=(((x155*x156))+new_r01);
evalcond[6]=(((new_r00*x156))+x154+((gconst12*new_r10)));
evalcond[7]=(((new_r01*x156))+x155+((gconst12*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x157 = IKatan2WithCheck(IkReal(((-1.0)*new_r10)),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x157.valid){
continue;
}
CheckValue<IkReal> x158=IKPowWithIntegerCheck(IKsign(gconst12),-1);
if(!x158.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x157.value)+(((1.5707963267949)*(x158.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x159=IKsin(j2);
IkReal x160=IKcos(j2);
if((((1.0)+(((-1.0)*(gconst12*gconst12))))) < -0.00001)
continue;
IkReal x161=IKsqrt(((1.0)+(((-1.0)*(gconst12*gconst12)))));
evalcond[0]=x160;
evalcond[1]=((-1.0)*x159);
evalcond[2]=(((gconst12*x159))+new_r10);
evalcond[3]=(((gconst12*x160))+new_r11);
evalcond[4]=(new_r00+((x159*x161)));
evalcond[5]=(new_r01+((x160*x161)));
evalcond[6]=(((new_r00*x161))+x159+((gconst12*new_r10)));
evalcond[7]=(((new_r01*x161))+x160+((gconst12*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x162=new_r22*new_r22;
CheckValue<IkReal> x163=IKPowWithIntegerCheck(((1.0)+(((-1.0)*x162))),-1);
if(!x163.valid){
continue;
}
if((((-1.0)*x162*(x163.value))) < -0.00001)
continue;
IkReal gconst13=((-1.0)*(IKsqrt(((-1.0)*x162*(x163.value)))));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj0+(((-1.0)*gconst13)))))+(IKabs(((-1.0)+(IKsign(sj0)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
IkReal x164=new_r22*new_r22;
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst13*gconst13))))) < -0.00001)
continue;
sj0=IKsqrt(((1.0)+(((-1.0)*(gconst13*gconst13)))));
cj0=gconst13;
if( (gconst13) < -1-IKFAST_SINCOS_THRESH || (gconst13) > 1+IKFAST_SINCOS_THRESH )
    continue;
j0=IKacos(gconst13);
CheckValue<IkReal> x165=IKPowWithIntegerCheck(((1.0)+(((-1.0)*x164))),-1);
if(!x165.valid){
continue;
}
if((((-1.0)*x164*(x165.value))) < -0.00001)
continue;
IkReal gconst13=((-1.0)*(IKsqrt(((-1.0)*x164*(x165.value)))));
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x166=IKPowWithIntegerCheck(gconst13,-1);
if(!x166.valid){
continue;
}
if((((1.0)+(((-1.0)*(gconst13*gconst13))))) < -0.00001)
continue;
if( IKabs(((-1.0)*new_r10*(x166.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*gconst13*new_r11))+((new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst13*gconst13)))))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10*(x166.value)))+IKsqr(((((-1.0)*gconst13*new_r11))+((new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst13*gconst13))))))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r10*(x166.value)), ((((-1.0)*gconst13*new_r11))+((new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst13*gconst13))))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x167=IKsin(j2);
IkReal x168=IKcos(j2);
if((((1.0)+(((-1.0)*(gconst13*gconst13))))) < -0.00001)
continue;
IkReal x169=IKsqrt(((1.0)+(((-1.0)*(gconst13*gconst13)))));
IkReal x170=((1.0)*x169);
evalcond[0]=x168;
evalcond[1]=((-1.0)*x167);
evalcond[2]=(new_r10+((gconst13*x167)));
evalcond[3]=(new_r11+((gconst13*x168)));
evalcond[4]=(new_r00+(((-1.0)*x167*x170)));
evalcond[5]=((((-1.0)*x168*x170))+new_r01);
evalcond[6]=(x167+((gconst13*new_r10))+(((-1.0)*new_r00*x170)));
evalcond[7]=(x168+((gconst13*new_r11))+(((-1.0)*new_r01*x170)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x171 = IKatan2WithCheck(IkReal(((-1.0)*new_r10)),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x171.valid){
continue;
}
CheckValue<IkReal> x172=IKPowWithIntegerCheck(IKsign(gconst13),-1);
if(!x172.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x171.value)+(((1.5707963267949)*(x172.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x173=IKsin(j2);
IkReal x174=IKcos(j2);
if((((1.0)+(((-1.0)*(gconst13*gconst13))))) < -0.00001)
continue;
IkReal x175=IKsqrt(((1.0)+(((-1.0)*(gconst13*gconst13)))));
IkReal x176=((1.0)*x175);
evalcond[0]=x174;
evalcond[1]=((-1.0)*x173);
evalcond[2]=(new_r10+((gconst13*x173)));
evalcond[3]=(new_r11+((gconst13*x174)));
evalcond[4]=(new_r00+(((-1.0)*x173*x176)));
evalcond[5]=((((-1.0)*x174*x176))+new_r01);
evalcond[6]=(x173+((gconst13*new_r10))+(((-1.0)*new_r00*x176)));
evalcond[7]=(x174+((gconst13*new_r11))+(((-1.0)*new_r01*x176)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x177=new_r22*new_r22;
CheckValue<IkReal> x178=IKPowWithIntegerCheck(((1.0)+(((-1.0)*x177))),-1);
if(!x178.valid){
continue;
}
if((((-1.0)*x177*(x178.value))) < -0.00001)
continue;
IkReal gconst13=((-1.0)*(IKsqrt(((-1.0)*x177*(x178.value)))));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.0)+(IKsign(sj0)))))+(IKabs((cj0+(((-1.0)*gconst13)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
IkReal x179=new_r22*new_r22;
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst13*gconst13))))) < -0.00001)
continue;
sj0=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst13*gconst13)))))));
cj0=gconst13;
if( (gconst13) < -1-IKFAST_SINCOS_THRESH || (gconst13) > 1+IKFAST_SINCOS_THRESH )
    continue;
j0=((-1.0)*(IKacos(gconst13)));
CheckValue<IkReal> x180=IKPowWithIntegerCheck(((1.0)+(((-1.0)*x179))),-1);
if(!x180.valid){
continue;
}
if((((-1.0)*x179*(x180.value))) < -0.00001)
continue;
IkReal gconst13=((-1.0)*(IKsqrt(((-1.0)*x179*(x180.value)))));
j2eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x181=IKPowWithIntegerCheck(gconst13,-1);
if(!x181.valid){
continue;
}
if((((1.0)+(((-1.0)*(gconst13*gconst13))))) < -0.00001)
continue;
if( IKabs(((-1.0)*new_r10*(x181.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*gconst13*new_r11))+(((-1.0)*new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst13*gconst13)))))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10*(x181.value)))+IKsqr(((((-1.0)*gconst13*new_r11))+(((-1.0)*new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst13*gconst13))))))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r10*(x181.value)), ((((-1.0)*gconst13*new_r11))+(((-1.0)*new_r01*(IKsqrt(((1.0)+(((-1.0)*(gconst13*gconst13))))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x182=IKsin(j2);
IkReal x183=IKcos(j2);
if((((1.0)+(((-1.0)*(gconst13*gconst13))))) < -0.00001)
continue;
IkReal x184=IKsqrt(((1.0)+(((-1.0)*(gconst13*gconst13)))));
evalcond[0]=x183;
evalcond[1]=((-1.0)*x182);
evalcond[2]=(((gconst13*x182))+new_r10);
evalcond[3]=(((gconst13*x183))+new_r11);
evalcond[4]=(new_r00+((x182*x184)));
evalcond[5]=(new_r01+((x183*x184)));
evalcond[6]=(((new_r00*x184))+x182+((gconst13*new_r10)));
evalcond[7]=(((new_r01*x184))+x183+((gconst13*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x185 = IKatan2WithCheck(IkReal(((-1.0)*new_r10)),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x185.valid){
continue;
}
CheckValue<IkReal> x186=IKPowWithIntegerCheck(IKsign(gconst13),-1);
if(!x186.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x185.value)+(((1.5707963267949)*(x186.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x187=IKsin(j2);
IkReal x188=IKcos(j2);
if((((1.0)+(((-1.0)*(gconst13*gconst13))))) < -0.00001)
continue;
IkReal x189=IKsqrt(((1.0)+(((-1.0)*(gconst13*gconst13)))));
evalcond[0]=x188;
evalcond[1]=((-1.0)*x187);
evalcond[2]=(((gconst13*x187))+new_r10);
evalcond[3]=(((gconst13*x188))+new_r11);
evalcond[4]=(((x187*x189))+new_r00);
evalcond[5]=(((x188*x189))+new_r01);
evalcond[6]=(((new_r00*x189))+x187+((gconst13*new_r10)));
evalcond[7]=(((new_r01*x189))+x188+((gconst13*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x190=(new_r01*new_r22);
IkReal x191=(cj0*new_r11);
CheckValue<IkReal> x192=IKPowWithIntegerCheck(cj0,-1);
if(!x192.valid){
continue;
}
if( IKabs(((x192.value)*((((new_r22*sj0*x191))+(((-1.0)*x190))+(((-1.0)*new_r10))+((x190*(cj0*cj0))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r01*sj0))+(((-1.0)*x191)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x192.value)*((((new_r22*sj0*x191))+(((-1.0)*x190))+(((-1.0)*new_r10))+((x190*(cj0*cj0)))))))+IKsqr((((new_r01*sj0))+(((-1.0)*x191))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((x192.value)*((((new_r22*sj0*x191))+(((-1.0)*x190))+(((-1.0)*new_r10))+((x190*(cj0*cj0)))))), (((new_r01*sj0))+(((-1.0)*x191))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[10];
IkReal x193=IKcos(j2);
IkReal x194=IKsin(j2);
IkReal x195=(cj0*new_r22);
IkReal x196=((1.0)*sj0);
IkReal x197=(new_r22*sj0);
IkReal x198=(new_r22*x194);
IkReal x199=((1.0)*x194);
evalcond[0]=(x194+(((-1.0)*new_r00*x196))+((cj0*new_r10)));
evalcond[1]=(x193+(((-1.0)*new_r01*x196))+((cj0*new_r11)));
evalcond[2]=(((new_r10*sj0))+((new_r22*x193))+((cj0*new_r00)));
evalcond[3]=(((new_r10*x197))+((new_r00*x195))+x193);
evalcond[4]=(((x193*x197))+((cj0*x194))+new_r10);
evalcond[5]=(((new_r11*sj0))+(((-1.0)*x198))+((cj0*new_r01)));
evalcond[6]=(((x193*x195))+(((-1.0)*x194*x196))+new_r00);
evalcond[7]=((((-1.0)*x196*x198))+((cj0*x193))+new_r11);
evalcond[8]=(((new_r11*x197))+((new_r01*x195))+(((-1.0)*x199)));
evalcond[9]=((((-1.0)*x195*x199))+new_r01+(((-1.0)*x193*x196)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x200=((1.0)*cj0);
CheckValue<IkReal> x201=IKPowWithIntegerCheck(new_r22,-1);
if(!x201.valid){
continue;
}
if( IKabs((((new_r00*sj0))+(((-1.0)*new_r10*x200)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x201.value)*(((((-1.0)*new_r00*x200))+(((-1.0)*new_r10*sj0)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r00*sj0))+(((-1.0)*new_r10*x200))))+IKsqr(((x201.value)*(((((-1.0)*new_r00*x200))+(((-1.0)*new_r10*sj0))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((new_r00*sj0))+(((-1.0)*new_r10*x200))), ((x201.value)*(((((-1.0)*new_r00*x200))+(((-1.0)*new_r10*sj0))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[10];
IkReal x202=IKcos(j2);
IkReal x203=IKsin(j2);
IkReal x204=(cj0*new_r22);
IkReal x205=((1.0)*sj0);
IkReal x206=(new_r22*sj0);
IkReal x207=(new_r22*x203);
IkReal x208=((1.0)*x203);
evalcond[0]=((((-1.0)*new_r00*x205))+x203+((cj0*new_r10)));
evalcond[1]=(x202+((cj0*new_r11))+(((-1.0)*new_r01*x205)));
evalcond[2]=(((new_r10*sj0))+((new_r22*x202))+((cj0*new_r00)));
evalcond[3]=(((new_r10*x206))+((new_r00*x204))+x202);
evalcond[4]=(((x202*x206))+((cj0*x203))+new_r10);
evalcond[5]=(((new_r11*sj0))+((cj0*new_r01))+(((-1.0)*x207)));
evalcond[6]=((((-1.0)*x203*x205))+((x202*x204))+new_r00);
evalcond[7]=((((-1.0)*x205*x207))+((cj0*x202))+new_r11);
evalcond[8]=(((new_r11*x206))+((new_r01*x204))+(((-1.0)*x208)));
evalcond[9]=((((-1.0)*x204*x208))+(((-1.0)*x202*x205))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x209=cj0*cj0;
IkReal x210=new_r22*new_r22;
IkReal x211=((1.0)*cj0);
IkReal x212=(new_r22*sj0);
CheckValue<IkReal> x213=IKPowWithIntegerCheck(IKsign(((((-1.0)*x209*x210))+x210+x209)),-1);
if(!x213.valid){
continue;
}
CheckValue<IkReal> x214 = IKatan2WithCheck(IkReal(((((-1.0)*new_r10*x211))+((new_r11*x212)))),IkReal(((((-1.0)*new_r11*x211))+(((-1.0)*new_r10*x212)))),IKFAST_ATAN2_MAGTHRESH);
if(!x214.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x213.value)))+(x214.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[10];
IkReal x215=IKcos(j2);
IkReal x216=IKsin(j2);
IkReal x217=(cj0*new_r22);
IkReal x218=((1.0)*sj0);
IkReal x219=(new_r22*sj0);
IkReal x220=(new_r22*x216);
IkReal x221=((1.0)*x216);
evalcond[0]=(x216+(((-1.0)*new_r00*x218))+((cj0*new_r10)));
evalcond[1]=(x215+(((-1.0)*new_r01*x218))+((cj0*new_r11)));
evalcond[2]=(((new_r22*x215))+((new_r10*sj0))+((cj0*new_r00)));
evalcond[3]=(x215+((new_r00*x217))+((new_r10*x219)));
evalcond[4]=(((cj0*x216))+((x215*x219))+new_r10);
evalcond[5]=(((new_r11*sj0))+((cj0*new_r01))+(((-1.0)*x220)));
evalcond[6]=(((x215*x217))+new_r00+(((-1.0)*x216*x218)));
evalcond[7]=(((cj0*x215))+(((-1.0)*x218*x220))+new_r11);
evalcond[8]=(((new_r01*x217))+((new_r11*x219))+(((-1.0)*x221)));
evalcond[9]=((((-1.0)*x217*x221))+new_r01+(((-1.0)*x215*x218)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x223=IKPowWithIntegerCheck(sj1,-1);
if(!x223.valid){
continue;
}
IkReal x222=x223.value;
CheckValue<IkReal> x224=IKPowWithIntegerCheck(new_r12,-1);
if(!x224.valid){
continue;
}
if( IKabs((x222*(x224.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj1*cj1))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x222)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x222*(x224.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj1*cj1)))))))+IKsqr((new_r02*x222))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2((x222*(x224.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj1*cj1)))))), (new_r02*x222));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x225=IKcos(j0);
IkReal x226=IKsin(j0);
IkReal x227=((1.0)*cj1);
IkReal x228=((1.0)*sj1);
IkReal x229=(new_r12*x226);
IkReal x230=(new_r02*x225);
evalcond[0]=((((-1.0)*x225*x228))+new_r02);
evalcond[1]=(new_r12+(((-1.0)*x226*x228)));
evalcond[2]=(((new_r12*x225))+(((-1.0)*new_r02*x226)));
evalcond[3]=(x229+x230+(((-1.0)*x228)));
evalcond[4]=(((cj1*x230))+((cj1*x229))+(((-1.0)*new_r22*x228)));
evalcond[5]=((((-1.0)*new_r10*x226*x228))+(((-1.0)*new_r00*x225*x228))+(((-1.0)*new_r20*x227)));
evalcond[6]=((((-1.0)*new_r11*x226*x228))+(((-1.0)*new_r01*x225*x228))+(((-1.0)*new_r21*x227)));
evalcond[7]=((1.0)+(((-1.0)*x228*x229))+(((-1.0)*new_r22*x227))+(((-1.0)*x228*x230)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j2eval[3];
j2eval[0]=sj1;
j2eval[1]=IKsign(sj1);
j2eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
j2eval[0]=sj1;
j2eval[1]=cj0;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
j2eval[0]=sj1;
j2eval[1]=cj1;
j2eval[2]=sj0;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r21;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x231=((1.0)*cj0);
if( IKabs((((new_r00*sj0))+(((-1.0)*new_r10*x231)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r10*sj0))+(((-1.0)*new_r00*x231)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r00*sj0))+(((-1.0)*new_r10*x231))))+IKsqr(((((-1.0)*new_r10*sj0))+(((-1.0)*new_r00*x231))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((new_r00*sj0))+(((-1.0)*new_r10*x231))), ((((-1.0)*new_r10*sj0))+(((-1.0)*new_r00*x231))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x232=IKcos(j2);
IkReal x233=IKsin(j2);
IkReal x234=((1.0)*sj0);
IkReal x235=(cj0*x232);
IkReal x236=(cj0*x233);
IkReal x237=(x233*x234);
evalcond[0]=(((new_r10*sj0))+x232+((cj0*new_r00)));
evalcond[1]=(x233+((cj0*new_r10))+(((-1.0)*new_r00*x234)));
evalcond[2]=(x232+(((-1.0)*new_r01*x234))+((cj0*new_r11)));
evalcond[3]=(((sj0*x232))+x236+new_r10);
evalcond[4]=(((new_r11*sj0))+((cj0*new_r01))+(((-1.0)*x233)));
evalcond[5]=((((-1.0)*x237))+x235+new_r00);
evalcond[6]=((((-1.0)*x237))+x235+new_r11);
evalcond[7]=(new_r01+(((-1.0)*x236))+(((-1.0)*x232*x234)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r21;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x238=((1.0)*cj0);
if( IKabs(((((-1.0)*new_r11*sj0))+(((-1.0)*new_r10*x238)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r10*sj0))+(((-1.0)*new_r11*x238)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r11*sj0))+(((-1.0)*new_r10*x238))))+IKsqr((((new_r10*sj0))+(((-1.0)*new_r11*x238))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*new_r11*sj0))+(((-1.0)*new_r10*x238))), (((new_r10*sj0))+(((-1.0)*new_r11*x238))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x239=IKsin(j2);
IkReal x240=IKcos(j2);
IkReal x241=((1.0)*sj0);
IkReal x242=(cj0*x239);
IkReal x243=((1.0)*x240);
IkReal x244=(x240*x241);
evalcond[0]=(((new_r11*sj0))+x239+((cj0*new_r01)));
evalcond[1]=((((-1.0)*new_r00*x241))+x239+((cj0*new_r10)));
evalcond[2]=((((-1.0)*new_r01*x241))+x240+((cj0*new_r11)));
evalcond[3]=(((new_r10*sj0))+((cj0*new_r00))+(((-1.0)*x243)));
evalcond[4]=(((cj0*x240))+((sj0*x239))+new_r11);
evalcond[5]=(x242+(((-1.0)*x244))+new_r10);
evalcond[6]=(x242+(((-1.0)*x244))+new_r01);
evalcond[7]=((((-1.0)*cj0*x243))+new_r00+(((-1.0)*x239*x241)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x245=IKsin(j2);
IkReal x246=IKcos(j2);
IkReal x247=((1.0)*sj0);
evalcond[0]=(x245+new_r21);
evalcond[1]=((((-1.0)*x246))+new_r20);
evalcond[2]=(new_r10+((new_r02*x245)));
evalcond[3]=(((cj0*x246))+new_r11);
evalcond[4]=((((-1.0)*x245*x247))+new_r00);
evalcond[5]=(new_r01+(((-1.0)*x246*x247)));
evalcond[6]=((((-1.0)*new_r00*x247))+x245+((cj0*new_r10)));
evalcond[7]=((((-1.0)*new_r01*x247))+x246+((cj0*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x248=IKcos(j2);
IkReal x249=IKsin(j2);
IkReal x250=((1.0)*sj0);
IkReal x251=((1.0)*x249);
evalcond[0]=(x248+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x251)));
evalcond[2]=(((cj0*x248))+new_r11);
evalcond[3]=(new_r10+(((-1.0)*new_r02*x251)));
evalcond[4]=((((-1.0)*x249*x250))+new_r00);
evalcond[5]=((((-1.0)*x248*x250))+new_r01);
evalcond[6]=(x249+((cj0*new_r10))+(((-1.0)*new_r00*x250)));
evalcond[7]=((((-1.0)*new_r01*x250))+x248+((cj0*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j0))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x252=IKsin(j2);
IkReal x253=IKcos(j2);
IkReal x254=((1.0)*sj1);
IkReal x255=((1.0)*x252);
evalcond[0]=(x252+new_r10);
evalcond[1]=(x253+new_r11);
evalcond[2]=(((sj1*x252))+new_r21);
evalcond[3]=(((cj1*x253))+new_r00);
evalcond[4]=(new_r20+(((-1.0)*x253*x254)));
evalcond[5]=((((-1.0)*cj1*x255))+new_r01);
evalcond[6]=(((cj1*new_r00))+x253+(((-1.0)*new_r20*x254)));
evalcond[7]=((((-1.0)*new_r21*x254))+((cj1*new_r01))+(((-1.0)*x255)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j0)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r10, new_r11);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x256=IKsin(j2);
IkReal x257=IKcos(j2);
IkReal x258=((1.0)*sj1);
IkReal x259=((1.0)*new_r00);
IkReal x260=((1.0)*new_r01);
IkReal x261=((1.0)*x256);
evalcond[0]=(((sj1*x256))+new_r21);
evalcond[1]=(x256+(((-1.0)*new_r10)));
evalcond[2]=(x257+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x257*x258))+new_r20);
evalcond[4]=(((cj1*x257))+(((-1.0)*x259)));
evalcond[5]=((((-1.0)*cj1*x261))+(((-1.0)*x260)));
evalcond[6]=(x257+(((-1.0)*cj1*x259))+(((-1.0)*new_r20*x258)));
evalcond[7]=((((-1.0)*new_r21*x258))+(((-1.0)*cj1*x260))+(((-1.0)*x261)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j0)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r00, new_r01);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x262=IKsin(j2);
IkReal x263=IKcos(j2);
IkReal x264=((1.0)*sj1);
IkReal x265=((1.0)*x262);
evalcond[0]=(new_r21+((sj1*x262)));
evalcond[1]=(x262+(((-1.0)*new_r00)));
evalcond[2]=(x263+(((-1.0)*new_r01)));
evalcond[3]=(((cj1*x263))+new_r10);
evalcond[4]=((((-1.0)*x263*x264))+new_r20);
evalcond[5]=((((-1.0)*cj1*x265))+new_r11);
evalcond[6]=(((cj1*new_r10))+x263+(((-1.0)*new_r20*x264)));
evalcond[7]=(((cj1*new_r11))+(((-1.0)*new_r21*x264))+(((-1.0)*x265)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j0)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x266=IKsin(j2);
IkReal x267=IKcos(j2);
IkReal x268=((1.0)*new_r11);
IkReal x269=((1.0)*sj1);
IkReal x270=((1.0)*new_r10);
IkReal x271=((1.0)*x266);
evalcond[0]=(x266+new_r00);
evalcond[1]=(x267+new_r01);
evalcond[2]=(new_r21+((sj1*x266)));
evalcond[3]=((((-1.0)*x267*x269))+new_r20);
evalcond[4]=(((cj1*x267))+(((-1.0)*x270)));
evalcond[5]=((((-1.0)*cj1*x271))+(((-1.0)*x268)));
evalcond[6]=((((-1.0)*cj1*x270))+x267+(((-1.0)*new_r20*x269)));
evalcond[7]=((((-1.0)*cj1*x268))+(((-1.0)*new_r21*x269))+(((-1.0)*x271)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j2eval[0]=IKabs(new_r22);
if( IKabs(j2eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j2]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=((-1.0)*new_r22);
op[1]=0;
op[2]=new_r22;
polyroots2(op,zeror,numroots);
IkReal j2array[2], cj2array[2], sj2array[2], tempj2array[1];
int numsolutions = 0;
for(int ij2 = 0; ij2 < numroots; ++ij2)
{
IkReal htj2 = zeror[ij2];
tempj2array[0]=((2.0)*(atan(htj2)));
for(int kj2 = 0; kj2 < 1; ++kj2)
{
j2array[numsolutions] = tempj2array[kj2];
if( j2array[numsolutions] > IKPI )
{
    j2array[numsolutions]-=IK2PI;
}
else if( j2array[numsolutions] < -IKPI )
{
    j2array[numsolutions]+=IK2PI;
}
sj2array[numsolutions] = IKsin(j2array[numsolutions]);
cj2array[numsolutions] = IKcos(j2array[numsolutions]);
numsolutions++;
}
}
bool j2valid[2]={true,true};
_nj2 = 2;
for(int ij2 = 0; ij2 < numsolutions; ++ij2)
    {
if( !j2valid[ij2] )
{
    continue;
}
    j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
htj2 = IKtan(j2/2);

_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < numsolutions; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x273=IKPowWithIntegerCheck(sj1,-1);
if(!x273.valid){
continue;
}
IkReal x272=x273.value;
CheckValue<IkReal> x274=IKPowWithIntegerCheck(cj1,-1);
if(!x274.valid){
continue;
}
CheckValue<IkReal> x275=IKPowWithIntegerCheck(sj0,-1);
if(!x275.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*x272)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x272*(x274.value)*(x275.value)*((((cj0*new_r21))+(((-1.0)*new_r10*sj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*x272))+IKsqr((x272*(x274.value)*(x275.value)*((((cj0*new_r21))+(((-1.0)*new_r10*sj1))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r21*x272), (x272*(x274.value)*(x275.value)*((((cj0*new_r21))+(((-1.0)*new_r10*sj1))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[12];
IkReal x276=IKsin(j2);
IkReal x277=IKcos(j2);
IkReal x278=((1.0)*sj0);
IkReal x279=((1.0)*sj1);
IkReal x280=(cj0*new_r00);
IkReal x281=(cj1*sj0);
IkReal x282=(cj0*new_r01);
IkReal x283=(cj1*x277);
IkReal x284=(cj1*x276);
evalcond[0]=(new_r21+((sj1*x276)));
evalcond[1]=((((-1.0)*x277*x279))+new_r20);
evalcond[2]=((((-1.0)*new_r00*x278))+x276+((cj0*new_r10)));
evalcond[3]=((((-1.0)*new_r01*x278))+x277+((cj0*new_r11)));
evalcond[4]=(((new_r10*sj0))+x283+x280);
evalcond[5]=(new_r10+((x277*x281))+((cj0*x276)));
evalcond[6]=(((new_r11*sj0))+x282+(((-1.0)*x284)));
evalcond[7]=(((cj0*x283))+new_r00+(((-1.0)*x276*x278)));
evalcond[8]=(new_r11+(((-1.0)*x278*x284))+((cj0*x277)));
evalcond[9]=((((-1.0)*x277*x278))+(((-1.0)*cj0*x284))+new_r01);
evalcond[10]=(x277+(((-1.0)*new_r20*x279))+((cj1*x280))+((new_r10*x281)));
evalcond[11]=((((-1.0)*x276))+(((-1.0)*new_r21*x279))+((new_r11*x281))+((cj1*x282)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x286=IKPowWithIntegerCheck(sj1,-1);
if(!x286.valid){
continue;
}
IkReal x285=x286.value;
CheckValue<IkReal> x287=IKPowWithIntegerCheck(cj0,-1);
if(!x287.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*x285)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x285*(x287.value)*(((((-1.0)*cj1*new_r21*sj0))+(((-1.0)*new_r11*sj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*x285))+IKsqr((x285*(x287.value)*(((((-1.0)*cj1*new_r21*sj0))+(((-1.0)*new_r11*sj1))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r21*x285), (x285*(x287.value)*(((((-1.0)*cj1*new_r21*sj0))+(((-1.0)*new_r11*sj1))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[12];
IkReal x288=IKsin(j2);
IkReal x289=IKcos(j2);
IkReal x290=((1.0)*sj0);
IkReal x291=((1.0)*sj1);
IkReal x292=(cj0*new_r00);
IkReal x293=(cj1*sj0);
IkReal x294=(cj0*new_r01);
IkReal x295=(cj1*x289);
IkReal x296=(cj1*x288);
evalcond[0]=(new_r21+((sj1*x288)));
evalcond[1]=((((-1.0)*x289*x291))+new_r20);
evalcond[2]=(x288+((cj0*new_r10))+(((-1.0)*new_r00*x290)));
evalcond[3]=((((-1.0)*new_r01*x290))+x289+((cj0*new_r11)));
evalcond[4]=(((new_r10*sj0))+x292+x295);
evalcond[5]=(((x289*x293))+((cj0*x288))+new_r10);
evalcond[6]=((((-1.0)*x296))+((new_r11*sj0))+x294);
evalcond[7]=((((-1.0)*x288*x290))+new_r00+((cj0*x295)));
evalcond[8]=((((-1.0)*x290*x296))+((cj0*x289))+new_r11);
evalcond[9]=((((-1.0)*cj0*x296))+(((-1.0)*x289*x290))+new_r01);
evalcond[10]=((((-1.0)*new_r20*x291))+((cj1*x292))+((new_r10*x293))+x289);
evalcond[11]=((((-1.0)*new_r21*x291))+((new_r11*x293))+((cj1*x294))+(((-1.0)*x288)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x297 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),IkReal(new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x297.valid){
continue;
}
CheckValue<IkReal> x298=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x298.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x297.value)+(((1.5707963267949)*(x298.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[12];
IkReal x299=IKsin(j2);
IkReal x300=IKcos(j2);
IkReal x301=((1.0)*sj0);
IkReal x302=((1.0)*sj1);
IkReal x303=(cj0*new_r00);
IkReal x304=(cj1*sj0);
IkReal x305=(cj0*new_r01);
IkReal x306=(cj1*x300);
IkReal x307=(cj1*x299);
evalcond[0]=(((sj1*x299))+new_r21);
evalcond[1]=(new_r20+(((-1.0)*x300*x302)));
evalcond[2]=(x299+(((-1.0)*new_r00*x301))+((cj0*new_r10)));
evalcond[3]=(x300+(((-1.0)*new_r01*x301))+((cj0*new_r11)));
evalcond[4]=(((new_r10*sj0))+x306+x303);
evalcond[5]=(new_r10+((x300*x304))+((cj0*x299)));
evalcond[6]=(((new_r11*sj0))+(((-1.0)*x307))+x305);
evalcond[7]=(((cj0*x306))+(((-1.0)*x299*x301))+new_r00);
evalcond[8]=((((-1.0)*x301*x307))+((cj0*x300))+new_r11);
evalcond[9]=((((-1.0)*cj0*x307))+new_r01+(((-1.0)*x300*x301)));
evalcond[10]=(((cj1*x303))+((new_r10*x304))+(((-1.0)*new_r20*x302))+x300);
evalcond[11]=((((-1.0)*x299))+((cj1*x305))+((new_r11*x304))+(((-1.0)*new_r21*x302)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x308 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),IkReal(new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x308.valid){
continue;
}
CheckValue<IkReal> x309=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x309.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x308.value)+(((1.5707963267949)*(x309.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[2];
evalcond[0]=(((sj1*(IKsin(j2))))+new_r21);
evalcond[1]=((((-1.0)*sj1*(IKcos(j2))))+new_r20);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0eval[3];
j0eval[0]=sj1;
j0eval[1]=((IKabs(new_r12))+(IKabs(new_r02)));
j0eval[2]=IKsign(sj1);
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
j0eval[0]=new_r00;
j0eval[1]=sj1;
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r21;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[3];
sj1=0;
cj1=1.0;
j1=0;
IkReal x310=((1.0)*cj2);
IkReal x311=((new_r10*new_r10)+(new_r00*new_r00));
j0eval[0]=x311;
j0eval[1]=((IKabs((((new_r00*sj2))+(((-1.0)*new_r10*x310)))))+(IKabs(((((-1.0)*new_r00*x310))+(((-1.0)*new_r10*sj2))))));
j0eval[2]=IKsign(x311);
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
sj1=0;
cj1=1.0;
j1=0;
IkReal x312=((1.0)*cj2);
IkReal x313=(((new_r10*new_r11))+((new_r00*new_r01)));
j0eval[0]=x313;
j0eval[1]=((IKabs(((((-1.0)*new_r11*x312))+((cj2*new_r00)))))+(IKabs(((((-1.0)*new_r10*x312))+(((-1.0)*new_r01*x312))))));
j0eval[2]=IKsign(x313);
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
sj1=0;
cj1=1.0;
j1=0;
IkReal x314=((1.0)*new_r10);
IkReal x315=((((-1.0)*sj2*x314))+((cj2*new_r00)));
j0eval[0]=x315;
j0eval[1]=IKsign(x315);
j0eval[2]=((IKabs(((((-1.0)*new_r00*x314))+((cj2*sj2)))))+(IKabs(((((-1.0)*(cj2*cj2)))+(new_r10*new_r10)))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x318 = ((new_r10*new_r10)+(new_r00*new_r00));
if(IKabs(x318)==0){
continue;
}
IkReal x316=pow(x318,-0.5);
IkReal x317=((-1.0)*x316);
CheckValue<IkReal> x319 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x319.valid){
continue;
}
IkReal gconst0=((-1.0)*(x319.value));
IkReal gconst1=(new_r00*x317);
IkReal gconst2=(new_r10*x317);
CheckValue<IkReal> x320 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x320.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x320.value)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[2];
CheckValue<IkReal> x324 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x324.valid){
continue;
}
IkReal x321=((-1.0)*(x324.value));
IkReal x322=x316;
IkReal x323=((-1.0)*x322);
sj1=0;
cj1=1.0;
j1=0;
sj2=gconst1;
cj2=gconst2;
j2=x321;
IkReal gconst0=x321;
IkReal gconst1=(new_r00*x323);
IkReal gconst2=(new_r10*x323);
IkReal x325=((new_r10*new_r10)+(new_r00*new_r00));
j0eval[0]=x325;
j0eval[1]=IKsign(x325);
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
CheckValue<IkReal> x329 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x329.valid){
continue;
}
IkReal x326=((-1.0)*(x329.value));
IkReal x327=x316;
IkReal x328=((-1.0)*x327);
sj1=0;
cj1=1.0;
j1=0;
sj2=gconst1;
cj2=gconst2;
j2=x326;
IkReal gconst0=x326;
IkReal gconst1=(new_r00*x328);
IkReal gconst2=(new_r10*x328);
IkReal x330=new_r10*new_r10;
IkReal x331=(((new_r10*new_r11))+((new_r00*new_r01)));
IkReal x332=x316;
IkReal x333=(new_r10*x332);
j0eval[0]=x331;
j0eval[1]=IKsign(x331);
j0eval[2]=((IKabs((((new_r11*x333))+(((-1.0)*new_r00*x333)))))+(IKabs((((x330*x332))+((new_r01*x333))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
CheckValue<IkReal> x337 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x337.valid){
continue;
}
IkReal x334=((-1.0)*(x337.value));
IkReal x335=x316;
IkReal x336=((-1.0)*x335);
sj1=0;
cj1=1.0;
j1=0;
sj2=gconst1;
cj2=gconst2;
j2=x334;
IkReal gconst0=x334;
IkReal gconst1=(new_r00*x336);
IkReal gconst2=(new_r10*x336);
IkReal x338=new_r10*new_r10;
IkReal x339=new_r00*new_r00;
CheckValue<IkReal> x346=IKPowWithIntegerCheck((x339+x338),-1);
if(!x346.valid){
continue;
}
IkReal x340=x346.value;
IkReal x341=(x338*x340);
CheckValue<IkReal> x347=IKPowWithIntegerCheck(((((-1.0)*x339))+(((-1.0)*x338))),-1);
if(!x347.valid){
continue;
}
IkReal x342=x347.value;
IkReal x343=((1.0)*x342);
IkReal x344=(new_r00*x343);
IkReal x345=(new_r10*x343);
j0eval[0]=((IKabs(((((-1.0)*new_r10*x344))+(((-1.0)*new_r10*x344*(new_r00*new_r00)))+(((-1.0)*x344*(new_r10*new_r10*new_r10))))))+(IKabs((((x340*(x339*x339)))+((x339*x341))+(((-1.0)*x341))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x348 = IKatan2WithCheck(IkReal(((((-1.0)*(gconst2*gconst2)))+(new_r00*new_r00))),IkReal(((((-1.0)*gconst1*gconst2))+(((-1.0)*new_r00*new_r10)))),IKFAST_ATAN2_MAGTHRESH);
if(!x348.valid){
continue;
}
CheckValue<IkReal> x349=IKPowWithIntegerCheck(IKsign((((gconst2*new_r10))+((gconst1*new_r00)))),-1);
if(!x349.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x348.value)+(((1.5707963267949)*(x349.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x350=IKcos(j0);
IkReal x351=IKsin(j0);
IkReal x352=((1.0)*gconst1);
IkReal x353=(gconst2*x350);
IkReal x354=(gconst1*x350);
IkReal x355=(gconst2*x351);
IkReal x356=((1.0)*x351);
IkReal x357=(x351*x352);
evalcond[0]=(gconst2+((new_r10*x351))+((new_r00*x350)));
evalcond[1]=(x355+x354+new_r10);
evalcond[2]=(gconst1+(((-1.0)*new_r00*x356))+((new_r10*x350)));
evalcond[3]=(gconst2+(((-1.0)*new_r01*x356))+((new_r11*x350)));
evalcond[4]=((((-1.0)*x357))+x353+new_r00);
evalcond[5]=((((-1.0)*x357))+x353+new_r11);
evalcond[6]=(((new_r01*x350))+(((-1.0)*x352))+((new_r11*x351)));
evalcond[7]=((((-1.0)*x355))+new_r01+(((-1.0)*x350*x352)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x358=((1.0)*gconst2);
CheckValue<IkReal> x359 = IKatan2WithCheck(IkReal((((gconst2*new_r00))+(((-1.0)*new_r11*x358)))),IkReal(((((-1.0)*new_r01*x358))+(((-1.0)*new_r10*x358)))),IKFAST_ATAN2_MAGTHRESH);
if(!x359.valid){
continue;
}
CheckValue<IkReal> x360=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x360.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x359.value)+(((1.5707963267949)*(x360.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x361=IKcos(j0);
IkReal x362=IKsin(j0);
IkReal x363=((1.0)*gconst1);
IkReal x364=(gconst2*x361);
IkReal x365=(gconst1*x361);
IkReal x366=(gconst2*x362);
IkReal x367=((1.0)*x362);
IkReal x368=(x362*x363);
evalcond[0]=(gconst2+((new_r00*x361))+((new_r10*x362)));
evalcond[1]=(x365+x366+new_r10);
evalcond[2]=((((-1.0)*new_r00*x367))+gconst1+((new_r10*x361)));
evalcond[3]=(gconst2+(((-1.0)*new_r01*x367))+((new_r11*x361)));
evalcond[4]=((((-1.0)*x368))+x364+new_r00);
evalcond[5]=((((-1.0)*x368))+x364+new_r11);
evalcond[6]=((((-1.0)*x363))+((new_r01*x361))+((new_r11*x362)));
evalcond[7]=((((-1.0)*x366))+(((-1.0)*x361*x363))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x369=((1.0)*new_r10);
CheckValue<IkReal> x370=IKPowWithIntegerCheck(IKsign(((new_r10*new_r10)+(new_r00*new_r00))),-1);
if(!x370.valid){
continue;
}
CheckValue<IkReal> x371 = IKatan2WithCheck(IkReal((((gconst1*new_r00))+(((-1.0)*gconst2*x369)))),IkReal(((((-1.0)*gconst1*x369))+(((-1.0)*gconst2*new_r00)))),IKFAST_ATAN2_MAGTHRESH);
if(!x371.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x370.value)))+(x371.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x372=IKcos(j0);
IkReal x373=IKsin(j0);
IkReal x374=((1.0)*gconst1);
IkReal x375=(gconst2*x372);
IkReal x376=(gconst1*x372);
IkReal x377=(gconst2*x373);
IkReal x378=((1.0)*x373);
IkReal x379=(x373*x374);
evalcond[0]=(gconst2+((new_r00*x372))+((new_r10*x373)));
evalcond[1]=(x377+x376+new_r10);
evalcond[2]=((((-1.0)*new_r00*x378))+gconst1+((new_r10*x372)));
evalcond[3]=(gconst2+(((-1.0)*new_r01*x378))+((new_r11*x372)));
evalcond[4]=((((-1.0)*x379))+x375+new_r00);
evalcond[5]=((((-1.0)*x379))+x375+new_r11);
evalcond[6]=((((-1.0)*x374))+((new_r01*x372))+((new_r11*x373)));
evalcond[7]=((((-1.0)*x377))+(((-1.0)*x372*x374))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x382 = ((new_r10*new_r10)+(new_r00*new_r00));
if(IKabs(x382)==0){
continue;
}
IkReal x380=pow(x382,-0.5);
IkReal x381=((1.0)*x380);
CheckValue<IkReal> x383 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x383.valid){
continue;
}
IkReal gconst3=((3.14159265358979)+(((-1.0)*(x383.value))));
IkReal gconst4=(new_r00*x381);
IkReal gconst5=(new_r10*x381);
CheckValue<IkReal> x384 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x384.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x384.value)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[2];
CheckValue<IkReal> x388 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x388.valid){
continue;
}
IkReal x385=((1.0)*(x388.value));
IkReal x386=x380;
IkReal x387=((1.0)*x386);
sj1=0;
cj1=1.0;
j1=0;
sj2=gconst4;
cj2=gconst5;
j2=((3.14159265)+(((-1.0)*x385)));
IkReal gconst3=((3.14159265358979)+(((-1.0)*x385)));
IkReal gconst4=(new_r00*x387);
IkReal gconst5=(new_r10*x387);
IkReal x389=((new_r10*new_r10)+(new_r00*new_r00));
j0eval[0]=x389;
j0eval[1]=IKsign(x389);
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
CheckValue<IkReal> x393 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x393.valid){
continue;
}
IkReal x390=((1.0)*(x393.value));
IkReal x391=x380;
IkReal x392=((1.0)*x391);
sj1=0;
cj1=1.0;
j1=0;
sj2=gconst4;
cj2=gconst5;
j2=((3.14159265)+(((-1.0)*x390)));
IkReal gconst3=((3.14159265358979)+(((-1.0)*x390)));
IkReal gconst4=(new_r00*x392);
IkReal gconst5=(new_r10*x392);
IkReal x394=new_r10*new_r10;
IkReal x395=(new_r10*new_r11);
IkReal x396=(((new_r00*new_r01))+x395);
IkReal x397=x380;
IkReal x398=((1.0)*x397);
j0eval[0]=x396;
j0eval[1]=((IKabs(((((-1.0)*x395*x398))+((new_r00*new_r10*x397)))))+(IKabs(((((-1.0)*new_r01*new_r10*x398))+(((-1.0)*x394*x398))))));
j0eval[2]=IKsign(x396);
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
CheckValue<IkReal> x402 = IKatan2WithCheck(IkReal(new_r00),IkReal(((-1.0)*new_r10)),IKFAST_ATAN2_MAGTHRESH);
if(!x402.valid){
continue;
}
IkReal x399=((1.0)*(x402.value));
IkReal x400=x380;
IkReal x401=((1.0)*x400);
sj1=0;
cj1=1.0;
j1=0;
sj2=gconst4;
cj2=gconst5;
j2=((3.14159265)+(((-1.0)*x399)));
IkReal gconst3=((3.14159265358979)+(((-1.0)*x399)));
IkReal gconst4=(new_r00*x401);
IkReal gconst5=(new_r10*x401);
IkReal x403=new_r10*new_r10;
IkReal x404=new_r00*new_r00;
CheckValue<IkReal> x411=IKPowWithIntegerCheck((x403+x404),-1);
if(!x411.valid){
continue;
}
IkReal x405=x411.value;
IkReal x406=(x403*x405);
CheckValue<IkReal> x412=IKPowWithIntegerCheck(((((-1.0)*x404))+(((-1.0)*x403))),-1);
if(!x412.valid){
continue;
}
IkReal x407=x412.value;
IkReal x408=((1.0)*x407);
IkReal x409=(new_r00*x408);
IkReal x410=(new_r10*x408);
j0eval[0]=((IKabs((((x404*x406))+((x405*(x404*x404)))+(((-1.0)*x406)))))+(IKabs(((((-1.0)*x409*(new_r10*new_r10*new_r10)))+(((-1.0)*new_r10*x409*(new_r00*new_r00)))+(((-1.0)*new_r10*x409))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x413=IKPowWithIntegerCheck(IKsign((((gconst4*new_r00))+((gconst5*new_r10)))),-1);
if(!x413.valid){
continue;
}
CheckValue<IkReal> x414 = IKatan2WithCheck(IkReal(((((-1.0)*(gconst5*gconst5)))+(new_r00*new_r00))),IkReal(((((-1.0)*gconst4*gconst5))+(((-1.0)*new_r00*new_r10)))),IKFAST_ATAN2_MAGTHRESH);
if(!x414.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x413.value)))+(x414.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x415=IKcos(j0);
IkReal x416=IKsin(j0);
IkReal x417=((1.0)*gconst4);
IkReal x418=(gconst5*x415);
IkReal x419=((1.0)*x416);
IkReal x420=(x416*x417);
evalcond[0]=(gconst5+((new_r10*x416))+((new_r00*x415)));
evalcond[1]=(((gconst5*x416))+new_r10+((gconst4*x415)));
evalcond[2]=(gconst4+((new_r10*x415))+(((-1.0)*new_r00*x419)));
evalcond[3]=(gconst5+((new_r11*x415))+(((-1.0)*new_r01*x419)));
evalcond[4]=((((-1.0)*x420))+x418+new_r00);
evalcond[5]=((((-1.0)*x420))+x418+new_r11);
evalcond[6]=(((new_r11*x416))+(((-1.0)*x417))+((new_r01*x415)));
evalcond[7]=((((-1.0)*gconst5*x419))+(((-1.0)*x415*x417))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x421=((1.0)*gconst5);
CheckValue<IkReal> x422 = IKatan2WithCheck(IkReal((((gconst5*new_r00))+(((-1.0)*new_r11*x421)))),IkReal(((((-1.0)*new_r10*x421))+(((-1.0)*new_r01*x421)))),IKFAST_ATAN2_MAGTHRESH);
if(!x422.valid){
continue;
}
CheckValue<IkReal> x423=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x423.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x422.value)+(((1.5707963267949)*(x423.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x424=IKcos(j0);
IkReal x425=IKsin(j0);
IkReal x426=((1.0)*gconst4);
IkReal x427=(gconst5*x424);
IkReal x428=((1.0)*x425);
IkReal x429=(x425*x426);
evalcond[0]=(gconst5+((new_r10*x425))+((new_r00*x424)));
evalcond[1]=(((gconst4*x424))+((gconst5*x425))+new_r10);
evalcond[2]=((((-1.0)*new_r00*x428))+gconst4+((new_r10*x424)));
evalcond[3]=(gconst5+((new_r11*x424))+(((-1.0)*new_r01*x428)));
evalcond[4]=((((-1.0)*x429))+x427+new_r00);
evalcond[5]=((((-1.0)*x429))+x427+new_r11);
evalcond[6]=((((-1.0)*x426))+((new_r11*x425))+((new_r01*x424)));
evalcond[7]=((((-1.0)*x424*x426))+new_r01+(((-1.0)*gconst5*x428)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x430=((1.0)*new_r10);
CheckValue<IkReal> x431=IKPowWithIntegerCheck(IKsign(((new_r10*new_r10)+(new_r00*new_r00))),-1);
if(!x431.valid){
continue;
}
CheckValue<IkReal> x432 = IKatan2WithCheck(IkReal((((gconst4*new_r00))+(((-1.0)*gconst5*x430)))),IkReal(((((-1.0)*gconst4*x430))+(((-1.0)*gconst5*new_r00)))),IKFAST_ATAN2_MAGTHRESH);
if(!x432.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x431.value)))+(x432.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x433=IKcos(j0);
IkReal x434=IKsin(j0);
IkReal x435=((1.0)*gconst4);
IkReal x436=(gconst5*x433);
IkReal x437=((1.0)*x434);
IkReal x438=(x434*x435);
evalcond[0]=(((new_r00*x433))+gconst5+((new_r10*x434)));
evalcond[1]=(((gconst4*x433))+((gconst5*x434))+new_r10);
evalcond[2]=((((-1.0)*new_r00*x437))+gconst4+((new_r10*x433)));
evalcond[3]=((((-1.0)*new_r01*x437))+gconst5+((new_r11*x433)));
evalcond[4]=((((-1.0)*x438))+x436+new_r00);
evalcond[5]=((((-1.0)*x438))+x436+new_r11);
evalcond[6]=(((new_r01*x433))+(((-1.0)*x435))+((new_r11*x434)));
evalcond[7]=((((-1.0)*x433*x435))+(((-1.0)*gconst5*x437))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(new_r00, ((-1.0)*new_r10));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x439=IKcos(j0);
IkReal x440=IKsin(j0);
IkReal x441=((1.0)*x440);
evalcond[0]=(x439+new_r10);
evalcond[1]=((((-1.0)*x441))+new_r00);
evalcond[2]=((((-1.0)*x441))+new_r11);
evalcond[3]=((((-1.0)*x439))+new_r01);
evalcond[4]=(((new_r00*x439))+((new_r10*x440)));
evalcond[5]=((((-1.0)*new_r01*x441))+((new_r11*x439)));
evalcond[6]=((-1.0)+((new_r01*x439))+((new_r11*x440)));
evalcond[7]=((1.0)+(((-1.0)*new_r00*x441))+((new_r10*x439)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x442=IKsin(j0);
IkReal x443=IKcos(j0);
IkReal x444=((1.0)*x442);
evalcond[0]=(x442+new_r00);
evalcond[1]=(x442+new_r11);
evalcond[2]=(x443+new_r01);
evalcond[3]=((((-1.0)*x443))+new_r10);
evalcond[4]=(((new_r00*x443))+((new_r10*x442)));
evalcond[5]=((((-1.0)*new_r01*x444))+((new_r11*x443)));
evalcond[6]=((1.0)+((new_r01*x443))+((new_r11*x442)));
evalcond[7]=((-1.0)+(((-1.0)*new_r00*x444))+((new_r10*x443)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((new_r10*new_r10)+(new_r00*new_r00));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=1.0;
j1=0;
new_r10=0;
new_r00=0;
j0eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x446 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x446.valid){
continue;
}
IkReal x445=x446.value;
j0array[0]=((-1.0)*x445);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x445)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=(((new_r11*(IKcos(j0))))+(((-1.0)*new_r01*(IKsin(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=1.0;
j1=0;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
j0eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x448 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x448.valid){
continue;
}
IkReal x447=x448.value;
j0array[0]=((-1.0)*x447);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x447)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=(((new_r11*(IKcos(j0))))+(((-1.0)*new_r01*(IKsin(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x449=((1.0)*new_r10);
CheckValue<IkReal> x450=IKPowWithIntegerCheck(IKsign(((((-1.0)*sj2*x449))+((cj2*new_r00)))),-1);
if(!x450.valid){
continue;
}
CheckValue<IkReal> x451 = IKatan2WithCheck(IkReal((((cj2*sj2))+(((-1.0)*new_r00*x449)))),IkReal(((((-1.0)*(cj2*cj2)))+(new_r10*new_r10))),IKFAST_ATAN2_MAGTHRESH);
if(!x451.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x450.value)))+(x451.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x452=IKcos(j0);
IkReal x453=IKsin(j0);
IkReal x454=((1.0)*sj2);
IkReal x455=(cj2*x452);
IkReal x456=((1.0)*x453);
IkReal x457=(x453*x454);
evalcond[0]=(((new_r10*x453))+cj2+((new_r00*x452)));
evalcond[1]=(((sj2*x452))+((cj2*x453))+new_r10);
evalcond[2]=(((new_r10*x452))+sj2+(((-1.0)*new_r00*x456)));
evalcond[3]=(((new_r11*x452))+cj2+(((-1.0)*new_r01*x456)));
evalcond[4]=((((-1.0)*x457))+x455+new_r00);
evalcond[5]=((((-1.0)*x457))+x455+new_r11);
evalcond[6]=(((new_r11*x453))+((new_r01*x452))+(((-1.0)*x454)));
evalcond[7]=((((-1.0)*x452*x454))+new_r01+(((-1.0)*cj2*x456)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x458=((1.0)*cj2);
CheckValue<IkReal> x459 = IKatan2WithCheck(IkReal(((((-1.0)*new_r11*x458))+((cj2*new_r00)))),IkReal(((((-1.0)*new_r10*x458))+(((-1.0)*new_r01*x458)))),IKFAST_ATAN2_MAGTHRESH);
if(!x459.valid){
continue;
}
CheckValue<IkReal> x460=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x460.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x459.value)+(((1.5707963267949)*(x460.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x461=IKcos(j0);
IkReal x462=IKsin(j0);
IkReal x463=((1.0)*sj2);
IkReal x464=(cj2*x461);
IkReal x465=((1.0)*x462);
IkReal x466=(x462*x463);
evalcond[0]=(((new_r10*x462))+cj2+((new_r00*x461)));
evalcond[1]=(((cj2*x462))+new_r10+((sj2*x461)));
evalcond[2]=(sj2+((new_r10*x461))+(((-1.0)*new_r00*x465)));
evalcond[3]=(((new_r11*x461))+cj2+(((-1.0)*new_r01*x465)));
evalcond[4]=((((-1.0)*x466))+x464+new_r00);
evalcond[5]=((((-1.0)*x466))+x464+new_r11);
evalcond[6]=(((new_r11*x462))+((new_r01*x461))+(((-1.0)*x463)));
evalcond[7]=((((-1.0)*x461*x463))+new_r01+(((-1.0)*cj2*x465)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x467=((1.0)*cj2);
CheckValue<IkReal> x468=IKPowWithIntegerCheck(IKsign(((new_r10*new_r10)+(new_r00*new_r00))),-1);
if(!x468.valid){
continue;
}
CheckValue<IkReal> x469 = IKatan2WithCheck(IkReal(((((-1.0)*new_r10*x467))+((new_r00*sj2)))),IkReal(((((-1.0)*new_r00*x467))+(((-1.0)*new_r10*sj2)))),IKFAST_ATAN2_MAGTHRESH);
if(!x469.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x468.value)))+(x469.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x470=IKcos(j0);
IkReal x471=IKsin(j0);
IkReal x472=((1.0)*sj2);
IkReal x473=(cj2*x470);
IkReal x474=((1.0)*x471);
IkReal x475=(x471*x472);
evalcond[0]=(cj2+((new_r10*x471))+((new_r00*x470)));
evalcond[1]=(((cj2*x471))+new_r10+((sj2*x470)));
evalcond[2]=(sj2+((new_r10*x470))+(((-1.0)*new_r00*x474)));
evalcond[3]=(cj2+((new_r11*x470))+(((-1.0)*new_r01*x474)));
evalcond[4]=((((-1.0)*x475))+x473+new_r00);
evalcond[5]=((((-1.0)*x475))+x473+new_r11);
evalcond[6]=(((new_r01*x470))+((new_r11*x471))+(((-1.0)*x472)));
evalcond[7]=(new_r01+(((-1.0)*x470*x472))+(((-1.0)*cj2*x474)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r21;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[3];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
IkReal x476=((1.0)*sj2);
IkReal x477=(((new_r10*new_r11))+((new_r00*new_r01)));
j0eval[0]=x477;
j0eval[1]=((IKabs(((((-1.0)*new_r00*x476))+(((-1.0)*new_r11*x476)))))+(IKabs((((new_r01*sj2))+(((-1.0)*new_r10*x476))))));
j0eval[2]=IKsign(x477);
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
IkReal x478=((1.0)*new_r11);
IkReal x479=((new_r01*new_r01)+(new_r11*new_r11));
j0eval[0]=x479;
j0eval[1]=((IKabs(((((-1.0)*new_r01*sj2))+(((-1.0)*cj2*x478)))))+(IKabs(((((-1.0)*sj2*x478))+((cj2*new_r01))))));
j0eval[2]=IKsign(x479);
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
IkReal x480=(((new_r11*sj2))+((cj2*new_r01)));
j0eval[0]=x480;
j0eval[1]=IKsign(x480);
j0eval[2]=((IKabs(((((-1.0)*cj2*sj2))+(((-1.0)*new_r10*new_r11)))))+(IKabs(((-1.0)+(cj2*cj2)+((new_r01*new_r10))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x482 = ((new_r01*new_r01)+(new_r11*new_r11));
if(IKabs(x482)==0){
continue;
}
IkReal x481=pow(x482,-0.5);
CheckValue<IkReal> x483 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x483.valid){
continue;
}
IkReal gconst6=((-1.0)*(x483.value));
IkReal gconst7=((-1.0)*new_r01*x481);
IkReal gconst8=(new_r11*x481);
CheckValue<IkReal> x484 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x484.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x484.value)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[3];
CheckValue<IkReal> x487 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x487.valid){
continue;
}
IkReal x485=((-1.0)*(x487.value));
IkReal x486=x481;
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=gconst7;
cj2=gconst8;
j2=x485;
IkReal gconst6=x485;
IkReal gconst7=((-1.0)*new_r01*x486);
IkReal gconst8=(new_r11*x486);
IkReal x488=new_r01*new_r01;
IkReal x489=(new_r00*new_r01);
IkReal x490=(((new_r10*new_r11))+x489);
IkReal x491=x481;
IkReal x492=(new_r01*x491);
j0eval[0]=x490;
j0eval[1]=IKsign(x490);
j0eval[2]=((IKabs((((x489*x491))+((new_r11*x492)))))+(IKabs(((((-1.0)*x488*x491))+((new_r10*x492))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
CheckValue<IkReal> x495 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x495.valid){
continue;
}
IkReal x493=((-1.0)*(x495.value));
IkReal x494=x481;
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=gconst7;
cj2=gconst8;
j2=x493;
IkReal gconst6=x493;
IkReal gconst7=((-1.0)*new_r01*x494);
IkReal gconst8=(new_r11*x494);
IkReal x496=((new_r01*new_r01)+(new_r11*new_r11));
j0eval[0]=x496;
j0eval[1]=IKsign(x496);
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
CheckValue<IkReal> x499 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x499.valid){
continue;
}
IkReal x497=((-1.0)*(x499.value));
IkReal x498=x481;
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=gconst7;
cj2=gconst8;
j2=x497;
IkReal gconst6=x497;
IkReal gconst7=((-1.0)*new_r01*x498);
IkReal gconst8=(new_r11*x498);
IkReal x500=new_r01*new_r01;
IkReal x501=new_r11*new_r11;
IkReal x502=((1.0)*x500);
CheckValue<IkReal> x508=IKPowWithIntegerCheck((x500+x501),-1);
if(!x508.valid){
continue;
}
IkReal x503=x508.value;
CheckValue<IkReal> x509=IKPowWithIntegerCheck(((((-1.0)*x502))+(((-1.0)*x501))),-1);
if(!x509.valid){
continue;
}
IkReal x504=x509.value;
IkReal x505=((1.0)*x504);
IkReal x506=(new_r11*x505);
IkReal x507=(new_r01*x505);
j0eval[0]=((IKabs((((x500*x501*x503))+((x503*(x501*x501)))+(((-1.0)*x502*x503)))))+(IKabs(((((-1.0)*new_r01*x506))+(((-1.0)*x506*(new_r01*new_r01*new_r01)))+(((-1.0)*new_r01*x506*(new_r11*new_r11)))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[3];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
CheckValue<IkReal> x511 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x511.valid){
continue;
}
IkReal x510=((-1.0)*(x511.value));
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=gconst7;
cj2=gconst8;
j2=x510;
new_r11=0;
new_r00=0;
IkReal gconst6=x510;
IkReal x512 = new_r01*new_r01;
if(IKabs(x512)==0){
continue;
}
IkReal gconst7=((-1.0)*new_r01*(pow(x512,-0.5)));
IkReal gconst8=0;
j0eval[0]=new_r10;
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x513=IKPowWithIntegerCheck(gconst7,-1);
if(!x513.valid){
continue;
}
cj0array[0]=((-1.0)*new_r10*(x513.value));
if( cj0array[0] >= -1-IKFAST_SINCOS_THRESH && cj0array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j0valid[0] = j0valid[1] = true;
    j0array[0] = IKacos(cj0array[0]);
    sj0array[0] = IKsin(j0array[0]);
    cj0array[1] = cj0array[0];
    j0array[1] = -j0array[0];
    sj0array[1] = -sj0array[0];
}
else if( isnan(cj0array[0]) )
{
    // probably any value will work
    j0valid[0] = true;
    cj0array[0] = 1; sj0array[0] = 0; j0array[0] = 0;
}
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[6];
IkReal x514=IKsin(j0);
IkReal x515=IKcos(j0);
IkReal x516=((-1.0)*x514);
evalcond[0]=(new_r10*x514);
evalcond[1]=(new_r01*x516);
evalcond[2]=(gconst7*x516);
evalcond[3]=(((new_r10*x515))+gconst7);
evalcond[4]=(((new_r01*x515))+gconst7);
evalcond[5]=(((gconst7*x515))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x517=IKPowWithIntegerCheck(new_r10,-1);
if(!x517.valid){
continue;
}
cj0array[0]=((-1.0)*gconst7*(x517.value));
if( cj0array[0] >= -1-IKFAST_SINCOS_THRESH && cj0array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j0valid[0] = j0valid[1] = true;
    j0array[0] = IKacos(cj0array[0]);
    sj0array[0] = IKsin(j0array[0]);
    cj0array[1] = cj0array[0];
    j0array[1] = -j0array[0];
    sj0array[1] = -sj0array[0];
}
else if( isnan(cj0array[0]) )
{
    // probably any value will work
    j0valid[0] = true;
    cj0array[0] = 1; sj0array[0] = 0; j0array[0] = 0;
}
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[6];
IkReal x518=IKsin(j0);
IkReal x519=IKcos(j0);
IkReal x520=(gconst7*x519);
IkReal x521=((-1.0)*x518);
evalcond[0]=(new_r10*x518);
evalcond[1]=(new_r01*x521);
evalcond[2]=(gconst7*x521);
evalcond[3]=(x520+new_r10);
evalcond[4]=(((new_r01*x519))+gconst7);
evalcond[5]=(x520+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
evalcond[1]=gconst7;
evalcond[2]=gconst8;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[3];
CheckValue<IkReal> x523 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x523.valid){
continue;
}
IkReal x522=((-1.0)*(x523.value));
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=gconst7;
cj2=gconst8;
j2=x522;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst6=x522;
IkReal gconst7=((-1.0)*new_r01);
IkReal gconst8=new_r11;
j0eval[0]=-1.0;
j0eval[1]=((IKabs((new_r01*new_r11)))+(IKabs(((1.0)+(((-1.0)*(new_r01*new_r01)))))));
j0eval[2]=-1.0;
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
CheckValue<IkReal> x525 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x525.valid){
continue;
}
IkReal x524=((-1.0)*(x525.value));
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=gconst7;
cj2=gconst8;
j2=x524;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst6=x524;
IkReal gconst7=((-1.0)*new_r01);
IkReal gconst8=new_r11;
j0eval[0]=-1.0;
j0eval[1]=((IKabs((new_r01*new_r11)))+(IKabs(((1.0)+(((-1.0)*(new_r01*new_r01)))))));
j0eval[2]=-1.0;
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
CheckValue<IkReal> x527 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x527.valid){
continue;
}
IkReal x526=((-1.0)*(x527.value));
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=gconst7;
cj2=gconst8;
j2=x526;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst6=x526;
IkReal gconst7=((-1.0)*new_r01);
IkReal gconst8=new_r11;
j0eval[0]=1.0;
j0eval[1]=((((0.5)*(IKabs(((-1.0)+(((2.0)*(new_r01*new_r01))))))))+(IKabs((new_r01*new_r11))));
j0eval[2]=1.0;
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x528=((1.0)*new_r11);
CheckValue<IkReal> x529=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x529.valid){
continue;
}
CheckValue<IkReal> x530 = IKatan2WithCheck(IkReal((((gconst8*new_r01))+(((-1.0)*gconst7*x528)))),IkReal(((((-1.0)*gconst8*x528))+(((-1.0)*gconst7*new_r01)))),IKFAST_ATAN2_MAGTHRESH);
if(!x530.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x529.value)))+(x530.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[6];
IkReal x531=IKsin(j0);
IkReal x532=IKcos(j0);
IkReal x533=(gconst7*x532);
IkReal x534=((1.0)*x531);
IkReal x535=(gconst8*x532);
IkReal x536=(gconst8*x534);
evalcond[0]=((((-1.0)*x536))+x533);
evalcond[1]=(((new_r01*x532))+gconst7+((new_r11*x531)));
evalcond[2]=(((gconst7*x531))+x535+new_r11);
evalcond[3]=(gconst8+((new_r11*x532))+(((-1.0)*new_r01*x534)));
evalcond[4]=((((-1.0)*x535))+(((-1.0)*gconst7*x534)));
evalcond[5]=((((-1.0)*x536))+x533+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x537 = IKatan2WithCheck(IkReal((gconst7*new_r11)),IkReal((gconst8*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x537.valid){
continue;
}
CheckValue<IkReal> x538=IKPowWithIntegerCheck(IKsign(((((-1.0)*(gconst8*gconst8)))+(((-1.0)*(gconst7*gconst7))))),-1);
if(!x538.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x537.value)+(((1.5707963267949)*(x538.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[6];
IkReal x539=IKsin(j0);
IkReal x540=IKcos(j0);
IkReal x541=(gconst7*x540);
IkReal x542=((1.0)*x539);
IkReal x543=(gconst8*x540);
IkReal x544=(gconst8*x542);
evalcond[0]=((((-1.0)*x544))+x541);
evalcond[1]=(gconst7+((new_r11*x539))+((new_r01*x540)));
evalcond[2]=(((gconst7*x539))+x543+new_r11);
evalcond[3]=(gconst8+((new_r11*x540))+(((-1.0)*new_r01*x542)));
evalcond[4]=((((-1.0)*x543))+(((-1.0)*gconst7*x542)));
evalcond[5]=((((-1.0)*x544))+x541+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x545 = IKatan2WithCheck(IkReal((gconst7*gconst8)),IkReal(gconst8*gconst8),IKFAST_ATAN2_MAGTHRESH);
if(!x545.valid){
continue;
}
CheckValue<IkReal> x546=IKPowWithIntegerCheck(IKsign(((((-1.0)*gconst8*new_r11))+((gconst7*new_r01)))),-1);
if(!x546.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x545.value)+(((1.5707963267949)*(x546.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[6];
IkReal x547=IKsin(j0);
IkReal x548=IKcos(j0);
IkReal x549=(gconst7*x548);
IkReal x550=((1.0)*x547);
IkReal x551=(gconst8*x548);
IkReal x552=(gconst8*x550);
evalcond[0]=((((-1.0)*x552))+x549);
evalcond[1]=(gconst7+((new_r11*x547))+((new_r01*x548)));
evalcond[2]=(x551+((gconst7*x547))+new_r11);
evalcond[3]=(gconst8+(((-1.0)*new_r01*x550))+((new_r11*x548)));
evalcond[4]=((((-1.0)*x551))+(((-1.0)*gconst7*x550)));
evalcond[5]=((((-1.0)*x552))+x549+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x553=IKPowWithIntegerCheck(gconst8,-1);
if(!x553.valid){
continue;
}
cj0array[0]=(new_r00*(x553.value));
if( cj0array[0] >= -1-IKFAST_SINCOS_THRESH && cj0array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j0valid[0] = j0valid[1] = true;
    j0array[0] = IKacos(cj0array[0]);
    sj0array[0] = IKsin(j0array[0]);
    cj0array[1] = cj0array[0];
    j0array[1] = -j0array[0];
    sj0array[1] = -sj0array[0];
}
else if( isnan(cj0array[0]) )
{
    // probably any value will work
    j0valid[0] = true;
    cj0array[0] = 1; sj0array[0] = 0; j0array[0] = 0;
}
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[6];
IkReal x554=IKsin(j0);
IkReal x555=IKcos(j0);
IkReal x556=((-1.0)*x554);
evalcond[0]=(new_r11*x554);
evalcond[1]=(new_r00*x556);
evalcond[2]=(gconst8*x556);
evalcond[3]=(((new_r11*x555))+gconst8);
evalcond[4]=(((gconst8*x555))+new_r11);
evalcond[5]=((((-1.0)*gconst8))+((new_r00*x555)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r00))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
CheckValue<IkReal> x558 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x558.valid){
continue;
}
IkReal x557=((-1.0)*(x558.value));
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=gconst7;
cj2=gconst8;
j2=x557;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst6=x557;
IkReal gconst7=0;
IkReal x559 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x559)==0){
continue;
}
IkReal gconst8=(new_r11*(pow(x559,-0.5)));
j0eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
CheckValue<IkReal> x561 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x561.valid){
continue;
}
IkReal x560=((-1.0)*(x561.value));
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=gconst7;
cj2=gconst8;
j2=x560;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst6=x560;
IkReal gconst7=0;
IkReal x562 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x562)==0){
continue;
}
IkReal gconst8=(new_r11*(pow(x562,-0.5)));
j0eval[0]=new_r11;
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
CheckValue<IkReal> x564 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x564.valid){
continue;
}
IkReal x563=((-1.0)*(x564.value));
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=gconst7;
cj2=gconst8;
j2=x563;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst6=x563;
IkReal gconst7=0;
IkReal x565 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x565)==0){
continue;
}
IkReal gconst8=(new_r11*(pow(x565,-0.5)));
j0eval[0]=new_r10;
j0eval[1]=new_r11;
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x566=IKPowWithIntegerCheck(new_r10,-1);
if(!x566.valid){
continue;
}
CheckValue<IkReal> x567=IKPowWithIntegerCheck(new_r11,-1);
if(!x567.valid){
continue;
}
if( IKabs((gconst8*(x566.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst8*(x567.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((gconst8*(x566.value)))+IKsqr(((-1.0)*gconst8*(x567.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2((gconst8*(x566.value)), ((-1.0)*gconst8*(x567.value)));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x568=IKcos(j0);
IkReal x569=IKsin(j0);
IkReal x570=(gconst8*x569);
IkReal x571=(gconst8*x568);
evalcond[0]=(new_r10*x568);
evalcond[1]=(new_r11*x569);
evalcond[2]=((-1.0)*x571);
evalcond[3]=((-1.0)*x570);
evalcond[4]=(gconst8+((new_r11*x568)));
evalcond[5]=(x571+new_r11);
evalcond[6]=((((-1.0)*x570))+new_r10);
evalcond[7]=((((-1.0)*gconst8))+((new_r10*x569)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x572=IKPowWithIntegerCheck(gconst8,-1);
if(!x572.valid){
continue;
}
CheckValue<IkReal> x573=IKPowWithIntegerCheck(new_r11,-1);
if(!x573.valid){
continue;
}
if( IKabs((new_r10*(x572.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst8*(x573.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x572.value)))+IKsqr(((-1.0)*gconst8*(x573.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2((new_r10*(x572.value)), ((-1.0)*gconst8*(x573.value)));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x574=IKcos(j0);
IkReal x575=IKsin(j0);
IkReal x576=(gconst8*x575);
IkReal x577=(gconst8*x574);
evalcond[0]=(new_r10*x574);
evalcond[1]=(new_r11*x575);
evalcond[2]=((-1.0)*x577);
evalcond[3]=((-1.0)*x576);
evalcond[4]=(((new_r11*x574))+gconst8);
evalcond[5]=(x577+new_r11);
evalcond[6]=((((-1.0)*x576))+new_r10);
evalcond[7]=(((new_r10*x575))+(((-1.0)*gconst8)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x578 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x578.valid){
continue;
}
CheckValue<IkReal> x579=IKPowWithIntegerCheck(IKsign(gconst8),-1);
if(!x579.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x578.value)+(((1.5707963267949)*(x579.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x580=IKcos(j0);
IkReal x581=IKsin(j0);
IkReal x582=(gconst8*x581);
IkReal x583=(gconst8*x580);
evalcond[0]=(new_r10*x580);
evalcond[1]=(new_r11*x581);
evalcond[2]=((-1.0)*x583);
evalcond[3]=((-1.0)*x582);
evalcond[4]=(gconst8+((new_r11*x580)));
evalcond[5]=(x583+new_r11);
evalcond[6]=((((-1.0)*x582))+new_r10);
evalcond[7]=((((-1.0)*gconst8))+((new_r10*x581)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(new_r01);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
CheckValue<IkReal> x585 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x585.valid){
continue;
}
IkReal x584=((-1.0)*(x585.value));
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=gconst7;
cj2=gconst8;
j2=x584;
new_r01=0;
IkReal gconst6=x584;
IkReal gconst7=0;
IkReal x586 = new_r11*new_r11;
if(IKabs(x586)==0){
continue;
}
IkReal gconst8=(new_r11*(pow(x586,-0.5)));
j0eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
CheckValue<IkReal> x588 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x588.valid){
continue;
}
IkReal x587=((-1.0)*(x588.value));
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=gconst7;
cj2=gconst8;
j2=x587;
new_r01=0;
IkReal gconst6=x587;
IkReal gconst7=0;
IkReal x589 = new_r11*new_r11;
if(IKabs(x589)==0){
continue;
}
IkReal gconst8=(new_r11*(pow(x589,-0.5)));
j0eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
CheckValue<IkReal> x591 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x591.valid){
continue;
}
IkReal x590=((-1.0)*(x591.value));
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=gconst7;
cj2=gconst8;
j2=x590;
new_r01=0;
IkReal gconst6=x590;
IkReal gconst7=0;
IkReal x592 = new_r11*new_r11;
if(IKabs(x592)==0){
continue;
}
IkReal gconst8=(new_r11*(pow(x592,-0.5)));
j0eval[0]=new_r11;
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x593=IKPowWithIntegerCheck(gconst8,-1);
if(!x593.valid){
continue;
}
CheckValue<IkReal> x594=IKPowWithIntegerCheck(new_r11,-1);
if(!x594.valid){
continue;
}
if( IKabs((new_r10*(x593.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst8*(x594.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x593.value)))+IKsqr(((-1.0)*gconst8*(x594.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2((new_r10*(x593.value)), ((-1.0)*gconst8*(x594.value)));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x595=IKsin(j0);
IkReal x596=IKcos(j0);
IkReal x597=((1.0)*gconst8);
IkReal x598=((1.0)*x595);
evalcond[0]=(new_r11*x595);
evalcond[1]=((-1.0)*gconst8*x595);
evalcond[2]=(((new_r11*x596))+gconst8);
evalcond[3]=(((gconst8*x596))+new_r11);
evalcond[4]=((((-1.0)*x595*x597))+new_r10);
evalcond[5]=((((-1.0)*x596*x597))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x598))+((new_r10*x596)));
evalcond[7]=(((new_r10*x595))+((new_r00*x596))+(((-1.0)*x597)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x599 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x599.valid){
continue;
}
CheckValue<IkReal> x600=IKPowWithIntegerCheck(IKsign(gconst8),-1);
if(!x600.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x599.value)+(((1.5707963267949)*(x600.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x601=IKsin(j0);
IkReal x602=IKcos(j0);
IkReal x603=((1.0)*gconst8);
IkReal x604=((1.0)*x601);
evalcond[0]=(new_r11*x601);
evalcond[1]=((-1.0)*gconst8*x601);
evalcond[2]=(gconst8+((new_r11*x602)));
evalcond[3]=(((gconst8*x602))+new_r11);
evalcond[4]=(new_r10+(((-1.0)*x601*x603)));
evalcond[5]=((((-1.0)*x602*x603))+new_r00);
evalcond[6]=(((new_r10*x602))+(((-1.0)*new_r00*x604)));
evalcond[7]=(((new_r10*x601))+((new_r00*x602))+(((-1.0)*x603)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x605=IKPowWithIntegerCheck(IKsign(gconst8),-1);
if(!x605.valid){
continue;
}
CheckValue<IkReal> x606 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r00),IKFAST_ATAN2_MAGTHRESH);
if(!x606.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x605.value)))+(x606.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x607=IKsin(j0);
IkReal x608=IKcos(j0);
IkReal x609=((1.0)*gconst8);
IkReal x610=((1.0)*x607);
evalcond[0]=(new_r11*x607);
evalcond[1]=((-1.0)*gconst8*x607);
evalcond[2]=(gconst8+((new_r11*x608)));
evalcond[3]=(((gconst8*x608))+new_r11);
evalcond[4]=(new_r10+(((-1.0)*x607*x609)));
evalcond[5]=((((-1.0)*x608*x609))+new_r00);
evalcond[6]=(((new_r10*x608))+(((-1.0)*new_r00*x610)));
evalcond[7]=(((new_r10*x607))+((new_r00*x608))+(((-1.0)*x609)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x611=((1.0)*new_r11);
CheckValue<IkReal> x612 = IKatan2WithCheck(IkReal((((gconst7*gconst8))+(((-1.0)*new_r01*x611)))),IkReal(((((-1.0)*(gconst7*gconst7)))+(new_r11*new_r11))),IKFAST_ATAN2_MAGTHRESH);
if(!x612.valid){
continue;
}
CheckValue<IkReal> x613=IKPowWithIntegerCheck(IKsign(((((-1.0)*gconst8*x611))+((gconst7*new_r01)))),-1);
if(!x613.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x612.value)+(((1.5707963267949)*(x613.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x614=IKcos(j0);
IkReal x615=IKsin(j0);
IkReal x616=(gconst7*x614);
IkReal x617=((1.0)*x615);
IkReal x618=(gconst8*x614);
IkReal x619=(gconst8*x617);
evalcond[0]=(gconst7+((new_r11*x615))+((new_r01*x614)));
evalcond[1]=(((gconst7*x615))+x618+new_r11);
evalcond[2]=(gconst7+((new_r10*x614))+(((-1.0)*new_r00*x617)));
evalcond[3]=(gconst8+((new_r11*x614))+(((-1.0)*new_r01*x617)));
evalcond[4]=((((-1.0)*x619))+x616+new_r10);
evalcond[5]=((((-1.0)*x619))+x616+new_r01);
evalcond[6]=((((-1.0)*gconst8))+((new_r10*x615))+((new_r00*x614)));
evalcond[7]=((((-1.0)*x618))+new_r00+(((-1.0)*gconst7*x617)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x620=((1.0)*new_r11);
CheckValue<IkReal> x621=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x621.valid){
continue;
}
CheckValue<IkReal> x622 = IKatan2WithCheck(IkReal((((gconst8*new_r01))+(((-1.0)*gconst7*x620)))),IkReal(((((-1.0)*gconst7*new_r01))+(((-1.0)*gconst8*x620)))),IKFAST_ATAN2_MAGTHRESH);
if(!x622.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x621.value)))+(x622.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x623=IKcos(j0);
IkReal x624=IKsin(j0);
IkReal x625=(gconst7*x623);
IkReal x626=((1.0)*x624);
IkReal x627=(gconst8*x623);
IkReal x628=(gconst8*x626);
evalcond[0]=(gconst7+((new_r01*x623))+((new_r11*x624)));
evalcond[1]=(x627+new_r11+((gconst7*x624)));
evalcond[2]=((((-1.0)*new_r00*x626))+gconst7+((new_r10*x623)));
evalcond[3]=((((-1.0)*new_r01*x626))+gconst8+((new_r11*x623)));
evalcond[4]=((((-1.0)*x628))+x625+new_r10);
evalcond[5]=((((-1.0)*x628))+x625+new_r01);
evalcond[6]=((((-1.0)*gconst8))+((new_r00*x623))+((new_r10*x624)));
evalcond[7]=((((-1.0)*gconst7*x626))+(((-1.0)*x627))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x629=((1.0)*gconst7);
CheckValue<IkReal> x630 = IKatan2WithCheck(IkReal(((((-1.0)*new_r10*x629))+((gconst7*new_r01)))),IkReal(((((-1.0)*new_r00*x629))+(((-1.0)*new_r11*x629)))),IKFAST_ATAN2_MAGTHRESH);
if(!x630.valid){
continue;
}
CheckValue<IkReal> x631=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x631.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x630.value)+(((1.5707963267949)*(x631.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x632=IKcos(j0);
IkReal x633=IKsin(j0);
IkReal x634=(gconst7*x632);
IkReal x635=((1.0)*x633);
IkReal x636=(gconst8*x632);
IkReal x637=(gconst8*x635);
evalcond[0]=(gconst7+((new_r01*x632))+((new_r11*x633)));
evalcond[1]=(x636+new_r11+((gconst7*x633)));
evalcond[2]=((((-1.0)*new_r00*x635))+gconst7+((new_r10*x632)));
evalcond[3]=((((-1.0)*new_r01*x635))+gconst8+((new_r11*x632)));
evalcond[4]=((((-1.0)*x637))+x634+new_r10);
evalcond[5]=((((-1.0)*x637))+x634+new_r01);
evalcond[6]=((((-1.0)*gconst8))+((new_r00*x632))+((new_r10*x633)));
evalcond[7]=((((-1.0)*gconst7*x635))+(((-1.0)*x636))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x639 = ((new_r01*new_r01)+(new_r11*new_r11));
if(IKabs(x639)==0){
continue;
}
IkReal x638=pow(x639,-0.5);
CheckValue<IkReal> x640 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x640.valid){
continue;
}
IkReal gconst9=((3.14159265358979)+(((-1.0)*(x640.value))));
IkReal gconst10=((1.0)*new_r01*x638);
IkReal gconst11=((-1.0)*new_r11*x638);
CheckValue<IkReal> x641 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x641.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x641.value)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[3];
CheckValue<IkReal> x644 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x644.valid){
continue;
}
IkReal x642=((1.0)*(x644.value));
IkReal x643=x638;
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=gconst10;
cj2=gconst11;
j2=((3.14159265)+(((-1.0)*x642)));
IkReal gconst9=((3.14159265358979)+(((-1.0)*x642)));
IkReal gconst10=((1.0)*new_r01*x643);
IkReal gconst11=((-1.0)*new_r11*x643);
IkReal x645=new_r01*new_r01;
IkReal x646=(((new_r10*new_r11))+((new_r00*new_r01)));
IkReal x647=x638;
IkReal x648=((1.0)*new_r01*x647);
j0eval[0]=x646;
j0eval[1]=((IKabs(((((-1.0)*new_r11*x648))+(((-1.0)*new_r00*x648)))))+(IKabs(((((-1.0)*new_r10*x648))+((x645*x647))))));
j0eval[2]=IKsign(x646);
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
CheckValue<IkReal> x651 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x651.valid){
continue;
}
IkReal x649=((1.0)*(x651.value));
IkReal x650=x638;
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=gconst10;
cj2=gconst11;
j2=((3.14159265)+(((-1.0)*x649)));
IkReal gconst9=((3.14159265358979)+(((-1.0)*x649)));
IkReal gconst10=((1.0)*new_r01*x650);
IkReal gconst11=((-1.0)*new_r11*x650);
IkReal x652=((new_r01*new_r01)+(new_r11*new_r11));
j0eval[0]=x652;
j0eval[1]=IKsign(x652);
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
CheckValue<IkReal> x655 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x655.valid){
continue;
}
IkReal x653=((1.0)*(x655.value));
IkReal x654=x638;
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=gconst10;
cj2=gconst11;
j2=((3.14159265)+(((-1.0)*x653)));
IkReal gconst9=((3.14159265358979)+(((-1.0)*x653)));
IkReal gconst10=((1.0)*new_r01*x654);
IkReal gconst11=((-1.0)*new_r11*x654);
IkReal x656=new_r01*new_r01;
IkReal x657=new_r11*new_r11;
IkReal x658=((1.0)*x656);
CheckValue<IkReal> x664=IKPowWithIntegerCheck((x656+x657),-1);
if(!x664.valid){
continue;
}
IkReal x659=x664.value;
CheckValue<IkReal> x665=IKPowWithIntegerCheck(((((-1.0)*x657))+(((-1.0)*x658))),-1);
if(!x665.valid){
continue;
}
IkReal x660=x665.value;
IkReal x661=((1.0)*x660);
IkReal x662=(new_r11*x661);
IkReal x663=(new_r01*x661);
j0eval[0]=((IKabs(((((-1.0)*new_r01*x662*(new_r11*new_r11)))+(((-1.0)*x662*(new_r01*new_r01*new_r01)))+(((-1.0)*new_r01*x662)))))+(IKabs((((x659*(x657*x657)))+((x656*x657*x659))+(((-1.0)*x658*x659))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[3];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
CheckValue<IkReal> x667 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x667.valid){
continue;
}
IkReal x666=((1.0)*(x667.value));
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=gconst10;
cj2=gconst11;
j2=((3.14159265)+(((-1.0)*x666)));
new_r11=0;
new_r00=0;
IkReal gconst9=((3.14159265358979)+(((-1.0)*x666)));
IkReal x668 = new_r01*new_r01;
if(IKabs(x668)==0){
continue;
}
IkReal gconst10=((1.0)*new_r01*(pow(x668,-0.5)));
IkReal gconst11=0;
j0eval[0]=new_r10;
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x669=IKPowWithIntegerCheck(gconst10,-1);
if(!x669.valid){
continue;
}
cj0array[0]=((-1.0)*new_r10*(x669.value));
if( cj0array[0] >= -1-IKFAST_SINCOS_THRESH && cj0array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j0valid[0] = j0valid[1] = true;
    j0array[0] = IKacos(cj0array[0]);
    sj0array[0] = IKsin(j0array[0]);
    cj0array[1] = cj0array[0];
    j0array[1] = -j0array[0];
    sj0array[1] = -sj0array[0];
}
else if( isnan(cj0array[0]) )
{
    // probably any value will work
    j0valid[0] = true;
    cj0array[0] = 1; sj0array[0] = 0; j0array[0] = 0;
}
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[6];
IkReal x670=IKsin(j0);
IkReal x671=IKcos(j0);
IkReal x672=((-1.0)*x670);
evalcond[0]=(new_r10*x670);
evalcond[1]=(new_r01*x672);
evalcond[2]=(gconst10*x672);
evalcond[3]=(((new_r10*x671))+gconst10);
evalcond[4]=(((new_r01*x671))+gconst10);
evalcond[5]=(((gconst10*x671))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x673=IKPowWithIntegerCheck(new_r10,-1);
if(!x673.valid){
continue;
}
cj0array[0]=((-1.0)*gconst10*(x673.value));
if( cj0array[0] >= -1-IKFAST_SINCOS_THRESH && cj0array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j0valid[0] = j0valid[1] = true;
    j0array[0] = IKacos(cj0array[0]);
    sj0array[0] = IKsin(j0array[0]);
    cj0array[1] = cj0array[0];
    j0array[1] = -j0array[0];
    sj0array[1] = -sj0array[0];
}
else if( isnan(cj0array[0]) )
{
    // probably any value will work
    j0valid[0] = true;
    cj0array[0] = 1; sj0array[0] = 0; j0array[0] = 0;
}
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[6];
IkReal x674=IKsin(j0);
IkReal x675=IKcos(j0);
IkReal x676=(gconst10*x675);
IkReal x677=((-1.0)*x674);
evalcond[0]=(new_r10*x674);
evalcond[1]=(new_r01*x677);
evalcond[2]=(gconst10*x677);
evalcond[3]=(x676+new_r10);
evalcond[4]=(((new_r01*x675))+gconst10);
evalcond[5]=(x676+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
evalcond[1]=gconst10;
evalcond[2]=gconst11;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[3];
CheckValue<IkReal> x679 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x679.valid){
continue;
}
IkReal x678=((1.0)*(x679.value));
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=gconst10;
cj2=gconst11;
j2=((3.14159265)+(((-1.0)*x678)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst9=((3.14159265358979)+(((-1.0)*x678)));
IkReal gconst10=((1.0)*new_r01);
IkReal gconst11=((-1.0)*new_r11);
j0eval[0]=1.0;
j0eval[1]=1.0;
j0eval[2]=((IKabs(((1.0)+(((-1.0)*(new_r01*new_r01))))))+(IKabs(((1.0)*new_r01*new_r11))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
CheckValue<IkReal> x681 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x681.valid){
continue;
}
IkReal x680=((1.0)*(x681.value));
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=gconst10;
cj2=gconst11;
j2=((3.14159265)+(((-1.0)*x680)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst9=((3.14159265358979)+(((-1.0)*x680)));
IkReal gconst10=((1.0)*new_r01);
IkReal gconst11=((-1.0)*new_r11);
j0eval[0]=-1.0;
j0eval[1]=-1.0;
j0eval[2]=((IKabs(((-1.0)+(new_r01*new_r01))))+(IKabs(((1.0)*new_r01*new_r11))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
CheckValue<IkReal> x683 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x683.valid){
continue;
}
IkReal x682=((1.0)*(x683.value));
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=gconst10;
cj2=gconst11;
j2=((3.14159265)+(((-1.0)*x682)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst9=((3.14159265358979)+(((-1.0)*x682)));
IkReal gconst10=((1.0)*new_r01);
IkReal gconst11=((-1.0)*new_r11);
j0eval[0]=1.0;
j0eval[1]=1.0;
j0eval[2]=((IKabs(((2.0)*new_r01*new_r11)))+(IKabs(((1.0)+(((-2.0)*(new_r01*new_r01)))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x684=((1.0)*new_r11);
CheckValue<IkReal> x685 = IKatan2WithCheck(IkReal((((gconst11*new_r01))+(((-1.0)*gconst10*x684)))),IkReal(((((-1.0)*gconst11*x684))+(((-1.0)*gconst10*new_r01)))),IKFAST_ATAN2_MAGTHRESH);
if(!x685.valid){
continue;
}
CheckValue<IkReal> x686=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x686.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x685.value)+(((1.5707963267949)*(x686.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[6];
IkReal x687=IKsin(j0);
IkReal x688=IKcos(j0);
IkReal x689=(gconst10*x688);
IkReal x690=(gconst11*x688);
IkReal x691=(gconst10*x687);
IkReal x692=((1.0)*x687);
IkReal x693=(gconst11*x692);
evalcond[0]=(x689+(((-1.0)*x693)));
evalcond[1]=(gconst10+((new_r01*x688))+((new_r11*x687)));
evalcond[2]=(x690+x691+new_r11);
evalcond[3]=((((-1.0)*new_r01*x692))+gconst11+((new_r11*x688)));
evalcond[4]=((((-1.0)*x690))+(((-1.0)*x691)));
evalcond[5]=(x689+(((-1.0)*x693))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x694=IKPowWithIntegerCheck(IKsign(((((-1.0)*(gconst11*gconst11)))+(((-1.0)*(gconst10*gconst10))))),-1);
if(!x694.valid){
continue;
}
CheckValue<IkReal> x695 = IKatan2WithCheck(IkReal((gconst10*new_r11)),IkReal((gconst11*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x695.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x694.value)))+(x695.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[6];
IkReal x696=IKsin(j0);
IkReal x697=IKcos(j0);
IkReal x698=(gconst10*x697);
IkReal x699=(gconst11*x697);
IkReal x700=(gconst10*x696);
IkReal x701=((1.0)*x696);
IkReal x702=(gconst11*x701);
evalcond[0]=((((-1.0)*x702))+x698);
evalcond[1]=(gconst10+((new_r11*x696))+((new_r01*x697)));
evalcond[2]=(x699+x700+new_r11);
evalcond[3]=(gconst11+((new_r11*x697))+(((-1.0)*new_r01*x701)));
evalcond[4]=((((-1.0)*x700))+(((-1.0)*x699)));
evalcond[5]=((((-1.0)*x702))+x698+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x703=IKPowWithIntegerCheck(IKsign((((gconst10*new_r01))+(((-1.0)*gconst11*new_r11)))),-1);
if(!x703.valid){
continue;
}
CheckValue<IkReal> x704 = IKatan2WithCheck(IkReal((gconst10*gconst11)),IkReal(gconst11*gconst11),IKFAST_ATAN2_MAGTHRESH);
if(!x704.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x703.value)))+(x704.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[6];
IkReal x705=IKsin(j0);
IkReal x706=IKcos(j0);
IkReal x707=(gconst10*x706);
IkReal x708=(gconst11*x706);
IkReal x709=(gconst10*x705);
IkReal x710=((1.0)*x705);
IkReal x711=(gconst11*x710);
evalcond[0]=((((-1.0)*x711))+x707);
evalcond[1]=(((new_r01*x706))+gconst10+((new_r11*x705)));
evalcond[2]=(x708+x709+new_r11);
evalcond[3]=(gconst11+((new_r11*x706))+(((-1.0)*new_r01*x710)));
evalcond[4]=((((-1.0)*x709))+(((-1.0)*x708)));
evalcond[5]=((((-1.0)*x711))+x707+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x712=IKPowWithIntegerCheck(gconst11,-1);
if(!x712.valid){
continue;
}
cj0array[0]=(new_r00*(x712.value));
if( cj0array[0] >= -1-IKFAST_SINCOS_THRESH && cj0array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j0valid[0] = j0valid[1] = true;
    j0array[0] = IKacos(cj0array[0]);
    sj0array[0] = IKsin(j0array[0]);
    cj0array[1] = cj0array[0];
    j0array[1] = -j0array[0];
    sj0array[1] = -sj0array[0];
}
else if( isnan(cj0array[0]) )
{
    // probably any value will work
    j0valid[0] = true;
    cj0array[0] = 1; sj0array[0] = 0; j0array[0] = 0;
}
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[6];
IkReal x713=IKsin(j0);
IkReal x714=IKcos(j0);
IkReal x715=((-1.0)*x713);
evalcond[0]=(new_r11*x713);
evalcond[1]=(new_r00*x715);
evalcond[2]=(gconst11*x715);
evalcond[3]=(gconst11+((new_r11*x714)));
evalcond[4]=(new_r11+((gconst11*x714)));
evalcond[5]=(((new_r00*x714))+(((-1.0)*gconst11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r00))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
CheckValue<IkReal> x717 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x717.valid){
continue;
}
IkReal x716=((1.0)*(x717.value));
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=gconst10;
cj2=gconst11;
j2=((3.14159265)+(((-1.0)*x716)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst9=((3.14159265358979)+(((-1.0)*x716)));
IkReal gconst10=0;
IkReal x718 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x718)==0){
continue;
}
IkReal gconst11=((-1.0)*new_r11*(pow(x718,-0.5)));
j0eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
CheckValue<IkReal> x720 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x720.valid){
continue;
}
IkReal x719=((1.0)*(x720.value));
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=gconst10;
cj2=gconst11;
j2=((3.14159265)+(((-1.0)*x719)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst9=((3.14159265358979)+(((-1.0)*x719)));
IkReal gconst10=0;
IkReal x721 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x721)==0){
continue;
}
IkReal gconst11=((-1.0)*new_r11*(pow(x721,-0.5)));
j0eval[0]=new_r11;
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
CheckValue<IkReal> x723 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x723.valid){
continue;
}
IkReal x722=((1.0)*(x723.value));
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=gconst10;
cj2=gconst11;
j2=((3.14159265)+(((-1.0)*x722)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst9=((3.14159265358979)+(((-1.0)*x722)));
IkReal gconst10=0;
IkReal x724 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x724)==0){
continue;
}
IkReal gconst11=((-1.0)*new_r11*(pow(x724,-0.5)));
j0eval[0]=new_r10;
j0eval[1]=new_r11;
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x725=IKPowWithIntegerCheck(new_r10,-1);
if(!x725.valid){
continue;
}
CheckValue<IkReal> x726=IKPowWithIntegerCheck(new_r11,-1);
if(!x726.valid){
continue;
}
if( IKabs((gconst11*(x725.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst11*(x726.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((gconst11*(x725.value)))+IKsqr(((-1.0)*gconst11*(x726.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2((gconst11*(x725.value)), ((-1.0)*gconst11*(x726.value)));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x727=IKcos(j0);
IkReal x728=IKsin(j0);
IkReal x729=((1.0)*gconst11);
IkReal x730=((-1.0)*gconst11);
evalcond[0]=(new_r10*x727);
evalcond[1]=(new_r11*x728);
evalcond[2]=(x727*x730);
evalcond[3]=(x728*x730);
evalcond[4]=(gconst11+((new_r11*x727)));
evalcond[5]=(((gconst11*x727))+new_r11);
evalcond[6]=(new_r10+(((-1.0)*x728*x729)));
evalcond[7]=((((-1.0)*x729))+((new_r10*x728)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x731=IKPowWithIntegerCheck(gconst11,-1);
if(!x731.valid){
continue;
}
CheckValue<IkReal> x732=IKPowWithIntegerCheck(new_r11,-1);
if(!x732.valid){
continue;
}
if( IKabs((new_r10*(x731.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst11*(x732.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x731.value)))+IKsqr(((-1.0)*gconst11*(x732.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2((new_r10*(x731.value)), ((-1.0)*gconst11*(x732.value)));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x733=IKcos(j0);
IkReal x734=IKsin(j0);
IkReal x735=((1.0)*gconst11);
IkReal x736=((-1.0)*gconst11);
evalcond[0]=(new_r10*x733);
evalcond[1]=(new_r11*x734);
evalcond[2]=(x733*x736);
evalcond[3]=(x734*x736);
evalcond[4]=(gconst11+((new_r11*x733)));
evalcond[5]=(new_r11+((gconst11*x733)));
evalcond[6]=((((-1.0)*x734*x735))+new_r10);
evalcond[7]=((((-1.0)*x735))+((new_r10*x734)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x737=IKPowWithIntegerCheck(IKsign(gconst11),-1);
if(!x737.valid){
continue;
}
CheckValue<IkReal> x738 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x738.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x737.value)))+(x738.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x739=IKcos(j0);
IkReal x740=IKsin(j0);
IkReal x741=((1.0)*gconst11);
IkReal x742=((-1.0)*gconst11);
evalcond[0]=(new_r10*x739);
evalcond[1]=(new_r11*x740);
evalcond[2]=(x739*x742);
evalcond[3]=(x740*x742);
evalcond[4]=(gconst11+((new_r11*x739)));
evalcond[5]=(new_r11+((gconst11*x739)));
evalcond[6]=((((-1.0)*x740*x741))+new_r10);
evalcond[7]=(((new_r10*x740))+(((-1.0)*x741)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(new_r01);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
CheckValue<IkReal> x744 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x744.valid){
continue;
}
IkReal x743=((1.0)*(x744.value));
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=gconst10;
cj2=gconst11;
j2=((3.14159265)+(((-1.0)*x743)));
new_r01=0;
IkReal gconst9=((3.14159265358979)+(((-1.0)*x743)));
IkReal gconst10=0;
IkReal x745 = new_r11*new_r11;
if(IKabs(x745)==0){
continue;
}
IkReal gconst11=((-1.0)*new_r11*(pow(x745,-0.5)));
j0eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
CheckValue<IkReal> x747 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x747.valid){
continue;
}
IkReal x746=((1.0)*(x747.value));
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=gconst10;
cj2=gconst11;
j2=((3.14159265)+(((-1.0)*x746)));
new_r01=0;
IkReal gconst9=((3.14159265358979)+(((-1.0)*x746)));
IkReal gconst10=0;
IkReal x748 = new_r11*new_r11;
if(IKabs(x748)==0){
continue;
}
IkReal gconst11=((-1.0)*new_r11*(pow(x748,-0.5)));
j0eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
CheckValue<IkReal> x750 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x750.valid){
continue;
}
IkReal x749=((1.0)*(x750.value));
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=gconst10;
cj2=gconst11;
j2=((3.14159265)+(((-1.0)*x749)));
new_r01=0;
IkReal gconst9=((3.14159265358979)+(((-1.0)*x749)));
IkReal gconst10=0;
IkReal x751 = new_r11*new_r11;
if(IKabs(x751)==0){
continue;
}
IkReal gconst11=((-1.0)*new_r11*(pow(x751,-0.5)));
j0eval[0]=new_r11;
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x752=IKPowWithIntegerCheck(gconst11,-1);
if(!x752.valid){
continue;
}
CheckValue<IkReal> x753=IKPowWithIntegerCheck(new_r11,-1);
if(!x753.valid){
continue;
}
if( IKabs((new_r10*(x752.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst11*(x753.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x752.value)))+IKsqr(((-1.0)*gconst11*(x753.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2((new_r10*(x752.value)), ((-1.0)*gconst11*(x753.value)));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x754=IKsin(j0);
IkReal x755=IKcos(j0);
IkReal x756=(gconst11*x754);
IkReal x757=(gconst11*x755);
evalcond[0]=(new_r11*x754);
evalcond[1]=((-1.0)*x756);
evalcond[2]=(gconst11+((new_r11*x755)));
evalcond[3]=(x757+new_r11);
evalcond[4]=((((-1.0)*x756))+new_r10);
evalcond[5]=((((-1.0)*x757))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x754))+((new_r10*x755)));
evalcond[7]=(((new_r00*x755))+((new_r10*x754))+(((-1.0)*gconst11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x758=IKPowWithIntegerCheck(IKsign(gconst11),-1);
if(!x758.valid){
continue;
}
CheckValue<IkReal> x759 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x759.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x758.value)))+(x759.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x760=IKsin(j0);
IkReal x761=IKcos(j0);
IkReal x762=(gconst11*x760);
IkReal x763=(gconst11*x761);
evalcond[0]=(new_r11*x760);
evalcond[1]=((-1.0)*x762);
evalcond[2]=(((new_r11*x761))+gconst11);
evalcond[3]=(x763+new_r11);
evalcond[4]=((((-1.0)*x762))+new_r10);
evalcond[5]=((((-1.0)*x763))+new_r00);
evalcond[6]=(((new_r10*x761))+(((-1.0)*new_r00*x760)));
evalcond[7]=(((new_r10*x760))+((new_r00*x761))+(((-1.0)*gconst11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x764=IKPowWithIntegerCheck(IKsign(gconst11),-1);
if(!x764.valid){
continue;
}
CheckValue<IkReal> x765 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r00),IKFAST_ATAN2_MAGTHRESH);
if(!x765.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x764.value)))+(x765.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x766=IKsin(j0);
IkReal x767=IKcos(j0);
IkReal x768=(gconst11*x766);
IkReal x769=(gconst11*x767);
evalcond[0]=(new_r11*x766);
evalcond[1]=((-1.0)*x768);
evalcond[2]=(((new_r11*x767))+gconst11);
evalcond[3]=(x769+new_r11);
evalcond[4]=((((-1.0)*x768))+new_r10);
evalcond[5]=((((-1.0)*x769))+new_r00);
evalcond[6]=(((new_r10*x767))+(((-1.0)*new_r00*x766)));
evalcond[7]=(((new_r10*x766))+((new_r00*x767))+(((-1.0)*gconst11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x770=((1.0)*new_r11);
CheckValue<IkReal> x771=IKPowWithIntegerCheck(IKsign(((((-1.0)*gconst11*x770))+((gconst10*new_r01)))),-1);
if(!x771.valid){
continue;
}
CheckValue<IkReal> x772 = IKatan2WithCheck(IkReal(((((-1.0)*new_r01*x770))+((gconst10*gconst11)))),IkReal(((new_r11*new_r11)+(((-1.0)*(gconst10*gconst10))))),IKFAST_ATAN2_MAGTHRESH);
if(!x772.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x771.value)))+(x772.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x773=IKcos(j0);
IkReal x774=IKsin(j0);
IkReal x775=(gconst10*x773);
IkReal x776=(gconst11*x773);
IkReal x777=((1.0)*x774);
IkReal x778=(gconst11*x777);
evalcond[0]=(gconst10+((new_r11*x774))+((new_r01*x773)));
evalcond[1]=(x776+new_r11+((gconst10*x774)));
evalcond[2]=((((-1.0)*new_r00*x777))+gconst10+((new_r10*x773)));
evalcond[3]=((((-1.0)*new_r01*x777))+gconst11+((new_r11*x773)));
evalcond[4]=(x775+(((-1.0)*x778))+new_r10);
evalcond[5]=(x775+(((-1.0)*x778))+new_r01);
evalcond[6]=(((new_r00*x773))+((new_r10*x774))+(((-1.0)*gconst11)));
evalcond[7]=((((-1.0)*gconst10*x777))+new_r00+(((-1.0)*x776)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x779=((1.0)*new_r11);
CheckValue<IkReal> x780=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x780.valid){
continue;
}
CheckValue<IkReal> x781 = IKatan2WithCheck(IkReal((((gconst11*new_r01))+(((-1.0)*gconst10*x779)))),IkReal(((((-1.0)*gconst10*new_r01))+(((-1.0)*gconst11*x779)))),IKFAST_ATAN2_MAGTHRESH);
if(!x781.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x780.value)))+(x781.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x782=IKcos(j0);
IkReal x783=IKsin(j0);
IkReal x784=(gconst10*x782);
IkReal x785=(gconst11*x782);
IkReal x786=((1.0)*x783);
IkReal x787=(gconst11*x786);
evalcond[0]=(((new_r11*x783))+gconst10+((new_r01*x782)));
evalcond[1]=(((gconst10*x783))+x785+new_r11);
evalcond[2]=(((new_r10*x782))+gconst10+(((-1.0)*new_r00*x786)));
evalcond[3]=((((-1.0)*new_r01*x786))+((new_r11*x782))+gconst11);
evalcond[4]=((((-1.0)*x787))+x784+new_r10);
evalcond[5]=((((-1.0)*x787))+x784+new_r01);
evalcond[6]=(((new_r10*x783))+((new_r00*x782))+(((-1.0)*gconst11)));
evalcond[7]=((((-1.0)*x785))+new_r00+(((-1.0)*gconst10*x786)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x788=((1.0)*gconst10);
CheckValue<IkReal> x789 = IKatan2WithCheck(IkReal(((((-1.0)*new_r10*x788))+((gconst10*new_r01)))),IkReal(((((-1.0)*new_r11*x788))+(((-1.0)*new_r00*x788)))),IKFAST_ATAN2_MAGTHRESH);
if(!x789.valid){
continue;
}
CheckValue<IkReal> x790=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x790.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x789.value)+(((1.5707963267949)*(x790.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x791=IKcos(j0);
IkReal x792=IKsin(j0);
IkReal x793=(gconst10*x791);
IkReal x794=(gconst11*x791);
IkReal x795=((1.0)*x792);
IkReal x796=(gconst11*x795);
evalcond[0]=(((new_r11*x792))+gconst10+((new_r01*x791)));
evalcond[1]=(((gconst10*x792))+x794+new_r11);
evalcond[2]=(((new_r10*x791))+gconst10+(((-1.0)*new_r00*x795)));
evalcond[3]=((((-1.0)*new_r01*x795))+((new_r11*x791))+gconst11);
evalcond[4]=((((-1.0)*x796))+x793+new_r10);
evalcond[5]=((((-1.0)*x796))+x793+new_r01);
evalcond[6]=(((new_r10*x792))+((new_r00*x791))+(((-1.0)*gconst11)));
evalcond[7]=((((-1.0)*x794))+new_r00+(((-1.0)*gconst10*x795)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((new_r01*new_r01)+(new_r11*new_r11));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
new_r01=0;
new_r11=0;
j0eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x798 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x798.valid){
continue;
}
IkReal x797=x798.value;
j0array[0]=((-1.0)*x797);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x797)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*new_r00*(IKsin(j0))))+((new_r10*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(new_r10, ((-1.0)*new_r11));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x799=IKcos(j0);
IkReal x800=IKsin(j0);
IkReal x801=((1.0)*x800);
evalcond[0]=(x799+new_r11);
evalcond[1]=(new_r10+(((-1.0)*x801)));
evalcond[2]=((((-1.0)*x799))+new_r00);
evalcond[3]=(new_r01+(((-1.0)*x801)));
evalcond[4]=(((new_r01*x799))+((new_r11*x800)));
evalcond[5]=(((new_r10*x799))+(((-1.0)*new_r00*x801)));
evalcond[6]=((-1.0)+((new_r00*x799))+((new_r10*x800)));
evalcond[7]=((1.0)+(((-1.0)*new_r01*x801))+((new_r11*x799)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r00));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x802=IKsin(j0);
IkReal x803=IKcos(j0);
IkReal x804=((1.0)*x802);
evalcond[0]=(new_r10+x802);
evalcond[1]=(new_r00+x803);
evalcond[2]=(new_r01+x802);
evalcond[3]=((((-1.0)*x803))+new_r11);
evalcond[4]=(((new_r11*x802))+((new_r01*x803)));
evalcond[5]=((((-1.0)*new_r00*x804))+((new_r10*x803)));
evalcond[6]=((1.0)+((new_r00*x803))+((new_r10*x802)));
evalcond[7]=((-1.0)+(((-1.0)*new_r01*x804))+((new_r11*x803)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[3];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
new_r11=0;
new_r00=0;
j0eval[0]=new_r01;
j0eval[1]=IKsign(new_r01);
j0eval[2]=((IKabs(cj2))+(IKabs(sj2)));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
new_r11=0;
new_r00=0;
j0eval[0]=new_r10;
j0eval[1]=((IKabs(cj2))+(IKabs(sj2)));
j0eval[2]=IKsign(new_r10);
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
new_r11=0;
new_r00=0;
j0eval[0]=new_r01;
j0eval[1]=new_r10;
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x805=IKPowWithIntegerCheck(new_r01,-1);
if(!x805.valid){
continue;
}
CheckValue<IkReal> x806=IKPowWithIntegerCheck(new_r10,-1);
if(!x806.valid){
continue;
}
if( IKabs((cj2*(x805.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*sj2*(x806.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((cj2*(x805.value)))+IKsqr(((-1.0)*sj2*(x806.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2((cj2*(x805.value)), ((-1.0)*sj2*(x806.value)));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[7];
IkReal x807=IKcos(j0);
IkReal x808=IKsin(j0);
IkReal x809=((1.0)*cj2);
IkReal x810=(sj2*x807);
IkReal x811=((1.0)*x808);
IkReal x812=(x808*x809);
evalcond[0]=(sj2+((new_r10*x807)));
evalcond[1]=(sj2+((new_r01*x807)));
evalcond[2]=(cj2+(((-1.0)*new_r01*x811)));
evalcond[3]=(((new_r10*x808))+(((-1.0)*x809)));
evalcond[4]=((((-1.0)*x812))+new_r10+x810);
evalcond[5]=((((-1.0)*x807*x809))+(((-1.0)*sj2*x811)));
evalcond[6]=((((-1.0)*x812))+new_r01+x810);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x813=IKPowWithIntegerCheck(IKsign(new_r10),-1);
if(!x813.valid){
continue;
}
CheckValue<IkReal> x814 = IKatan2WithCheck(IkReal(cj2),IkReal(((-1.0)*sj2)),IKFAST_ATAN2_MAGTHRESH);
if(!x814.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x813.value)))+(x814.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[7];
IkReal x815=IKcos(j0);
IkReal x816=IKsin(j0);
IkReal x817=((1.0)*cj2);
IkReal x818=(sj2*x815);
IkReal x819=((1.0)*x816);
IkReal x820=(x816*x817);
evalcond[0]=(sj2+((new_r10*x815)));
evalcond[1]=(sj2+((new_r01*x815)));
evalcond[2]=(cj2+(((-1.0)*new_r01*x819)));
evalcond[3]=(((new_r10*x816))+(((-1.0)*x817)));
evalcond[4]=((((-1.0)*x820))+new_r10+x818);
evalcond[5]=((((-1.0)*x815*x817))+(((-1.0)*sj2*x819)));
evalcond[6]=((((-1.0)*x820))+new_r01+x818);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x821=IKPowWithIntegerCheck(IKsign(new_r01),-1);
if(!x821.valid){
continue;
}
CheckValue<IkReal> x822 = IKatan2WithCheck(IkReal(cj2),IkReal(((-1.0)*sj2)),IKFAST_ATAN2_MAGTHRESH);
if(!x822.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x821.value)))+(x822.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[7];
IkReal x823=IKcos(j0);
IkReal x824=IKsin(j0);
IkReal x825=((1.0)*cj2);
IkReal x826=(sj2*x823);
IkReal x827=((1.0)*x824);
IkReal x828=(x824*x825);
evalcond[0]=(sj2+((new_r10*x823)));
evalcond[1]=(sj2+((new_r01*x823)));
evalcond[2]=(cj2+(((-1.0)*new_r01*x827)));
evalcond[3]=(((new_r10*x824))+(((-1.0)*x825)));
evalcond[4]=((((-1.0)*x828))+new_r10+x826);
evalcond[5]=((((-1.0)*x823*x825))+(((-1.0)*sj2*x827)));
evalcond[6]=((((-1.0)*x828))+new_r01+x826);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
new_r11=0;
new_r01=0;
new_r22=0;
new_r20=0;
j0eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x830 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x830.valid){
continue;
}
IkReal x829=x830.value;
j0array[0]=((-1.0)*x829);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x829)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*new_r00*(IKsin(j0))))+((new_r10*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
j0eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x832 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x832.valid){
continue;
}
IkReal x831=x832.value;
j0array[0]=((-1.0)*x831);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x831)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=(((new_r11*(IKcos(j0))))+(((-1.0)*new_r01*(IKsin(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[3];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
new_r01=0;
new_r10=0;
j0eval[0]=new_r11;
j0eval[1]=IKsign(new_r11);
j0eval[2]=((IKabs(cj2))+(IKabs(sj2)));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
new_r01=0;
new_r10=0;
j0eval[0]=new_r00;
j0eval[1]=new_r11;
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x833=IKPowWithIntegerCheck(new_r00,-1);
if(!x833.valid){
continue;
}
CheckValue<IkReal> x834=IKPowWithIntegerCheck(new_r11,-1);
if(!x834.valid){
continue;
}
if( IKabs((sj2*(x833.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*cj2*(x834.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((sj2*(x833.value)))+IKsqr(((-1.0)*cj2*(x834.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2((sj2*(x833.value)), ((-1.0)*cj2*(x834.value)));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[7];
IkReal x835=IKsin(j0);
IkReal x836=IKcos(j0);
IkReal x837=((1.0)*cj2);
IkReal x838=(sj2*x835);
evalcond[0]=(((new_r11*x836))+cj2);
evalcond[1]=(((new_r11*x835))+sj2);
evalcond[2]=(sj2+(((-1.0)*new_r00*x835)));
evalcond[3]=(((new_r00*x836))+(((-1.0)*x837)));
evalcond[4]=((((-1.0)*x835*x837))+((sj2*x836)));
evalcond[5]=(new_r11+x838+((cj2*x836)));
evalcond[6]=((((-1.0)*x836*x837))+(((-1.0)*x838))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x839=IKPowWithIntegerCheck(IKsign(new_r11),-1);
if(!x839.valid){
continue;
}
CheckValue<IkReal> x840 = IKatan2WithCheck(IkReal(((-1.0)*sj2)),IkReal(((-1.0)*cj2)),IKFAST_ATAN2_MAGTHRESH);
if(!x840.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x839.value)))+(x840.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[7];
IkReal x841=IKsin(j0);
IkReal x842=IKcos(j0);
IkReal x843=((1.0)*cj2);
IkReal x844=(sj2*x841);
evalcond[0]=(cj2+((new_r11*x842)));
evalcond[1]=(sj2+((new_r11*x841)));
evalcond[2]=(sj2+(((-1.0)*new_r00*x841)));
evalcond[3]=(((new_r00*x842))+(((-1.0)*x843)));
evalcond[4]=((((-1.0)*x841*x843))+((sj2*x842)));
evalcond[5]=(((cj2*x842))+new_r11+x844);
evalcond[6]=((((-1.0)*x842*x843))+(((-1.0)*x844))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x845=IKPowWithIntegerCheck(IKsign((((new_r11*sj2))+((cj2*new_r01)))),-1);
if(!x845.valid){
continue;
}
CheckValue<IkReal> x846 = IKatan2WithCheck(IkReal(((-1.0)+(cj2*cj2)+((new_r01*new_r10)))),IkReal(((((-1.0)*cj2*sj2))+(((-1.0)*new_r10*new_r11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x846.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x845.value)))+(x846.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x847=IKcos(j0);
IkReal x848=IKsin(j0);
IkReal x849=((1.0)*cj2);
IkReal x850=(sj2*x847);
IkReal x851=(sj2*x848);
IkReal x852=((1.0)*x848);
IkReal x853=(x848*x849);
evalcond[0]=(sj2+((new_r01*x847))+((new_r11*x848)));
evalcond[1]=(((cj2*x847))+new_r11+x851);
evalcond[2]=(((new_r10*x847))+sj2+(((-1.0)*new_r00*x852)));
evalcond[3]=(cj2+(((-1.0)*new_r01*x852))+((new_r11*x847)));
evalcond[4]=((((-1.0)*x853))+new_r10+x850);
evalcond[5]=((((-1.0)*x853))+new_r01+x850);
evalcond[6]=(((new_r10*x848))+((new_r00*x847))+(((-1.0)*x849)));
evalcond[7]=((((-1.0)*x847*x849))+(((-1.0)*x851))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x854=((1.0)*new_r11);
CheckValue<IkReal> x855 = IKatan2WithCheck(IkReal(((((-1.0)*sj2*x854))+((cj2*new_r01)))),IkReal(((((-1.0)*new_r01*sj2))+(((-1.0)*cj2*x854)))),IKFAST_ATAN2_MAGTHRESH);
if(!x855.valid){
continue;
}
CheckValue<IkReal> x856=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x856.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x855.value)+(((1.5707963267949)*(x856.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x857=IKcos(j0);
IkReal x858=IKsin(j0);
IkReal x859=((1.0)*cj2);
IkReal x860=(sj2*x857);
IkReal x861=(sj2*x858);
IkReal x862=((1.0)*x858);
IkReal x863=(x858*x859);
evalcond[0]=(sj2+((new_r11*x858))+((new_r01*x857)));
evalcond[1]=(((cj2*x857))+new_r11+x861);
evalcond[2]=(sj2+(((-1.0)*new_r00*x862))+((new_r10*x857)));
evalcond[3]=(cj2+(((-1.0)*new_r01*x862))+((new_r11*x857)));
evalcond[4]=((((-1.0)*x863))+new_r10+x860);
evalcond[5]=((((-1.0)*x863))+new_r01+x860);
evalcond[6]=((((-1.0)*x859))+((new_r10*x858))+((new_r00*x857)));
evalcond[7]=((((-1.0)*x861))+new_r00+(((-1.0)*x857*x859)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x864=((1.0)*sj2);
CheckValue<IkReal> x865 = IKatan2WithCheck(IkReal((((new_r01*sj2))+(((-1.0)*new_r10*x864)))),IkReal(((((-1.0)*new_r00*x864))+(((-1.0)*new_r11*x864)))),IKFAST_ATAN2_MAGTHRESH);
if(!x865.valid){
continue;
}
CheckValue<IkReal> x866=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x866.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x865.value)+(((1.5707963267949)*(x866.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x867=IKcos(j0);
IkReal x868=IKsin(j0);
IkReal x869=((1.0)*cj2);
IkReal x870=(sj2*x867);
IkReal x871=(sj2*x868);
IkReal x872=((1.0)*x868);
IkReal x873=(x868*x869);
evalcond[0]=(((new_r01*x867))+sj2+((new_r11*x868)));
evalcond[1]=(((cj2*x867))+new_r11+x871);
evalcond[2]=(sj2+(((-1.0)*new_r00*x872))+((new_r10*x867)));
evalcond[3]=(cj2+(((-1.0)*new_r01*x872))+((new_r11*x867)));
evalcond[4]=(new_r10+x870+(((-1.0)*x873)));
evalcond[5]=(new_r01+x870+(((-1.0)*x873)));
evalcond[6]=((((-1.0)*x869))+((new_r00*x867))+((new_r10*x868)));
evalcond[7]=((((-1.0)*x871))+new_r00+(((-1.0)*x867*x869)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j0eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j0eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j0eval[0]=((IKabs((new_r10*new_r22)))+(IKabs((new_r00*new_r22))));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x875 = IKatan2WithCheck(IkReal((new_r00*new_r22)),IkReal((new_r10*new_r22)),IKFAST_ATAN2_MAGTHRESH);
if(!x875.valid){
continue;
}
IkReal x874=x875.value;
j0array[0]=((-1.0)*x874);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x874)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x876=IKsin(j0);
IkReal x877=IKcos(j0);
IkReal x878=((1.0)*x876);
IkReal x879=(new_r11*x876);
IkReal x880=(new_r01*x877);
evalcond[0]=(((new_r00*x877))+((new_r10*x876)));
evalcond[1]=(x879+x880);
evalcond[2]=((((-1.0)*new_r00*x878))+((new_r10*x877)));
evalcond[3]=((((-1.0)*new_r01*x878))+((new_r11*x877)));
evalcond[4]=(((new_r22*x880))+((new_r22*x879)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x882 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x882.valid){
continue;
}
IkReal x881=x882.value;
j0array[0]=((-1.0)*x881);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x881)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x883=IKcos(j0);
IkReal x884=IKsin(j0);
IkReal x885=(new_r10*x884);
IkReal x886=((1.0)*x884);
IkReal x887=(new_r00*x883);
evalcond[0]=(x885+x887);
evalcond[1]=(((new_r10*x883))+(((-1.0)*new_r00*x886)));
evalcond[2]=(((new_r11*x883))+(((-1.0)*new_r01*x886)));
evalcond[3]=(((new_r22*x887))+((new_r22*x885)));
evalcond[4]=(((new_r11*new_r22*x884))+((new_r01*new_r22*x883)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x889 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x889.valid){
continue;
}
IkReal x888=x889.value;
j0array[0]=((-1.0)*x888);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x888)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x890=IKcos(j0);
IkReal x891=IKsin(j0);
IkReal x892=((1.0)*x891);
IkReal x893=(new_r11*x891);
IkReal x894=(new_r22*x890);
evalcond[0]=(((new_r01*x890))+x893);
evalcond[1]=(((new_r10*x890))+(((-1.0)*new_r00*x892)));
evalcond[2]=(((new_r11*x890))+(((-1.0)*new_r01*x892)));
evalcond[3]=(((new_r00*x894))+((new_r10*new_r22*x891)));
evalcond[4]=(((new_r01*x894))+((new_r22*x893)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x896=IKPowWithIntegerCheck(sj1,-1);
if(!x896.valid){
continue;
}
IkReal x895=x896.value;
CheckValue<IkReal> x897=IKPowWithIntegerCheck(new_r00,-1);
if(!x897.valid){
continue;
}
if( IKabs((x895*(x897.value)*((((sj1*sj2))+((new_r02*new_r10)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x895)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x895*(x897.value)*((((sj1*sj2))+((new_r02*new_r10))))))+IKsqr((new_r02*x895))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2((x895*(x897.value)*((((sj1*sj2))+((new_r02*new_r10))))), (new_r02*x895));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[18];
IkReal x898=IKcos(j0);
IkReal x899=IKsin(j0);
IkReal x900=((1.0)*sj1);
IkReal x901=((1.0)*sj2);
IkReal x902=((1.0)*cj1);
IkReal x903=(new_r10*x899);
IkReal x904=(cj1*x898);
IkReal x905=(cj1*x899);
IkReal x906=(new_r00*x898);
IkReal x907=((1.0)*x899);
IkReal x908=(new_r11*x899);
IkReal x909=(new_r12*x899);
IkReal x910=(new_r02*x898);
IkReal x911=(new_r01*x898);
evalcond[0]=((((-1.0)*x898*x900))+new_r02);
evalcond[1]=(new_r12+(((-1.0)*x899*x900)));
evalcond[2]=((((-1.0)*new_r02*x907))+((new_r12*x898)));
evalcond[3]=(sj2+((new_r10*x898))+(((-1.0)*new_r00*x907)));
evalcond[4]=(((new_r11*x898))+cj2+(((-1.0)*new_r01*x907)));
evalcond[5]=(((cj2*x905))+((sj2*x898))+new_r10);
evalcond[6]=((((-1.0)*x900))+x910+x909);
evalcond[7]=(((cj1*cj2))+x906+x903);
evalcond[8]=(((cj2*x904))+new_r00+(((-1.0)*x899*x901)));
evalcond[9]=(((cj2*x898))+(((-1.0)*x901*x905))+new_r11);
evalcond[10]=(x911+x908+(((-1.0)*cj1*x901)));
evalcond[11]=((((-1.0)*x901*x904))+new_r01+(((-1.0)*cj2*x907)));
evalcond[12]=(((new_r12*x905))+((new_r02*x904))+(((-1.0)*new_r22*x900)));
evalcond[13]=(((cj1*x903))+(((-1.0)*new_r20*x900))+cj2+((new_r00*x904)));
evalcond[14]=((((-1.0)*x900*x903))+(((-1.0)*x900*x906))+(((-1.0)*new_r20*x902)));
evalcond[15]=((((-1.0)*x900*x908))+(((-1.0)*new_r21*x902))+(((-1.0)*x900*x911)));
evalcond[16]=((1.0)+(((-1.0)*x900*x909))+(((-1.0)*x900*x910))+(((-1.0)*new_r22*x902)));
evalcond[17]=((((-1.0)*x901))+(((-1.0)*new_r21*x900))+((new_r11*x905))+((new_r01*x904)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x912=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x912.valid){
continue;
}
CheckValue<IkReal> x913 = IKatan2WithCheck(IkReal(new_r12),IkReal(new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x913.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x912.value)))+(x913.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[18];
IkReal x914=IKcos(j0);
IkReal x915=IKsin(j0);
IkReal x916=((1.0)*sj1);
IkReal x917=((1.0)*sj2);
IkReal x918=((1.0)*cj1);
IkReal x919=(new_r10*x915);
IkReal x920=(cj1*x914);
IkReal x921=(cj1*x915);
IkReal x922=(new_r00*x914);
IkReal x923=((1.0)*x915);
IkReal x924=(new_r11*x915);
IkReal x925=(new_r12*x915);
IkReal x926=(new_r02*x914);
IkReal x927=(new_r01*x914);
evalcond[0]=((((-1.0)*x914*x916))+new_r02);
evalcond[1]=(new_r12+(((-1.0)*x915*x916)));
evalcond[2]=((((-1.0)*new_r02*x923))+((new_r12*x914)));
evalcond[3]=(sj2+((new_r10*x914))+(((-1.0)*new_r00*x923)));
evalcond[4]=(cj2+((new_r11*x914))+(((-1.0)*new_r01*x923)));
evalcond[5]=(((sj2*x914))+((cj2*x921))+new_r10);
evalcond[6]=((((-1.0)*x916))+x926+x925);
evalcond[7]=(((cj1*cj2))+x922+x919);
evalcond[8]=(((cj2*x920))+new_r00+(((-1.0)*x915*x917)));
evalcond[9]=(((cj2*x914))+new_r11+(((-1.0)*x917*x921)));
evalcond[10]=((((-1.0)*cj1*x917))+x927+x924);
evalcond[11]=((((-1.0)*cj2*x923))+new_r01+(((-1.0)*x917*x920)));
evalcond[12]=((((-1.0)*new_r22*x916))+((new_r02*x920))+((new_r12*x921)));
evalcond[13]=(cj2+(((-1.0)*new_r20*x916))+((new_r00*x920))+((cj1*x919)));
evalcond[14]=((((-1.0)*new_r20*x918))+(((-1.0)*x916*x922))+(((-1.0)*x916*x919)));
evalcond[15]=((((-1.0)*new_r21*x918))+(((-1.0)*x916*x927))+(((-1.0)*x916*x924)));
evalcond[16]=((1.0)+(((-1.0)*new_r22*x918))+(((-1.0)*x916*x926))+(((-1.0)*x916*x925)));
evalcond[17]=((((-1.0)*new_r21*x916))+(((-1.0)*x917))+((new_r01*x920))+((new_r11*x921)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x928=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x928.valid){
continue;
}
CheckValue<IkReal> x929 = IKatan2WithCheck(IkReal(new_r12),IkReal(new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x929.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x928.value)))+(x929.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[8];
IkReal x930=IKcos(j0);
IkReal x931=IKsin(j0);
IkReal x932=((1.0)*cj1);
IkReal x933=((1.0)*sj1);
IkReal x934=(new_r12*x931);
IkReal x935=(new_r02*x930);
evalcond[0]=((((-1.0)*x930*x933))+new_r02);
evalcond[1]=((((-1.0)*x931*x933))+new_r12);
evalcond[2]=((((-1.0)*new_r02*x931))+((new_r12*x930)));
evalcond[3]=(x935+x934+(((-1.0)*x933)));
evalcond[4]=((((-1.0)*new_r22*x933))+((cj1*x935))+((cj1*x934)));
evalcond[5]=((((-1.0)*new_r00*x930*x933))+(((-1.0)*new_r10*x931*x933))+(((-1.0)*new_r20*x932)));
evalcond[6]=((((-1.0)*new_r21*x932))+(((-1.0)*new_r11*x931*x933))+(((-1.0)*new_r01*x930*x933)));
evalcond[7]=((1.0)+(((-1.0)*new_r22*x932))+(((-1.0)*x933*x935))+(((-1.0)*x933*x934)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j2eval[3];
j2eval[0]=sj1;
j2eval[1]=IKsign(sj1);
j2eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
j2eval[0]=sj1;
j2eval[1]=cj0;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
j2eval[0]=sj1;
j2eval[1]=cj1;
j2eval[2]=sj0;
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r21;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x936=((1.0)*cj0);
if( IKabs((((new_r00*sj0))+(((-1.0)*new_r10*x936)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r00*x936))+(((-1.0)*new_r10*sj0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r00*sj0))+(((-1.0)*new_r10*x936))))+IKsqr(((((-1.0)*new_r00*x936))+(((-1.0)*new_r10*sj0))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((new_r00*sj0))+(((-1.0)*new_r10*x936))), ((((-1.0)*new_r00*x936))+(((-1.0)*new_r10*sj0))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x937=IKcos(j2);
IkReal x938=IKsin(j2);
IkReal x939=((1.0)*sj0);
IkReal x940=(cj0*x937);
IkReal x941=(cj0*x938);
IkReal x942=(x938*x939);
evalcond[0]=(((new_r10*sj0))+((cj0*new_r00))+x937);
evalcond[1]=((((-1.0)*new_r00*x939))+((cj0*new_r10))+x938);
evalcond[2]=((((-1.0)*new_r01*x939))+((cj0*new_r11))+x937);
evalcond[3]=(((sj0*x937))+new_r10+x941);
evalcond[4]=(((new_r11*sj0))+(((-1.0)*x938))+((cj0*new_r01)));
evalcond[5]=((((-1.0)*x942))+new_r00+x940);
evalcond[6]=((((-1.0)*x942))+new_r11+x940);
evalcond[7]=((((-1.0)*x941))+(((-1.0)*x937*x939))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r21;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x943=((1.0)*cj0);
if( IKabs(((((-1.0)*new_r10*x943))+(((-1.0)*new_r11*sj0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r10*sj0))+(((-1.0)*new_r11*x943)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r10*x943))+(((-1.0)*new_r11*sj0))))+IKsqr((((new_r10*sj0))+(((-1.0)*new_r11*x943))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*new_r10*x943))+(((-1.0)*new_r11*sj0))), (((new_r10*sj0))+(((-1.0)*new_r11*x943))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x944=IKsin(j2);
IkReal x945=IKcos(j2);
IkReal x946=((1.0)*sj0);
IkReal x947=(cj0*x944);
IkReal x948=((1.0)*x945);
IkReal x949=(x945*x946);
evalcond[0]=(((new_r11*sj0))+((cj0*new_r01))+x944);
evalcond[1]=(((cj0*new_r10))+(((-1.0)*new_r00*x946))+x944);
evalcond[2]=((((-1.0)*new_r01*x946))+((cj0*new_r11))+x945);
evalcond[3]=((((-1.0)*x948))+((new_r10*sj0))+((cj0*new_r00)));
evalcond[4]=(((cj0*x945))+((sj0*x944))+new_r11);
evalcond[5]=((((-1.0)*x949))+new_r10+x947);
evalcond[6]=((((-1.0)*x949))+new_r01+x947);
evalcond[7]=((((-1.0)*x944*x946))+(((-1.0)*cj0*x948))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x950=IKsin(j2);
IkReal x951=IKcos(j2);
IkReal x952=((1.0)*sj0);
evalcond[0]=(new_r21+x950);
evalcond[1]=((((-1.0)*x951))+new_r20);
evalcond[2]=(((new_r02*x950))+new_r10);
evalcond[3]=(new_r11+((cj0*x951)));
evalcond[4]=((((-1.0)*x950*x952))+new_r00);
evalcond[5]=((((-1.0)*x951*x952))+new_r01);
evalcond[6]=((((-1.0)*new_r00*x952))+((cj0*new_r10))+x950);
evalcond[7]=((((-1.0)*new_r01*x952))+((cj0*new_r11))+x951);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x953=IKcos(j2);
IkReal x954=IKsin(j2);
IkReal x955=((1.0)*sj0);
IkReal x956=((1.0)*x954);
evalcond[0]=(new_r20+x953);
evalcond[1]=(new_r21+(((-1.0)*x956)));
evalcond[2]=(new_r11+((cj0*x953)));
evalcond[3]=(new_r10+(((-1.0)*new_r02*x956)));
evalcond[4]=(new_r00+(((-1.0)*x954*x955)));
evalcond[5]=((((-1.0)*x953*x955))+new_r01);
evalcond[6]=((((-1.0)*new_r00*x955))+((cj0*new_r10))+x954);
evalcond[7]=((((-1.0)*new_r01*x955))+((cj0*new_r11))+x953);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j0))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x957=IKsin(j2);
IkReal x958=IKcos(j2);
IkReal x959=((1.0)*sj1);
IkReal x960=((1.0)*x957);
evalcond[0]=(new_r10+x957);
evalcond[1]=(new_r11+x958);
evalcond[2]=(((sj1*x957))+new_r21);
evalcond[3]=(((cj1*x958))+new_r00);
evalcond[4]=((((-1.0)*x958*x959))+new_r20);
evalcond[5]=((((-1.0)*cj1*x960))+new_r01);
evalcond[6]=(((cj1*new_r00))+x958+(((-1.0)*new_r20*x959)));
evalcond[7]=((((-1.0)*new_r21*x959))+((cj1*new_r01))+(((-1.0)*x960)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j0)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r10, new_r11);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x961=IKsin(j2);
IkReal x962=IKcos(j2);
IkReal x963=((1.0)*sj1);
IkReal x964=((1.0)*new_r00);
IkReal x965=((1.0)*new_r01);
IkReal x966=((1.0)*x961);
evalcond[0]=(((sj1*x961))+new_r21);
evalcond[1]=((((-1.0)*new_r10))+x961);
evalcond[2]=((((-1.0)*new_r11))+x962);
evalcond[3]=((((-1.0)*x962*x963))+new_r20);
evalcond[4]=(((cj1*x962))+(((-1.0)*x964)));
evalcond[5]=((((-1.0)*cj1*x966))+(((-1.0)*x965)));
evalcond[6]=((((-1.0)*cj1*x964))+x962+(((-1.0)*new_r20*x963)));
evalcond[7]=((((-1.0)*cj1*x965))+(((-1.0)*new_r21*x963))+(((-1.0)*x966)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j0)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(new_r00, new_r01);
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x967=IKsin(j2);
IkReal x968=IKcos(j2);
IkReal x969=((1.0)*sj1);
IkReal x970=((1.0)*x967);
evalcond[0]=(((sj1*x967))+new_r21);
evalcond[1]=((((-1.0)*new_r00))+x967);
evalcond[2]=((((-1.0)*new_r01))+x968);
evalcond[3]=(((cj1*x968))+new_r10);
evalcond[4]=((((-1.0)*x968*x969))+new_r20);
evalcond[5]=((((-1.0)*cj1*x970))+new_r11);
evalcond[6]=(((cj1*new_r10))+x968+(((-1.0)*new_r20*x969)));
evalcond[7]=((((-1.0)*new_r21*x969))+((cj1*new_r11))+(((-1.0)*x970)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j0)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x971=IKsin(j2);
IkReal x972=IKcos(j2);
IkReal x973=((1.0)*new_r11);
IkReal x974=((1.0)*sj1);
IkReal x975=((1.0)*new_r10);
IkReal x976=((1.0)*x971);
evalcond[0]=(new_r00+x971);
evalcond[1]=(new_r01+x972);
evalcond[2]=(((sj1*x971))+new_r21);
evalcond[3]=((((-1.0)*x972*x974))+new_r20);
evalcond[4]=(((cj1*x972))+(((-1.0)*x975)));
evalcond[5]=((((-1.0)*cj1*x976))+(((-1.0)*x973)));
evalcond[6]=((((-1.0)*cj1*x975))+(((-1.0)*new_r20*x974))+x972);
evalcond[7]=((((-1.0)*cj1*x973))+(((-1.0)*new_r21*x974))+(((-1.0)*x976)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j2eval[0]=IKabs(new_r22);
if( IKabs(j2eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j2]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=((-1.0)*new_r22);
op[1]=0;
op[2]=new_r22;
polyroots2(op,zeror,numroots);
IkReal j2array[2], cj2array[2], sj2array[2], tempj2array[1];
int numsolutions = 0;
for(int ij2 = 0; ij2 < numroots; ++ij2)
{
IkReal htj2 = zeror[ij2];
tempj2array[0]=((2.0)*(atan(htj2)));
for(int kj2 = 0; kj2 < 1; ++kj2)
{
j2array[numsolutions] = tempj2array[kj2];
if( j2array[numsolutions] > IKPI )
{
    j2array[numsolutions]-=IK2PI;
}
else if( j2array[numsolutions] < -IKPI )
{
    j2array[numsolutions]+=IK2PI;
}
sj2array[numsolutions] = IKsin(j2array[numsolutions]);
cj2array[numsolutions] = IKcos(j2array[numsolutions]);
numsolutions++;
}
}
bool j2valid[2]={true,true};
_nj2 = 2;
for(int ij2 = 0; ij2 < numsolutions; ++ij2)
    {
if( !j2valid[ij2] )
{
    continue;
}
    j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
htj2 = IKtan(j2/2);

_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < numsolutions; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x978=IKPowWithIntegerCheck(sj1,-1);
if(!x978.valid){
continue;
}
IkReal x977=x978.value;
CheckValue<IkReal> x979=IKPowWithIntegerCheck(cj1,-1);
if(!x979.valid){
continue;
}
CheckValue<IkReal> x980=IKPowWithIntegerCheck(sj0,-1);
if(!x980.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*x977)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x977*(x979.value)*(x980.value)*((((cj0*new_r21))+(((-1.0)*new_r10*sj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*x977))+IKsqr((x977*(x979.value)*(x980.value)*((((cj0*new_r21))+(((-1.0)*new_r10*sj1))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r21*x977), (x977*(x979.value)*(x980.value)*((((cj0*new_r21))+(((-1.0)*new_r10*sj1))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[12];
IkReal x981=IKsin(j2);
IkReal x982=IKcos(j2);
IkReal x983=((1.0)*sj0);
IkReal x984=((1.0)*sj1);
IkReal x985=(cj0*new_r00);
IkReal x986=(cj1*sj0);
IkReal x987=(cj0*new_r01);
IkReal x988=(cj1*x982);
IkReal x989=(cj1*x981);
evalcond[0]=(((sj1*x981))+new_r21);
evalcond[1]=((((-1.0)*x982*x984))+new_r20);
evalcond[2]=((((-1.0)*new_r00*x983))+((cj0*new_r10))+x981);
evalcond[3]=((((-1.0)*new_r01*x983))+((cj0*new_r11))+x982);
evalcond[4]=(((new_r10*sj0))+x988+x985);
evalcond[5]=(((x982*x986))+new_r10+((cj0*x981)));
evalcond[6]=((((-1.0)*x989))+((new_r11*sj0))+x987);
evalcond[7]=((((-1.0)*x981*x983))+new_r00+((cj0*x988)));
evalcond[8]=(new_r11+((cj0*x982))+(((-1.0)*x983*x989)));
evalcond[9]=((((-1.0)*x982*x983))+new_r01+(((-1.0)*cj0*x989)));
evalcond[10]=((((-1.0)*new_r20*x984))+((cj1*x985))+((new_r10*x986))+x982);
evalcond[11]=((((-1.0)*new_r21*x984))+((cj1*x987))+(((-1.0)*x981))+((new_r11*x986)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x991=IKPowWithIntegerCheck(sj1,-1);
if(!x991.valid){
continue;
}
IkReal x990=x991.value;
CheckValue<IkReal> x992=IKPowWithIntegerCheck(cj0,-1);
if(!x992.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*x990)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x990*(x992.value)*(((((-1.0)*cj1*new_r21*sj0))+(((-1.0)*new_r11*sj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*x990))+IKsqr((x990*(x992.value)*(((((-1.0)*cj1*new_r21*sj0))+(((-1.0)*new_r11*sj1))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.0)*new_r21*x990), (x990*(x992.value)*(((((-1.0)*cj1*new_r21*sj0))+(((-1.0)*new_r11*sj1))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[12];
IkReal x993=IKsin(j2);
IkReal x994=IKcos(j2);
IkReal x995=((1.0)*sj0);
IkReal x996=((1.0)*sj1);
IkReal x997=(cj0*new_r00);
IkReal x998=(cj1*sj0);
IkReal x999=(cj0*new_r01);
IkReal x1000=(cj1*x994);
IkReal x1001=(cj1*x993);
evalcond[0]=(new_r21+((sj1*x993)));
evalcond[1]=((((-1.0)*x994*x996))+new_r20);
evalcond[2]=((((-1.0)*new_r00*x995))+((cj0*new_r10))+x993);
evalcond[3]=((((-1.0)*new_r01*x995))+((cj0*new_r11))+x994);
evalcond[4]=(x1000+((new_r10*sj0))+x997);
evalcond[5]=(((x994*x998))+((cj0*x993))+new_r10);
evalcond[6]=((((-1.0)*x1001))+((new_r11*sj0))+x999);
evalcond[7]=(((cj0*x1000))+new_r00+(((-1.0)*x993*x995)));
evalcond[8]=((((-1.0)*x1001*x995))+((cj0*x994))+new_r11);
evalcond[9]=((((-1.0)*x994*x995))+(((-1.0)*cj0*x1001))+new_r01);
evalcond[10]=(((cj1*x997))+((new_r10*x998))+(((-1.0)*new_r20*x996))+x994);
evalcond[11]=((((-1.0)*x993))+((cj1*x999))+((new_r11*x998))+(((-1.0)*new_r21*x996)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x1002 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),IkReal(new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x1002.valid){
continue;
}
CheckValue<IkReal> x1003=IKPowWithIntegerCheck(IKsign(sj1),-1);
if(!x1003.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x1002.value)+(((1.5707963267949)*(x1003.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[12];
IkReal x1004=IKsin(j2);
IkReal x1005=IKcos(j2);
IkReal x1006=((1.0)*sj0);
IkReal x1007=((1.0)*sj1);
IkReal x1008=(cj0*new_r00);
IkReal x1009=(cj1*sj0);
IkReal x1010=(cj0*new_r01);
IkReal x1011=(cj1*x1005);
IkReal x1012=(cj1*x1004);
evalcond[0]=(((sj1*x1004))+new_r21);
evalcond[1]=((((-1.0)*x1005*x1007))+new_r20);
evalcond[2]=(x1004+(((-1.0)*new_r00*x1006))+((cj0*new_r10)));
evalcond[3]=(x1005+(((-1.0)*new_r01*x1006))+((cj0*new_r11)));
evalcond[4]=(x1011+x1008+((new_r10*sj0)));
evalcond[5]=(((cj0*x1004))+((x1005*x1009))+new_r10);
evalcond[6]=(x1010+((new_r11*sj0))+(((-1.0)*x1012)));
evalcond[7]=(((cj0*x1011))+(((-1.0)*x1004*x1006))+new_r00);
evalcond[8]=((((-1.0)*x1006*x1012))+((cj0*x1005))+new_r11);
evalcond[9]=((((-1.0)*cj0*x1012))+(((-1.0)*x1005*x1006))+new_r01);
evalcond[10]=(x1005+((new_r10*x1009))+(((-1.0)*new_r20*x1007))+((cj1*x1008)));
evalcond[11]=((((-1.0)*x1004))+((new_r11*x1009))+(((-1.0)*new_r21*x1007))+((cj1*x1010)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "<robot:GenericRobot - iiwa14 (adad6d3183863605f3e7f408f7a58e1b)>"; }

IKFAST_API const char* GetIkFastVersion() { return "0x1000004a"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
